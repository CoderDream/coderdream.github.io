

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/babyking_v4_128_128.png">
  <link rel="icon" href="/img/babyking_v4_128_128.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="CoderDream">
  <meta name="keywords" content="">
  
    <meta name="description" content="Jenkins持续集成入门到精通1、持续集成及Jenkins介绍软件开发生命周期 软件开发生命周期又叫做SDLC（Software Development Life Cycle），它是集合了计划、开发、测试和部署过程的集合。如下图所示 ：       需求分析  这是生命周期的第一阶段，根据项目需求，团队执行一个可行性计划的分析。项目需求可能是公司内部或者客户提出的。这阶段主要是对信息的收集，也有">
<meta property="og:type" content="article">
<meta property="og:title" content="Jenkins持续集成入门到精通">
<meta property="og:url" content="http://coderdream.github.io/2024/01/31/jenkins-cicd/index.html">
<meta property="og:site_name" content="CoderDream Studio">
<meta property="og:description" content="Jenkins持续集成入门到精通1、持续集成及Jenkins介绍软件开发生命周期 软件开发生命周期又叫做SDLC（Software Development Life Cycle），它是集合了计划、开发、测试和部署过程的集合。如下图所示 ：       需求分析  这是生命周期的第一阶段，根据项目需求，团队执行一个可行性计划的分析。项目需求可能是公司内部或者客户提出的。这阶段主要是对信息的收集，也有">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://coderdream.github.io/images/jenkins-cicd_index_img.jpg">
<meta property="article:published_time" content="2024-01-31T06:01:03.000Z">
<meta property="article:modified_time" content="2024-01-31T06:29:36.685Z">
<meta property="article:author" content="CoderDream">
<meta property="article:tag" content="Jenkins">
<meta property="article:tag" content="CICD - Docker - k8s - SpringCloud">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://coderdream.github.io/images/jenkins-cicd_index_img.jpg">
  
  
  
  <title>Jenkins持续集成入门到精通 - CoderDream Studio</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"coderdream.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>CoderDream</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Jenkins持续集成入门到精通"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-01-31 14:01" pubdate>
          2024年1月31日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          8.5k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          71 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Jenkins持续集成入门到精通</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Jenkins持续集成入门到精通"><a href="#Jenkins持续集成入门到精通" class="headerlink" title="Jenkins持续集成入门到精通"></a><strong>Jenkins</strong>持续集成入门到精通</h1><h2 id="1、持续集成及Jenkins介绍"><a href="#1、持续集成及Jenkins介绍" class="headerlink" title="1、持续集成及Jenkins介绍"></a>1、持续集成及<strong>Jenkins</strong>介绍</h2><p>软件开发生命周期</p>
<p>软件开发生命周期又叫做<strong>SDLC</strong>（Software Development Life Cycle），它是集合了计划、开发、测试和部署过程的集合。如下图所示 ：</p>
 <img src="/2024/01/31/jenkins-cicd/image-20240128162257533.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128162257533">



<ul>
<li>需求分析</li>
</ul>
<p>这是生命周期的第一阶段，根据项目需求，团队执行一个可行性计划的分析。项目需求可能是公司内部或者客户提出的。这阶段主要是对信息的收集，也有可能是对现有项目的改善和重新做一个新的项目。还要分析项目的预算多长，可以从哪方面受益及布局，这也是项目创建的目标。</p>
<ul>
<li>设计</li>
</ul>
<p>第二阶段就是设计阶段，系统架构和满意状态（就是要做成什么样子，有什么功能），和创建一个项目计划。计划可以使用图表，布局设计或者文者的方式呈现。</p>
<ul>
<li>实现</li>
</ul>
<p>第三阶段就是实现阶段，项目经理创建和分配工作给开者，开发者根据任务和在设计阶段定义的目标进行开发代码。依据项目的大小和复杂程度，可以需要数月或更长时间才能完成。</p>
<ul>
<li>测试</li>
</ul>
<p>测试人员进行代码测试 ，包括功能测试、代码测试、压力测试等。</p>
<ul>
<li>进化</li>
</ul>
<p>最后进阶段就是对产品不断的进化改进和维护阶段，根据用户的使用情况，可能需要对某功能进行修改，bug修复，功能增加等。</p>
<h3 id="软件开发瀑布模型"><a href="#软件开发瀑布模型" class="headerlink" title="软件开发瀑布模型"></a>软件开发瀑布模型</h3><p>瀑布模型是最著名和最常使用的软件开发模型。瀑布模型就是一系列的软件开发过程。它是由制造业繁衍出来的。一个高度化的结构流程在一个方向上流动，有点像生产线一样。在瀑布模型创建之初，没有其它开发的模型，有很多东西全靠开发人员去猜测，去开发。这样的模型仅适用于那些简单的软件开 发， 但是已经不适合现在的开发了。</p>
<p>下图对软件开发模型的一个阐述。</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128162617664.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128162617664">

<table>
<thead>
<tr>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody><tr>
<td>简单易用和理解</td>
<td>各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量。</td>
</tr>
<tr>
<td>当前一阶段完成后，您只需要去关注后续阶段。</td>
<td>由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发风险。</td>
</tr>
<tr>
<td>为项目提供了按阶段划分的检查节点</td>
<td>瀑布模型的突出缺点是不适应用户需求的变化。</td>
</tr>
</tbody></table>
<h3 id="软件的敏捷开发"><a href="#软件的敏捷开发" class="headerlink" title="软件的敏捷开发"></a>软件的敏捷开发</h3><h4 id="什么是敏捷开发？"><a href="#什么是敏捷开发？" class="headerlink" title="什么是敏捷开发？"></a>什么是敏捷开发？</h4><p>敏捷开发（Agile Development） 的核心是迭代开发（Iterative Development） 与 增量开发</p>
<p>（Incremental Development） 。</p>
<ul>
<li><strong>何为迭代开发？</strong></li>
</ul>
<p>对于大型软件项目，传统的开发方式是采用一个大周期（比如一年）进行开发，整个过程就是一次”大开发”；迭代开发的方式则不一样，它将开发过程拆分成多个小周期，即一次”大开发”变成多次”小开发”，每次小开发都是同样的流程，所以看上去就好像重复在做同样的步骤。</p>
<p>举例来说，SpaceX 公司想造一个大推力火箭，将人类送到火星。但是，它不是一开始就造大火箭，而是先造一个最简陋的小火箭 Falcon 1。结果，第一次发射就爆炸了，直到第四次发射，才成功进入轨道。然后，开发了中型火箭 Falcon 9，九年中发射了70次。最后，才开发 Falcon 重型火箭。如果 SpaceX 不采用迭代开发，它可能直到现在还无法上天。</p>
<ul>
<li><strong>何为增量开发？</strong></li>
</ul>
<p>软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代。</p>
<p>举例来说，房产公司开发一个10栋楼的小区。如果采用增量开发的模式，该公司第一个迭代就是交付一号楼，第二个迭代交付二号楼 每个迭代都是完成一栋完整的楼。而不是第一个迭代挖好10栋楼的地</p>
<p>基，第二个迭代建好每栋楼的骨架，第三个迭代架设屋顶……</p>
<h4 id="敏捷开发如何迭代？"><a href="#敏捷开发如何迭代？" class="headerlink" title="敏捷开发如何迭代？"></a>敏捷开发如何迭代？</h4><p>虽然敏捷开发将软件开发分成多个迭代，但是也要求，每次迭代都是一个完整的软件开发周期，必须按照软件工程的方法论，进行正规的流程管理。</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128162738311.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128162738311">

<h4 id="敏捷开发有什么好处？"><a href="#敏捷开发有什么好处？" class="headerlink" title="敏捷开发有什么好处？"></a>敏捷开发有什么好处？</h4><ul>
<li><strong>早期交付</strong></li>
</ul>
<p>敏捷开发的第一个好处，就是早期交付，从而大大降低成本。 还是以上一节的房产公司为例，如果按照传统的”瀑布开发模式”，先挖10栋楼的地基、再盖骨架、然后架设屋顶，每个阶段都等到前一个阶段完成后开始，可能需要两年才能一次性交付10栋楼。也就是说，如果不考虑预售，该项目必须等到两年后才能回款。 敏捷开发是六个月后交付一号楼，后面每两个月交付一栋楼。因此，半年就能回款10%，后面每个月都会有现金流，资金压力就大大减轻了。</p>
<ul>
<li><strong>降低风险</strong></li>
</ul>
<p>敏捷开发的第二个好处是，及时了解市场需求，降低产品不适用的风险。 请想一想，哪一种情况损失比较小：10栋楼都造好以后，才发现卖不出去，还是造好第一栋楼，就发现卖不出去，从而改进或停建后面9栋楼？</p>
<h3 id="什么是持续集成"><a href="#什么是持续集成" class="headerlink" title="什么是持续集成"></a>什么是持续集成</h3><p>持续集成（ Continuous integration ， 简称 CI ）指的是，频繁地（一天多次）将代码集成到主干。</p>
<p>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</p>
<p>通过持续集成， 团队可以快速的从一个功能到另一个功能，简而言之，敏捷软件开发很大一部分都要归功于持续集成。</p>
<ul>
<li><strong>持续集成的流程</strong></li>
</ul>
<img src="/2024/01/31/jenkins-cicd/image-20240128162839909.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128162839909">

<p>根据持续集成的设计，代码从提交到生产，整个过程有以下几步。</p>
<ul>
<li>提交</li>
</ul>
<p>流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交（commit）。</p>
<ul>
<li>测试（第一轮）</li>
</ul>
<p>代码仓库对commit操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。</p>
<ul>
<li>构建</li>
</ul>
<p>通过第一轮测试，代码就可以合并进主干，就算可以交付了。</p>
<p>交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等。</p>
<ul>
<li>测试（第二轮）</li>
</ul>
<p>构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。</p>
<ul>
<li>部署</li>
</ul>
<p>过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（tar ﬁlename.tar * ）存档，发到生产服务器。</p>
<ul>
<li>回滚</li>
</ul>
<p>一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。</p>
<h3 id="持续集成的组成要素"><a href="#持续集成的组成要素" class="headerlink" title="持续集成的组成要素"></a>持续集成的组成要素</h3><ul>
<li>一个自动构建过程， 从检出代码、 编译构建、 运行测试、 结果记录、 测试统计等都是自动完成的， 无需人工干预。</li>
<li>一个代码存储库，即需要版本控制软件来保障代码的可维护性，同时作为构建过程的素材库，一般使用SVN或Git。</li>
<li>一个持续集成服务器， Jenkins 就是一个配置简单和使用方便的持续集成服务器。</li>
</ul>
<img src="/2024/01/31/jenkins-cicd/image-20240128163046909.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128163046909">



<p>持续集成的好处</p>
<p>1、降低风险，由于持续集成不断去构建，编译和测试，可以很早期发现问题，所以修复的代价就少；</p>
<p>2、对系统健康持续检查，减少发布风险带来的问题；</p>
<p>3、减少重复性工作；</p>
<p>4、持续部署，提供可部署单元包；</p>
<p>5、持续交付可供使用的版本；</p>
<p>6、增强团队信心；</p>
<h3 id="Jenkins介绍"><a href="#Jenkins介绍" class="headerlink" title="Jenkins介绍"></a>Jenkins<strong>介绍</strong></h3> <img src="/2024/01/31/jenkins-cicd/image-20240128163113614.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128163113614">

<p>Jenkins 是一款流行的开源持续集成（Continuous Integration）工具，广泛用于项目开发，具有自动化构建、测试和部署等功能。官网： <a target="_blank" rel="noopener" href="http://jenkins-ci.org/">http://jenkins-ci.org/</a>。</p>
<p>Jenkins的特征：</p>
<ul>
<li>开源的Java语言开发持续集成工具，支持持续集成，持续部署。</li>
<li>易于安装部署配置：可通过yum安装,或下载war包以及通过docker容器等快速实现安装部署，可方便web界面配置管理。</li>
<li>消息通知及测试报告：集成RSS&#x2F;E-mail通过RSS发布构建结果或当构建完成时通过e-mail通知，生成JUnit&#x2F;TestNG测试报告。</li>
<li>分布式构建：支持Jenkins能够让多台计算机一起构建&#x2F;测试。</li>
<li>文件识别：Jenkins能够跟踪哪次构建生成哪些jar，哪次构建使用哪个版本的jar等。</li>
<li>丰富的插件支持：支持扩展插件，你可以开发适合自己团队使用的工具，如git，svn，maven，docker等。</li>
</ul>
<h2 id="2、Jenkins安装和持续集成环境配置"><a href="#2、Jenkins安装和持续集成环境配置" class="headerlink" title="2、Jenkins安装和持续集成环境配置"></a>2<strong>、</strong>Jenkins<strong>安装和持续集成环境配置</strong></h2><h3 id="持续集成流程说明"><a href="#持续集成流程说明" class="headerlink" title="持续集成流程说明"></a>持续集成流程说明</h3><img src="/2024/01/31/jenkins-cicd/image-20240128163332042.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128163332042">

<ol>
<li><p>首先，开发人员每天进行代码提交，提交到Git仓库</p>
</li>
<li><p>然后，Jenkins作为持续集成工具，使用Git工具到Git仓库拉取代码到集成服务器，再配合JDK， Maven等软件完成代码编译，代码测试与审查，测试，打包等工作，在这个过程中每一步出错，都重新再执行一次整个流程。</p>
</li>
<li><p>最后，Jenkins把生成的jar或war包分发到测试服务器或者生产服务器，测试人员或用户就可以访问应用。</p>
</li>
</ol>
<p><strong>服务器列表</strong></p>
<p>本课程虚拟机统一采用CentOS7。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>IP<strong>地址</strong></th>
<th>安装的软件</th>
</tr>
</thead>
<tbody><tr>
<td>代码托管服务器</td>
<td>192.168.66.100</td>
<td>Gitlab-12.4.2</td>
</tr>
<tr>
<td>持续集成服务器</td>
<td>192.168.66.101</td>
<td>Jenkins-2.190.3，JDK1.8，Maven3.6.2，Git， SonarQube</td>
</tr>
<tr>
<td>应用测试服务器</td>
<td>192.168.66.102</td>
<td>JDK1.8，Tomcat8.5</td>
</tr>
</tbody></table>
<h3 id="Gitlab代码托管服务器安装"><a href="#Gitlab代码托管服务器安装" class="headerlink" title="Gitlab代码托管服务器安装"></a>Gitlab<strong>代码托管服务器安装</strong></h3><h4 id="Gitlab简介"><a href="#Gitlab简介" class="headerlink" title="Gitlab简介"></a>Gitlab<strong>简介</strong></h4> <img src="/2024/01/31/jenkins-cicd/image-20240128163551876.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128163551876">

<p>官网：<a target="_blank" rel="noopener" href="https://about.gitlab.com/">https://about.gitlab.com/</a></p>
<p>GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务。</p>
<p>GitLab和GitHub一样属于第三方基于Git开发的作品，免费且开源（基于MIT协议），与Github类似，可以注册用户，任意提交你的代码，添加SSHKey等等。不同的是，<strong>GitLab****是可以部署到自己的服务器上，数据库等一切信息都掌握在自己手上，适合团队内部协作开发</strong>，你总不可能把团队内部的智慧总放在别人的服务器上吧？简单来说可把GitLab看作个人版的GitHub。</p>
<h4 id="Gitlab安装"><a href="#Gitlab安装" class="headerlink" title="Gitlab安装"></a>Gitlab<strong>安装</strong></h4><ol>
<li><p>安装相关依赖</p>
 <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">yum -y install policycoreutils openssh-<span class="hljs-keyword">server</span> openssh-clients postﬁx<br></code></pre></td></tr></table></figure>
</li>
<li><p>启动ssh服务&amp;设置为开机启动</p>
 <figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl enable sshd &amp;&amp; sudo <span class="hljs-params">system</span>ctl start sshd<br></code></pre></td></tr></table></figure>
</li>
<li><p>设置postﬁx开机自启，并启动，postﬁx支持gitlab发信功能</p>
 <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">systemctl enable postﬁ<span class="hljs-keyword">x</span> &amp;&amp; systemctl start postﬁ<span class="hljs-keyword">x</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>开放ssh以及http服务，然后重新加载防火墙列表</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ﬁrewall-cmd --add-service=ssh --permanent <br>ﬁrewall-cmd --add-service=http --permanent <br>ﬁrewall-cmd --reload<br><br></code></pre></td></tr></table></figure>

<p>如果关闭防火墙就不需要做以上配置</p>
</li>
<li><p>下载gitlab包，并且安装在线下载安装包：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">wget https://mirrors.tuna.tsinghua.edu.<span class="hljs-keyword">cn</span>/gitlab-<span class="hljs-keyword">ce</span>/yum/el6/gitlab-<span class="hljs-keyword">ce</span>-<span class="hljs-number">12.4</span>.<span class="hljs-number">2</span>-<span class="hljs-keyword">ce</span>.<span class="hljs-number">0</span>.el6.x86_64.rpm<br><br>安装：<br>rpm -i gitlab-<span class="hljs-keyword">ce</span>-<span class="hljs-number">12.4</span>.<span class="hljs-number">2</span>-<span class="hljs-keyword">ce</span>.<span class="hljs-number">0</span>.el6.x86_64.rpm<br></code></pre></td></tr></table></figure>
</li>
<li><p>修改gitlab配置</p>
 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vi <span class="hljs-regexp">/etc/gi</span>tlab/gitlab.rb<br></code></pre></td></tr></table></figure>

<p>修改gitlab访问地址和端口，默认为80，我们改为82</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">external_url</span> <span class="hljs-string">&#x27;http://192.168.66.100:82&#x27;</span><br>nginx[<span class="hljs-string">&#x27;listen_port&#x27;</span>] = <span class="hljs-number">82</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>重载配置及启动gitlab gitlab-ctl reconﬁgure gitlab-ctl restart</p>
</li>
<li><p>把端口添加到防火墙</p>
</li>
</ol>
   <figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">ﬁrewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">zone=public</span> <span class="hljs-literal">--</span><span class="hljs-comment">add</span><span class="hljs-literal">-</span><span class="hljs-comment">port=82/tcp</span> <span class="hljs-literal">--</span><span class="hljs-comment">permanent</span> <br><span class="hljs-comment">ﬁrewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">reload</span><br></code></pre></td></tr></table></figure>

<p>启动成功后，看到以下修改管理员root密码的页面，修改密码后，然后登录即可</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128164107873.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128164107873">

<h4 id="Gitlab添加组、创建用户、创建项目"><a href="#Gitlab添加组、创建用户、创建项目" class="headerlink" title="Gitlab添加组、创建用户、创建项目"></a>Gitlab<strong>添加组、创建用户、创建项目</strong></h4><p>1）创建组</p>
<p>使用管理员 root 创建组，一个组里面可以有多个项目分支，可以将开发添加到组里面进行设置权限，不同的组就是公司不同的开发项目或者服务模块，不同的组添加不同的开发即可实现对开发设置权限的管理</p>
 <img src="/2024/01/31/jenkins-cicd/image-20240128164157994.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128164157994">

 <img src="/2024/01/31/jenkins-cicd/image-20240128164224122.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128164224122">

<p>2）创建用户</p>
<p>创建用户的时候，可以选择Regular或Admin类型。</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128164249515.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128164249515">

<p>创建完用户后，立即修改密码</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128164309630.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128164309630">

<p>3）将用户添加到组中</p>
<p>选择某个用户组，进行Members管理组的成员</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128164322370.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128164322370">

<img src="/2024/01/31/jenkins-cicd/image-20240128164330998.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128164330998">



<img src="/2024/01/31/jenkins-cicd/image-20240128164339785.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128164339785">

<p>Gitlab用户在组里面有5种不同权限：</p>
<p>Guest：可以创建issue、发表评论，不能读写版本库 </p>
<p>Reporter：可以克隆代码，不能提交，QA、PM可以赋予这个权限 </p>
<p>Developer：可以克隆代码、开发、提交、push，普通开发可以赋予这个权限 </p>
<p>Maintainer：可以创建项目、添加tag、保护分支、添加项目成员、编辑项目，核心开发可以赋予这个权限 </p>
<p>Owner：可以设置项目访问权限 - Visibility Level、删除项目、迁移项目、管理组成员，开发组组长可以赋予这个权限</p>
<p>4）在用户组中创建项目</p>
<p>以刚才创建的新用户身份登录到Gitlab，然后在用户组中创建新的项目</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128164501359.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128164501359">

<img src="/2024/01/31/jenkins-cicd/image-20240128164508368.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128164508368">

<h3 id="源码上传到Gitlab仓库"><a href="#源码上传到Gitlab仓库" class="headerlink" title="源码上传到Gitlab仓库"></a>源码上传到<strong>Gitlab</strong>仓库</h3><p>下面来到IDEA开发工具，我们已经准备好一个简单的Web应用准备到集成部署。我们要把源码上传到Gitlab的项目仓库中。</p>
<p>1）项目结构说明</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128164548382.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128164548382">

<p> 我们建立了一个非常简单的web应用，只有一个index.jsp页面，如果部署好，可以访问该页面就成功啦！</p>
<p>2）开启版本控制</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128164652302.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128164652302">

<img src="/2024/01/31/jenkins-cicd/image-20240128164702233.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128164702233">

<p>3）提交代码到本地仓库</p>
<ul>
<li>先Add到缓存区</li>
</ul>
<img src="/2024/01/31/jenkins-cicd/image-20240128164751633.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128164751633">

<ul>
<li><p>再Commit到本地仓库</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128164816549.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128164816549"></li>
</ul>
 <img src="/2024/01/31/jenkins-cicd/image-20240128164829105.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128164829105">

<p>4）推送到Gitlab项目仓库中</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128164858106.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128164858106">

 <img src="/2024/01/31/jenkins-cicd/image-20240128164907470.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128164907470">

<p>这时都Gitlab的项目中拷贝url地址</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128164938278.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128164938278">

 <img src="/2024/01/31/jenkins-cicd/image-20240128164947125.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128164947125">

<p>输入gitlab的用户名和密码，然后就可以把代码推送到远程仓库啦</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128165001477.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128165001477">

<p>刷新gitlab项目</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128165013875.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128165013875">

<h3 id="持续集成环境"><a href="#持续集成环境" class="headerlink" title="持续集成环境"></a>持续集成环境</h3><h4 id="1-Jenkins安装"><a href="#1-Jenkins安装" class="headerlink" title="(1)-Jenkins安装"></a><strong>(1)-Jenkins</strong>安装</h4><p>1）安装JDK</p>
<p>Jenkins需要依赖JDK，所以先安装JDK1.8 </p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">yum</span> install java-<span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">0</span>-openjdk* -y<br></code></pre></td></tr></table></figure>

<p> 安装目录为：&#x2F;usr&#x2F;lib&#x2F;jvm</p>
<p>2）获取jenkins安装包</p>
<p>下载页面：<a target="_blank" rel="noopener" href="https://jenkins.io/zh/download/">https://jenkins.io/zh/download/</a></p>
<p>安装文件：jenkins-2.190.3-1.1.noarch.rpm</p>
<p>3）把安装包上传到192.168.66.101服务器，进行安装  </p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">rpm</span> -ivh jenkins-<span class="hljs-number">2</span>.<span class="hljs-number">190</span>.<span class="hljs-number">3</span>-<span class="hljs-number">1</span>.<span class="hljs-number">1</span>.noarch.rpm<br></code></pre></td></tr></table></figure>

<p>4）修改Jenkins配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/syscoﬁg/jenkins<br></code></pre></td></tr></table></figure>

<p>修改内容如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">JENKINS_USER</span>=<span class="hljs-string">&quot;root&quot;</span><br><span class="hljs-attr">JENKINS_PORT</span>=<span class="hljs-string">&quot;8888&quot;</span><br></code></pre></td></tr></table></figure>

<p>5）启动Jenkins</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> jenkins <br></code></pre></td></tr></table></figure>

<p>6）打开浏览器访问 </p>
<p><a target="_blank" rel="noopener" href="http://192.168.66.101:8888/">http://192.168.66.101:8888</a></p>
<p>注意：本服务器把防火墙关闭了，如果开启防火墙，需要在防火墙添加端口</p>
<p>7）获取并输入admin账户密码</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/jenkins/</span>secrets/initialAdminPassword<br></code></pre></td></tr></table></figure>

<p>8）跳过插件安装</p>
<p>因为Jenkins插件需要连接默认官网下载，速度非常慢，而且经过会失败，所以我们暂时先跳过插件安装</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128165624701.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128165624701">

<img src="/2024/01/31/jenkins-cicd/image-20240128165642921.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128165642921">

<p>9）添加一个管理员账户，并进入Jenkins后台</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128165657325.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128165657325">

<p>保存并完成</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128165711040.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128165711040">

<p>开始使用Jenkins</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128165725865.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128165725865">

<img src="/2024/01/31/jenkins-cicd/image-20240128165732794.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128165732794">

<h4 id="2-Jenkins插件管理"><a href="#2-Jenkins插件管理" class="headerlink" title="(2)-Jenkins插件管理"></a><strong>(2)-Jenkins</strong>插件管理</h4><p>Jenkins本身不提供很多功能，我们可以通过使用插件来满足我们的使用。例如从Gitlab拉取代码，使用 Maven构建项目等功能需要依靠插件完成。接下来演示如何下载插件。</p>
<h5 id="修改Jenkins插件下载地址"><a href="#修改Jenkins插件下载地址" class="headerlink" title="修改Jenkins插件下载地址"></a>修改<strong>Jenkins</strong>插件下载地址</h5><p>Jenkins国外官方插件地址下载速度非常慢，所以可以修改为国内插件地址： Jenkins-&gt;Manage Jenkins-&gt;Manage Plugins，点击Available</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128165923879.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128165923879">

<p>这样做是为了把Jenkins官方的插件列表下载到本地，接着修改地址文件，替换为国内插件地址</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift">cd <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/jenkins/</span>updates<br><br>sed <span class="hljs-operator">-</span>i &#x27;s<span class="hljs-regexp">/http:\/\/updates.jenkins-ci.org\/download/</span>https:\<span class="hljs-regexp">/\/</span>mirrors.tuna.tsinghua.edu.cn\<span class="hljs-regexp">/jenkins/</span>g&#x27; <span class="hljs-keyword">default</span>.json <span class="hljs-operator">&amp;&amp;</span> sed <span class="hljs-operator">-</span>i &#x27;s<span class="hljs-regexp">/http:\/\/www.google.com/</span>https:\<span class="hljs-regexp">/\/</span>www.baidu.com<span class="hljs-operator">/</span>g&#x27; <span class="hljs-keyword">default</span>.json<br></code></pre></td></tr></table></figure>

<p>最后，Manage Plugins点击Advanced，把Update Site改为国内插件下载地址</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">https://mirrors.tuna.tsinghua.edu.<span class="hljs-keyword">cn</span>/jenkins/updates/<span class="hljs-keyword">update</span>-<span class="hljs-keyword">center</span>.json<br></code></pre></td></tr></table></figure>

<img src="/2024/01/31/jenkins-cicd/image-20240128170154114.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128170154114">

<p>Sumbit后，在浏览器输入： <a target="_blank" rel="noopener" href="http://192.168.66.101:8888/restart">http://192.168.66.101:8888/restart</a> ，重启Jenkins。</p>
<h5 id="下载中文汉化插件"><a href="#下载中文汉化插件" class="headerlink" title="下载中文汉化插件"></a><strong>下载中文汉化插件</strong></h5><p>Jenkins-&gt;Manage Jenkins-&gt;Manage Plugins，点击Available，搜索”Chinese”</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128170337462.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128170337462">

<p>完成后如下图：</p>
 <img src="/2024/01/31/jenkins-cicd/image-20240128170353822.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128170353822">

<p>重启Jenkins后，就看到Jenkins汉化了！（PS：但可能部分菜单汉化会失败）</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128170346546.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128170346546">

<h4 id="3-Jenkins用户权限管理"><a href="#3-Jenkins用户权限管理" class="headerlink" title="(3)-Jenkins用户权限管理"></a><strong>(3)-Jenkins</strong>用户权限管理</h4><p> 080.jpg)</p>
<p>我们可以利用Role-based Authorization Strategy 插件来管理Jenkins用户权限<strong>安装<strong><strong>Role-based Authorization Strategy</strong></strong>插件</strong></p>
<p>开启权限全局安全配置</p>
<p> 081.jpg)</p>
<p>授权策略切换为”Role-Based Strategy”，保存</p>
<p> 082.jpg)</p>
<p>创建角色</p>
<p>在系统管理页面进入 Manage and Assign Roles</p>
<p> 083.jpg)</p>
<p>点击”Manage Roles”</p>
<p> 084.jpg)</p>
<p>Global roles（全局角色）：管理员等高级用户可以创建基于全局的角色 Project roles（项目角色）：针对某个或者某些项目的角色 Slave roles（奴隶角色）：节点相关的权限</p>
<p>我们添加以下三个角色：</p>
<p> 085.png)</p>
<p> 086.png)</p>
<p> 087.png)</p>
<p>baseRole：该角色为全局角色。这个角色需要绑定Overall下面的Read权限，是为了给所有用户绑定最基本的Jenkins访问权限。注意：如果不给后续用户绑定这个角色，会报错误：用户名 is missing the Overall&#x2F;Read permission role1：该角色为项目角色。使用正则表达式绑定”itcast.<em>“，意思是只能操作itcast开头的项目。 role2：该角色也为项目角色。绑定”itheima.</em>“，意思是只能操作itheima开头的项目。</p>
<p> 088.jpg)</p>
<p>保存。</p>
<p>创建用户</p>
<p>在系统管理页面进入 Manage Users</p>
<p> 089.jpg)</p>
<p> 090.jpg)</p>
<p> 091.jpg)</p>
<p>分别创建两个用户：jack和eric</p>
<p> 092.jpg)</p>
<p>给用户分配角色</p>
<p>系统管理页面进入Manage and Assign Roles，点击Assign Roles</p>
<p>绑定规则如下：</p>
<p> 093.png)</p>
<p> 094.png)</p>
<p>eric用户分别绑定baseRole和role1角色 jack用户分别绑定baseRole和role2角色</p>
<p> 095.jpg)</p>
<p>保存。</p>
<p>创建项目测试权限</p>
<p>以itcast管理员账户创建两个项目，分别为itcast01和itheima01</p>
<p> 096.jpg)</p>
<p>结果为：</p>
<p> 097.png)</p>
<p> 098.png)</p>
<p>eric用户登录，只能看到itcast01项目 jack用户登录，只能看到itheima01项目</p>
<p>持续集成环境**(4)-Jenkins**凭证管理</p>
<p>凭据可以用来存储需要密文保护的数据库密码、Gitlab密码信息、Docker私有仓库密码等，以便</p>
<p>Jenkins可以和这些第三方的应用进行交互。</p>
<p>安装<strong>Credentials Binding</strong>插件</p>
<p>要在Jenkins使用凭证管理功能，需要安装Credentials Binding插件</p>
<p> 099.jpg)</p>
<p>安装插件后，左边多了”凭证”菜单，在这里管理所有凭证</p>
<p> 100.jpg)</p>
<p>可以添加的凭证有5种：</p>
<p> 101.jpg)</p>
<p> 102.png)</p>
<p>Username with password：用户名和密码</p>
<p> 103.png)</p>
<p>SSH Username with private key： 使用SSH用户和密钥</p>
<p> 104.png)</p>
<p>Secret ﬁle：需要保密的文本文件，使用时Jenkins会将文件复制到一个临时目录中，再将文件路径设置到一个变量中，等构建结束后，所复制的Secret ﬁle就会被删除。</p>
<p> 105.png)</p>
<p> 106.png)</p>
<p>Secret text：需要保存的一个加密的文本串，如钉钉机器人或Github的api token Certiﬁcate：通过上传证书文件的方式</p>
<p>常用的凭证类型有：Username with password（用户密码）和SSH Username with private key（SSH</p>
<p>密钥）</p>
<p>接下来以使用Git工具到Gitlab拉取项目源码为例，演示Jenkins的如何管理Gitlab的凭证。<strong>安装<strong><strong>Git</strong></strong>插件和<strong><strong>Git</strong></strong>工具</strong></p>
<p>为了让Jenkins支持从Gitlab拉取源码，需要安装Git插件以及在CentOS7上安装Git工具。</p>
<p>Git插件安装：</p>
<p> 107.jpg)</p>
<p> 108.png)</p>
<p>CentOS7上安装Git工具： yum install git -y 安装</p>
<p>git –version 安装后查看版本</p>
<p>用户密码类型</p>
<ol>
<li><p>创建凭证</p>
<p>Jenkins-&gt;凭证-&gt;系统-&gt;全局凭证-&gt;添加凭证</p>
<p> 109.jpg)</p>
<p> 110.jpg)</p>
<p>选择”Username with password”，输入Gitlab的用户名和密码，点击”确定”。</p>
<p> 111.jpg)</p>
</li>
<li><p>测试凭证是否可用</p>
</li>
</ol>
<p>创建一个FreeStyle项目：新建Item-&gt;FreeStyle Project-&gt;确定</p>
<p> 112.jpg)</p>
<p>找到”源码管理”-&gt;”Git”，在Repository URL复制Gitlab中的项目URL</p>
<p> 113.jpg)</p>
<p> 114.jpg)</p>
<p>这时会报错说无法连接仓库！在Credentials选择刚刚添加的凭证就不报错啦</p>
<p> 115.jpg)</p>
<p>保存配置后，点击构建”Build Now“ 开始构建项目</p>
<p> 116.jpg)</p>
<p> 117.jpg)</p>
<p>查看**&#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;workspace&#x2F;**目录，发现已经从Gitlab成功拉取了代码到Jenkins中。</p>
<p> 118.jpg)</p>
<h4 id="SSH密钥类型"><a href="#SSH密钥类型" class="headerlink" title="SSH密钥类型"></a>SSH<strong>密钥类型</strong></h4><p>SSH免密登录示意图</p>
<p> 119.jpg)</p>
<ol>
<li><p>使用root用户生成公钥和私钥  120.png) ssh-keygen -t rsa</p>
<p>在&#x2F;root&#x2F;.ssh&#x2F;目录保存了公钥和使用</p>
<p> 121.jpg)</p>
<p>id_rsa：私钥文件 id_rsa.pub：公钥文件</p>
</li>
<li><p>把生成的公钥放在Gitlab中</p>
<p>以root账户登录-&gt;点击头像-&gt;Settings-&gt;SSH Keys</p>
<p>复制刚才id_rsa.pub文件的内容到这里，点击”Add Key”</p>
<p> 122.jpg)</p>
</li>
<li><p>在Jenkins中添加凭证，配置私钥</p>
<p>在Jenkins添加一个新的凭证，类型为”SSH Username with private key”，把刚才生成私有文件内容复制过来</p>
<p> 123.jpg)</p>
<p> 124.jpg)</p>
</li>
<li><p>测试凭证是否可用</p>
</li>
</ol>
<p>新建”test02”项目-&gt;源码管理-&gt;Git，这次要使用Gitlab的SSH连接，并且选择SSH凭证</p>
<p> 125.jpg)</p>
<p> 126.jpg)</p>
<p> 127.jpg)</p>
<p>同样尝试构建项目，如果代码可以正常拉取，代表凭证配置成功！</p>
<p> 128.jpg)</p>
<p>持续集成环境**(5)-Maven**安装和配置</p>
<p>在Jenkins集成服务器上，我们需要安装Maven来编译和打包项目。<strong>安装****Maven</strong></p>
<p>先上传Maven软件到192.168.66.101</p>
<p> 129.png)</p>
<p>tar -xzf apache-maven-3.6.2-bin.tar.gz 解压</p>
<p>mkdir -p &#x2F;opt&#x2F;maven 创建目录</p>
<p>mv apache-maven-3.6.2&#x2F;* &#x2F;opt&#x2F;maven 移动文件<strong>配置环境变量</strong></p>
<p> 130.png)</p>
<p>export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdk export MAVEN_HOME&#x3D;&#x2F;opt&#x2F;maven</p>
<p>export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$MAVEN_HOME&#x2F;bin</p>
<p> 131.png) vi &#x2F;etc&#x2F;proﬁle</p>
<p> 132.png)</p>
<p>source &#x2F;etc&#x2F;proﬁle 配置生效</p>
<p>mvn -v 查找Maven版本</p>
<p>全局工具配置关联<strong>JDK</strong>和<strong>Maven</strong></p>
<p>Jenkins-&gt;Global Tool Conﬁguration-&gt;JDK-&gt;新增JDK，配置如下：</p>
<p> 133.jpg)</p>
<p>Jenkins-&gt;Global Tool Conﬁguration-&gt;Maven-&gt;新增Maven，配置如下：</p>
<p> 134.jpg)</p>
<p>添加<strong>Jenkins</strong>全局变量</p>
<p>Manage Jenkins-&gt;Conﬁgure System-&gt;Global Properties ，添加三个全局变量</p>
<p>JAVA_HOME、M2_HOME、PATH+EXTRA</p>
<p> 135.jpg)</p>
<p>修改<strong>Maven</strong>的<strong>settings.xml</strong></p>
<p> 136.png)</p>
<p>mkdir &#x2F;root&#x2F;repo 创建本地仓库目录</p>
<p>vi &#x2F;opt&#x2F;maven&#x2F;conf&#x2F;settings.xml</p>
<p>本地仓库改为：&#x2F;root&#x2F;repo&#x2F;添加阿里云私服地址：</p>
<p> 137.png) <a target="_blank" rel="noopener" href="http://maven.aliyun.com/nexus/content/groups/public/">alimaven aliyun maven </a><a target="_blank" rel="noopener" href="http://maven.aliyun.com/nexus/content/groups/public/">http://maven.al</a><a target="_blank" rel="noopener" href="http://maven.aliyun.com/nexus/content/groups/public/">iy</a><a target="_blank" rel="noopener" href="http://maven.aliyun.com/nexus/content/groups/public/">un.com&#x2F;nexus&#x2F;content&#x2F;</a><a target="_blank" rel="noopener" href="http://maven.aliyun.com/nexus/content/groups/public/">g</a>roups&#x2F;public&#x2F; central</p>
<p>测试<strong>Maven</strong>是否配置成功</p>
<p>使用之前的gitlab密码测试项目，修改配置</p>
<p> 138.jpg)</p>
<p>构建-&gt;增加构建步骤-&gt;Execute Shell</p>
<p> 139.jpg)</p>
<p>输入</p>
<p> 140.png) mvn clean package</p>
<p> 141.jpg)</p>
<p>再次构建，如果可以把项目打成war包，代表maven环境配置成功啦！</p>
<p> 142.jpg)</p>
<p>持续集成环境**(6)-Tomcat**安装和配置</p>
<h3 id="安装Tomcat8-5"><a href="#安装Tomcat8-5" class="headerlink" title="安装Tomcat8.5"></a>安装<strong>Tomcat8.5</strong></h3><p>把Tomcat压缩包上传到192.168.66.102服务器</p>
<p> 143.png)</p>
<p>yum install java-1.8.0-openjdk* -y 安装JDK（已完成）</p>
<p>tar -xzf apache-tomcat-8.5.47.tar.gz 解压</p>
<p>mkdir -p &#x2F;opt&#x2F;tomcat 创建目录</p>
<p> 144.png)</p>
<p>mv &#x2F;root&#x2F;apache-tomcat-8.5.47&#x2F;* &#x2F;opt&#x2F;tomcat 移动文件</p>
<p>&#x2F;opt&#x2F;tomcat&#x2F;bin&#x2F;startup.sh 启动tomcat</p>
<p>注意：服务器已经关闭了防火墙，所以可以直接访问Tomcat<a target="_blank" rel="noopener" href="http://192.168.66.102/8080">啦地址为：</a><a target="_blank" rel="noopener" href="http://192.168.66.102/8080">http://192.168.66.102/8080</a></p>
<p> 145.jpg)</p>
<h3 id="配置Tomcat用户角色权限"><a href="#配置Tomcat用户角色权限" class="headerlink" title="配置Tomcat用户角色权限"></a>配置<strong>Tomcat</strong>用户角色权限</h3><p>默认情况下Tomcat是没有配置用户角色权限的</p>
<p> 146.jpg)</p>
<p> 147.jpg)</p>
<p>但是，后续Jenkins部署项目到Tomcat服务器，需要用到Tomcat的用户，所以修改tomcat以下配置，添加用户及权限</p>
<p> 148.png) vi &#x2F;opt&#x2F;tomcat&#x2F;conf&#x2F;tomcat-users.xml</p>
<p> 149.png)</p>
<tomcat-users>

<role rolename="tomcat"/>

<role rolename="role1"/>

<role rolename="manager-script"/>

<role rolename="manager-gui"/>

<role rolename="manager-status"/>

<role rolename="admin-gui"/>

<role rolename="admin-script"/>

<user username="tomcat" password="tomcat" roles="manager-gui,manager- script,tomcat,admin-gui,admin-script"/>

</tomcat-users>



<p>内容如下：</p>
<p>用户和密码都是：tomcat</p>
<p>注意：为了能够刚才配置的用户登录到Tomcat，还需要修改以下配置</p>
<p> 150.png)</p>
<!--

<Valve className="org.apache.catalina.valves.RemoteAddrValve" allow="127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1" />

-->



<p> 151.png) vi &#x2F;opt&#x2F;tomcat&#x2F;webapps&#x2F;manager&#x2F;META-INF&#x2F;context.xml</p>
<p>把上面这行注释掉即可！重启<strong>Tomcat</strong>，访问测试</p>
<p> 152.png)</p>
<p>&#x2F;opt&#x2F;tomcat&#x2F;bin&#x2F;shutdown.sh 停止</p>
<p>&#x2F;opt&#x2F;tomcat&#x2F;bin&#x2F;startup.sh 启动</p>
<p>访问： <a target="_blank" rel="noopener" href="http://192.168.66.102:8080/manager/html">http://192.168.66.102:8080/manager/html</a> ，输入tomcat和tomcat，看到以下页面代表成功啦</p>
<h2 id="3、Jenkins构建Maven项目"><a href="#3、Jenkins构建Maven项目" class="headerlink" title="3、Jenkins构建Maven项目"></a>3<strong>、</strong>Jenkins<strong>构建</strong>Maven<strong>项目</strong></h2><h3 id="Jenkins项目构建类型-1-Jenkins构建的项目类型介绍"><a href="#Jenkins项目构建类型-1-Jenkins构建的项目类型介绍" class="headerlink" title="Jenkins项目构建类型(1)-Jenkins构建的项目类型介绍"></a>Jenkins<strong>项目构建类型</strong>(1)-Jenkins<strong>构建的项目类型介绍</strong></h3><p> 154.png)</p>
<p>Jenkins中自动构建项目的类型有很多，常用的有以下三种：自由风格软件项目（FreeStyle Project）</p>
<p> 155.png)</p>
<p>Maven项目（Maven Project）</p>
<p> 156.png)</p>
<p>流水线项目（Pipeline Project）</p>
<p>每种类型的构建其实都可以完成一样的构建过程与结果，只是在操作方式、灵活度等方面有所区别，在实际开发中可以根据自己的需求和习惯来选择。（PS：个人推荐使用流水线类型，因为灵活度非常高）</p>
<p><strong>Jenkins**<strong>项目构建类型</strong></strong>(2)-**<strong>自由风格项目构建</strong> 下面演示创建一个自由风格项目来完成项目的集成过程：  157.png) 拉取代码-&gt;编译-&gt;打包-&gt;部署</p>
<p>拉取代码</p>
<ol>
<li><p>创建项目</p>
<p> 158.jpg)</p>
</li>
<li><p>配置源码管理，从gitlab拉取代码</p>
<p> 159.jpg)</p>
<p>编译打包</p>
</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">160.png)<br></code></pre></td></tr></table></figure>

<p>   echo “开始编译和打包” mvn clean package echo “编译和打包结束”</p>
<p>   构建-&gt;添加构建步骤-&gt;Executor Shell</p>
<p>   部署</p>
<p>   把项目部署到远程的Tomcat里面</p>
<ol>
<li><p>安装 Deploy to container插件</p>
<p>Jenkins本身无法实现远程部署到Tomcat的功能，需要安装Deploy to container插件实现</p>
<p> 161.jpg)</p>
</li>
<li><p>添加Tomcat用户凭证</p>
<p> 162.jpg)</p>
</li>
</ol>
<p>​      </p>
<ol start="3">
<li><p>添加构建后操作</p>
<p> 163.jpg)</p>
</li>
</ol>
<p>​      </p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"> <span class="hljs-number">164</span>.<span class="hljs-keyword">jpg)</span><br><span class="hljs-keyword"></span><br> <span class="hljs-number">165</span>.<span class="hljs-keyword">jpg)</span><br><span class="hljs-keyword"></span><br>点击<span class="hljs-string">&quot;Build Now&quot;</span>，开始构建过程<br></code></pre></td></tr></table></figure>


<p>   ​      </p>
<pre><code class="hljs">      166.jpg)
</code></pre>
<p>   ​      </p>
<pre><code class="hljs">  4. 部署成功后，访问项目 http://192.168.66.102:8080/web_demo-1.0-SNAPSHOT/
</code></pre>
<p>​      </p>
<pre><code class="hljs">   167.jpg)
</code></pre>
<p>​      </p>
<pre><code class="hljs">  **演示改动代码后的持续集成** 1）IDEA中源码修改并提交到gitlab 2）在Jenkins中项目重新构建
</code></pre>
<ol start="3">
<li>访问Tomcat</li>
</ol>
<h3 id="Jenkins项目构建类型-3-Maven项目构建"><a href="#Jenkins项目构建类型-3-Maven项目构建" class="headerlink" title="Jenkins项目构建类型(3)-Maven项目构建"></a>Jenkins<strong>项目构建类型</strong>(3)-Maven<strong>项目构建</strong></h3><ol>
<li><p>安装Maven Integration插件</p>
<p> 168.jpg)</p>
</li>
</ol>
<p>​      </p>
<ol start="2">
<li><p>创建Maven项目</p>
<p> 169.jpg)</p>
</li>
</ol>
<p>​      </p>
<ol start="3">
<li>配置项目</li>
</ol>
<p>   拉取代码和远程部署的过程和自由风格项目一样，只是”构建”部分不同</p>
<pre><code class="hljs">170.jpg)
</code></pre>
<h3 id="Jenkins项目构建类型-4-Pipeline流水线项目构建"><a href="#Jenkins项目构建类型-4-Pipeline流水线项目构建" class="headerlink" title="Jenkins项目构建类型(4)-Pipeline流水线项目构建(*)"></a>Jenkins<strong>项目构建类型</strong>(4)-Pipeline<strong>流水线项目构建</strong>(*)</h3><h4 id="Pipeline简介"><a href="#Pipeline简介" class="headerlink" title="Pipeline简介"></a>Pipeline<strong>简介</strong></h4><ol>
<li><p>概念</p>
<p>Pipeline，简单来说，就是一套运行在 Jenkins 上的工作流框架，将原来独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂流程编排和可视化的工作。</p>
</li>
<li><p>使用Pipeline有以下好处（来自翻译自官方文档）：</p>
<p>代码：Pipeline以代码的形式实现，通常被检入源代码控制，使团队能够编辑，审查和迭代其传送流 程。 持久：无论是计划内的还是计划外的服务器重启，Pipeline都是可恢复的。 可停止：Pipeline可接收交互式输入，以确定是否继续执行Pipeline。 多功能：Pipeline支持现实世界中复杂的持续交付要 求。它支持fork&#x2F;join、循环执行，并行执行任务的功能。 可扩展：Pipeline插件支持其DSL的自定义扩展 ，以及与其他插件集成的多个选项。</p>
</li>
<li><p>如何创建 Jenkins Pipeline呢？</p>
</li>
</ol>
<pre><code class="hljs">171.png)

172.png)
</code></pre>
<p>   Pipeline 脚本是由 <strong>Groovy</strong> 语言实现的，但是我们没必要单独去学习 Groovy Pipeline 支持两种语法：<strong>Declarative</strong>(声明式)和 <strong>Scripted Pipeline</strong>(脚本式)语法</p>
<pre><code class="hljs">173.png)
</code></pre>
<p>   Pipeline 也有两种创建方法：可以直接在 Jenkins 的 Web UI 界面中输入脚本；也可以通过创建一个 Jenkinsﬁle 脚本文件放入项目源码库中（一般我们都推荐在 Jenkins 中直接从源代码控制(SCM)中直接载入 Jenkinsﬁle Pipeline 这种方法）。</p>
<p>   安装<strong>Pipeline</strong>插件</p>
<p>   Manage Jenkins-&gt;Manage Plugins-&gt;可选插件</p>
<pre><code class="hljs">174.jpg)
</code></pre>
<p>   安装插件后，创建项目的时候多了“流水线”类型</p>
<pre><code class="hljs">175.jpg)
</code></pre>
<h4 id="Pipeline语法快速入门-1）Declarative声明式-Pipeline创建项目"><a href="#Pipeline语法快速入门-1）Declarative声明式-Pipeline创建项目" class="headerlink" title="Pipeline语法快速入门 1）Declarative声明式-Pipeline创建项目"></a>Pipeline<strong>语法快速入门</strong> 1<strong>）</strong>Declarative<strong>声明式</strong>-Pipeline创建项目</h4><pre><code class="hljs">176.jpg)
</code></pre>
<p>   流水线-&gt;选择HelloWorld模板</p>
<pre><code class="hljs">177.jpg)







178.png)
</code></pre>
<p>   pipeline { agent any</p>
<p>   stages {</p>
<p>   stage(‘Hello’) { steps {</p>
<p>   echo ‘Hello World’</p>
<p>   }</p>
<p>   }</p>
<p>   }</p>
<p>   }</p>
<p>   生成内容如下：</p>
<p>   stages：代表整个流水线的所有执行阶段。通常stages只有1个，里面包含多个stage</p>
<p>   stage：代表流水线中的某个阶段，可能出现n个。一般分为拉取代码，编译构建，部署等阶段。</p>
<p>   steps：代表一个阶段内需要执行的逻辑。steps里面是shell脚本，git拉取代码，ssh远程发布等任意内容。</p>
<pre><code class="hljs">179.png)
</code></pre>
<p>   pipeline { agent any</p>
<p>   stages {</p>
<p>   stage(‘拉取代码’) { steps {</p>
<p>   echo ‘拉取代码’</p>
<p>   }</p>
<p>   }</p>
<p>   stage(‘编译构建’) { steps {</p>
<p>   echo ‘编译构建’</p>
<p>   }</p>
<p>   }</p>
<p>   stage(‘项目部署’) { steps {</p>
<p>   echo ‘项目部署’</p>
<p>   }</p>
<p>   }</p>
<p>   }</p>
<p>   }</p>
<p>   编写一个简单声明式Pipeline：</p>
<p>   点击构建，可以看到整个构建过程</p>
<pre><code class="hljs">180.jpg)
</code></pre>
<ol start="2">
<li><h4 id="Scripted-Pipeline脚本式-Pipeline"><a href="#Scripted-Pipeline脚本式-Pipeline" class="headerlink" title="Scripted Pipeline脚本式-Pipeline"></a>Scripted Pipeline<strong>脚本式</strong>-Pipeline</h4></li>
</ol>
<p>创建项目</p>
<p> 181.jpg)</p>
<p>这次选择”Scripted Pipeline”</p>
<p> 182.jpg)</p>
<p> 183.png)</p>
<p>node {</p>
<p>def mvnHome</p>
<p>stage(‘Preparation’) { &#x2F;&#x2F; for display purposes</p>
<p>}</p>
<p>stage(‘Build’) {</p>
<p>}</p>
<p>stage(‘Results’) {</p>
<p>}</p>
<p>}</p>
<p> 184.png)</p>
<p>Node：节点，一个 Node 就是一个 Jenkins 节点，Master 或者 Agent，是执行 Step 的具体运行环境，后续讲到Jenkins的Master-Slave架构的时候用到。</p>
<p> 185.png)</p>
<p>Stage：阶段，一个 Pipeline 可以划分为若干个 Stage，每个 Stage 代表一组操作，比如：</p>
<p>Build、Test、Deploy，Stage 是一个逻辑分组的概念。</p>
<p> 186.png)</p>
<p>Step：步骤，Step 是最基本的操作单元，可以是打印一句话，也可以是构建一个 Docker 镜像，由各类 Jenkins 插件提供，比如命令：sh ‘make’，就相当于我们平时 shell 终端中执行 make 命令一样。</p>
<p>编写一个简单的脚本式Pipeline</p>
<p> 187.png)</p>
<p>node {</p>
<p>def mvnHome</p>
<p>stage(‘拉取代码’) { &#x2F;&#x2F; for display purposes echo ‘拉取代码’</p>
<p>}</p>
<p>stage(‘编译构建’) { echo ‘编译构建’</p>
<p>}</p>
<p>stage(‘项目部署’) { echo ‘项目部署’</p>
<p>}</p>
<p>}</p>
<p> 188.png)</p>
<p>pipeline { agent any</p>
<p>stages {</p>
<p>stage(‘拉取代码’) { steps {</p>
<p>checkout([$class: ‘GitSCM’, branches: [[name: ‘*&#x2F;master’]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: ‘68f2087f-a034-4d39-a9ff-1f776dd3dfa8’, url: ‘<a href="mailto:&#x67;&#x69;&#116;&#x40;&#49;&#x39;&#x32;&#x2e;&#x31;&#54;&#x38;&#46;&#x36;&#54;&#46;&#49;&#x30;&#48;">&#x67;&#x69;&#116;&#x40;&#49;&#x39;&#x32;&#x2e;&#x31;&#54;&#x38;&#46;&#x36;&#54;&#46;&#49;&#x30;&#48;</a>:itheima_group&#x2F;web_demo.git’]]])</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>构建结果和声明式一样！<strong>拉取代码</strong></p>
<p> 189.png)</p>
<p>pipeline { agent any</p>
<p>stages {</p>
<p>stage(‘拉取代码’) { steps {</p>
<p>checkout([$class: ‘GitSCM’, branches: [[name: ‘*&#x2F;master’]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: ‘68f2087f-a034-4d39-a9ff-1f776dd3dfa8’, url: ‘<a href="mailto:&#103;&#105;&#116;&#x40;&#49;&#x39;&#x32;&#46;&#49;&#x36;&#56;&#46;&#x36;&#54;&#46;&#49;&#x30;&#x30;">&#103;&#105;&#116;&#x40;&#49;&#x39;&#x32;&#46;&#49;&#x36;&#56;&#46;&#x36;&#54;&#46;&#49;&#x30;&#x30;</a>:itheima_group&#x2F;web_demo.git’]]])</p>
<p>}</p>
<p>}</p>
<p>stage(‘编译构建’) { steps {</p>
<p>sh label: ‘’, script: ‘mvn clean package’</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>编译打包</p>
<p> 190.png)</p>
<p> 191.png)</p>
<p>pipeline { agent any</p>
<p>stages {</p>
<p>stage(‘拉取代码’) { steps {</p>
<p>checkout([$class: ‘GitSCM’, branches: [[name: ‘*&#x2F;master’]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: ‘68f2087f-a034-4d39-a9ff-1f776dd3dfa8’, url: ‘<a href="mailto:&#x67;&#x69;&#x74;&#x40;&#x31;&#57;&#x32;&#46;&#x31;&#54;&#56;&#x2e;&#54;&#54;&#x2e;&#49;&#48;&#48;">&#x67;&#x69;&#x74;&#x40;&#x31;&#57;&#x32;&#46;&#x31;&#54;&#56;&#x2e;&#54;&#54;&#x2e;&#49;&#48;&#48;</a>:itheima_group&#x2F;web_demo.git’]]])</p>
<p>}</p>
<p>}</p>
<p>stage(‘编译构建’) { steps {</p>
<p>sh label: ‘’, script: ‘mvn clean package’</p>
<p>}</p>
<p>}</p>
<p>stage(‘项目部署’) { steps {</p>
<p>deploy adapters: [tomcat8(credentialsId: ‘afc43e5e-4a4e-4de6-984f- b1d5a254e434’, path: ‘’, url: ‘<a target="_blank" rel="noopener" href="http://192.168.66.102:8080')]">http://192.168.66.102:8080&#39;)]</a>, contextPath: null, war: ‘target&#x2F;*.war’</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>部署</p>
<h4 id="Pipeline-Script-from-SCM"><a href="#Pipeline-Script-from-SCM" class="headerlink" title="Pipeline Script from SCM"></a>Pipeline Script from SCM</h4><p>刚才我们都是直接在Jenkins的UI界面编写Pipeline代码，这样不方便脚本维护，建议把Pipeline脚本放在项目中（一起进行版本控制）</p>
<ol>
<li>在项目根目录建立Jenkinsﬁle文件，把内容复制到该文件中</li>
</ol>
<p> 192.jpg)</p>
<p> 193.jpg)</p>
<p>把Jenkinsﬁle上传到Gitlab 2）在项目中引用该文件</p>
<h3 id="Jenkins项目构建细节-1-常用的构建触发器"><a href="#Jenkins项目构建细节-1-常用的构建触发器" class="headerlink" title="Jenkins项目构建细节(1)-常用的构建触发器"></a>Jenkins<strong>项目构建细节</strong>(1)-<strong>常用的构建触发器</strong></h3><p> 194.png)</p>
<p>Jenkins内置4种构建触发器：触发远程构建</p>
<p> 195.png)</p>
<p>其他工程构建后触发（Build after other projects are build）</p>
<p> 196.png)</p>
<p> 197.png)</p>
<p>定时构建（Build periodically）轮询SCM（Poll SCM）</p>
<p>触发远程构建</p>
<p> 198.jpg)</p>
<p>触发构建url：<a target="_blank" rel="noopener" href="http://192.168.66.101:8888/job/web_demo_pipeline/build?token=6666">http://192.168.66.101:8888/job/web_demo_pipeline/build?token=6666</a></p>
<p>其他工程构建后触发</p>
<ol>
<li><p>创建pre_job流水线工程</p>
<p> 199.jpg)</p>
</li>
<li><p>配置需要触发的工程</p>
</li>
</ol>
<p> 200.jpg)</p>
<p>定时构建</p>
<p> 201.jpg)</p>
<p>定时字符串从左往右分别为： 分 时 日 月 周</p>
<p>一些定时表达式的例子：</p>
<p> 202.png)</p>
<p>每30分钟构建一次：H代表形参 H&#x2F;30 * * * * 10:02 10:32</p>
<p>每2个小时构建一次: H H&#x2F;2 * * *</p>
<p>每天的8点，12点，22点，一天构建3次： (多个时间点中间用逗号隔开) 0 8,12,22 * * *</p>
<p>每天中午12点定时构建一次 H 12 * * *</p>
<p>每天下午18点定时构建一次 H 18 * * *</p>
<p>在每个小时的前半个小时内的每10分钟 H(0-29)&#x2F;10 * * * *</p>
<p>每两小时一次，每个工作日上午9点到下午5点(也许是上午10:38，下午12:38，下午2:38，下午</p>
<p>4:38) H H(9-16)&#x2F;2 * * 1-5</p>
<p>轮询<strong>SCM</strong></p>
<p>轮询SCM，是指定时扫描本地代码仓库的代码是否有变更，如果代码有变更就触发项目构建。</p>
<p> 203.jpg)</p>
<p>注意：这次构建触发器，Jenkins会定时扫描本地整个项目的代码，增大系统的开销，不建议使用。</p>
<h3 id="Jenkins项目构建细节-2-Git-hook自动触发构建"><a href="#Jenkins项目构建细节-2-Git-hook自动触发构建" class="headerlink" title="Jenkins项目构建细节(2)-Git hook自动触发构建(*)"></a>Jenkins<strong>项目构建细节</strong>(2)-Git hook<strong>自动触发构建</strong>(*)</h3><p>刚才我们看到在Jenkins的内置构建触发器中，轮询SCM可以实现Gitlab代码更新，项目自动构建，但是该方案的性能不佳。那有没有更好的方案呢？ 有的。就是利用Gitlab的webhook实现代码push到仓</p>
<p>库，立即触发项目自动构建。</p>
<p> 204.jpg)</p>
<p>安装<strong>Gitlab Hook</strong>插件需要安装两个插件： Gitlab Hook和GitLab</p>
<p> 205.jpg)</p>
<p> 206.jpg)</p>
<h4 id="Jenkins设置自动构建"><a href="#Jenkins设置自动构建" class="headerlink" title="Jenkins设置自动构建"></a>Jenkins<strong>设置自动构建</strong></h4><p> 207.jpg)</p>
<p>等会需要把生成的webhook URL配置到Gitlab中。</p>
<h4 id="Gitlab配置webhook-1）开启webhook功能"><a href="#Gitlab配置webhook-1）开启webhook功能" class="headerlink" title="Gitlab配置webhook 1）开启webhook功能"></a>Gitlab<strong>配置</strong>webhook 1）开启webhook功能</h4><p>使用root账户登录到后台，点击Admin Area -&gt; Settings -&gt; Network</p>
<p>勾选”Allow requests to the local network from web hooks and services”</p>
<p> 208.jpg)</p>
<p>2）在项目添加webhook</p>
<p>点击项目-&gt;Settings-&gt;Integrations</p>
<p> 209.jpg)</p>
<p>注意：以下设置必须完成，否则会报错！</p>
<p>Manage Jenkins-&gt;Conﬁgure System</p>
<p> 210.jpg)</p>
<h3 id="Jenkins项目构建细节-3-Jenkins的参数化构建"><a href="#Jenkins项目构建细节-3-Jenkins的参数化构建" class="headerlink" title="Jenkins项目构建细节(3)-Jenkins的参数化构建"></a>Jenkins<strong>项目构建细节</strong>(3)-Jenkins<strong>的参数化构建</strong></h3><p>有时在项目构建的过程中，我们需要根据用户的输入动态传入一些参数，从而影响整个构建结果，这时我们可以使用参数化构建。</p>
<p>Jenkins支持非常丰富的参数类型</p>
<p> 211.jpg)</p>
<p>接下来演示通过输入gitlab项目的分支名称来部署不同分支项目。<strong>项目创建分支，并推送到<strong><strong>Gitlab</strong></strong>上</strong></p>
<p> 212.jpg)</p>
<p>新</p>
<p>新建分支：v1，代码稍微改动下，然后提交到gitlab上。这时看到gitlab上有一个两个分支：master和v1</p>
<p> 213.jpg)</p>
<p>在<strong>Jenkins</strong>添加字符串类型参数</p>
<p> 214.jpg)</p>
<p> 215.jpg)</p>
<p>改动<strong>pipeline</strong>流水线代码</p>
<p> 216.jpg)</p>
<p>点击<strong>Build with Parameters</strong></p>
<p> 217.jpg)</p>
<p>输入分支名称，构建即可！构建完成后访问Tomcat查看结果</p>
<h3 id="Jenkins项目构建细节-4-配置邮箱服务器发送构建结果"><a href="#Jenkins项目构建细节-4-配置邮箱服务器发送构建结果" class="headerlink" title="Jenkins项目构建细节(4)-配置邮箱服务器发送构建结果"></a>Jenkins<strong>项目构建细节</strong>(4)-<strong>配置邮箱服务器发送构建结果</strong></h3><p>安装<strong>Email Extension</strong>插件</p>
<p> 218.jpg)</p>
<h4 id="Jenkins设置邮箱相关参数"><a href="#Jenkins设置邮箱相关参数" class="headerlink" title="Jenkins设置邮箱相关参数"></a>Jenkins<strong>设置邮箱相关参数</strong></h4><p>Manage Jenkins-&gt;Conﬁgure System</p>
<p> 219.jpg)</p>
<p>设置邮件参数</p>
<p> 220.jpg)</p>
<p>设置Jenkins默认邮箱信息</p>
<p> 221.jpg)</p>
<p>准备邮件内容</p>
<p>在项目根目录编写email.html，并把文件推送到Gitlab，内容如下：</p>
<p> 222.jpg)</p>
<p> 223.png)</p>
<!DOCTYPE html>

<html>

<head>

<meta charset="UTF-8">

<title>${ENV, var="JOB_NAME"}-第${BUILD_NUMBER}次构建日志</title>

</head>



<body leftmargin="8" marginwidth="0" topmargin="8" marginheight="4" offset="0">

<table width="95%" cellpadding="0" cellspacing="0"

<p>style&#x3D;”font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans- serif”&gt;</p>
<tr>

<td>(本邮件是程序自动下发的，请勿回复！)</td>

</tr>

<tr>

<td><h2>

<p><font color="#0000FF">构建结果 - ${BUILD_STATUS}</font></p>
</h2></td>

</tr>

<tr>

<td><br />

<p><b><font color="#0B610B">构建信息</font></b></p>
<hr size="2" width="100%" align="center" /></td>

</tr>

<tr>

<td>



<ul>

<li>项目名称&nbsp;：&nbsp;${PROJECT_NAME}</li>

<li>构建编号&nbsp;：&nbsp;第${BUILD_NUMBER}次构建</li>

<li>触发原因：&nbsp;${CAUSE}</li>

<li>构建日志：&nbsp;<a

<p>href&#x3D;”${BUILD_URL}console”&gt;${BUILD_URL}console</a></li></p>
<li>构建&nbsp;&nbsp;Url&nbsp;：&nbsp;<a href="${BUILD_URL}">${BUILD_URL}</a></li>

<li>工作目录&nbsp;：&nbsp;<a href="${PROJECT_URL}ws">${PROJECT_URL}ws</a></li>

<li>项目&nbsp;&nbsp;Url&nbsp;：&nbsp;<a href="${PROJECT_URL}">${PROJECT_URL}</a></li>

</ul>

</td>

</tr>

<tr>

<td><b><font color="#0B610B">Changes Since Last Successful Build:</font></b>

<hr size="2" width="100%" align="center" /></td>

</tr>



<p> 224.png)</p>
<tr>

<td>

<ul>

<li>历史变更记录 : <a href="${PROJECT_URL}changes">${PROJECT_URL}changes</a></li>

</ul> ${CHANGES_SINCE_LAST_SUCCESS,reverse=true, format="Changes for Build #%n:<br />%c<br />",showPaths=true,changesFormat="<pre>[%a]<br

<p>&#x2F;&gt;%m</pre>“,pathFormat&#x3D;”&nbsp;&nbsp;&nbsp;&nbsp;%p”}</p>
</td>

</tr>

<tr>

<td><b>Failed Test Results</b>

<hr size="2" width="100%" align="center" /></td>

</tr>

<tr>

<td><pre

<p>style&#x3D;”font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif”&gt;$FAILED_TESTS</pre></p>
<p><br /></td></p>
</tr>

<tr>

<td><b><font color="#0B610B">构建日志 (最后 100行):</font></b>

<hr size="2" width="100%" align="center" /></td>

</tr>

<tr>

<td><textarea cols="80" rows="30" readonly="readonly" style="font-family: Courier New">${BUILD_LOG,

<p>maxLines&#x3D;100}</textarea></p>
</td>

</tr>

</table>

</body>

</html>



<p> 225.png)</p>
<p>pipeline { agent any</p>
<p>stages {</p>
<p>stage(‘拉取代码’) { steps {</p>
<p>checkout([$class: ‘GitSCM’, branches: [[name: ‘*&#x2F;master’]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: ‘68f2087f-a034-4d39-a9ff-1f776dd3dfa8’, url: ‘<a href="mailto:&#103;&#x69;&#x74;&#x40;&#49;&#x39;&#50;&#x2e;&#x31;&#54;&#x38;&#46;&#x36;&#x36;&#46;&#x31;&#x30;&#x30;">&#103;&#x69;&#x74;&#x40;&#49;&#x39;&#50;&#x2e;&#x31;&#54;&#x38;&#46;&#x36;&#x36;&#46;&#x31;&#x30;&#x30;</a>:itheima_group&#x2F;web_demo.git’]]])</p>
<p>}</p>
<p>}</p>
<p>stage(‘编译构建’) { steps {</p>
<p>sh label: ‘’, script: ‘mvn clean package’</p>
<p>}</p>
<p>}</p>
<p>stage(‘项目部署’) { steps {</p>
<p>编写<strong>Jenkinsﬁle</strong>添加构建后发送邮件</p>
<p> 226.png)</p>
<p>deploy adapters: [tomcat8(credentialsId: ‘afc43e5e-4a4e-4de6-984f- b1d5a254e434’, path: ‘’, url: ‘<a target="_blank" rel="noopener" href="http://192.168.66.102:8080')]">http://192.168.66.102:8080&#39;)]</a>, contextPath: null, war: ‘target&#x2F;*.war’</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>post {</p>
<p>always {</p>
<p>emailext(</p>
<p>subject: ‘构建通知：${PROJECT_NAME} - Build # ${BUILD_NUMBER} -</p>
<p>${BUILD_STATUS}!’,</p>
<p>body: ‘${FILE,path&#x3D;”email.html”}’, to: ‘<a href="mailto:&#120;&#120;&#x78;&#x40;&#x71;&#113;&#46;&#99;&#x6f;&#109;">&#120;&#120;&#x78;&#x40;&#x71;&#113;&#46;&#99;&#x6f;&#109;</a>‘</p>
<p>)</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>测试</p>
<p> 227.jpg)</p>
<p>PS：邮件相关全局参数参考列表：</p>
<p>系统设置-&gt;Extended E-mail Notiﬁcation-&gt;Content Token Reference，点击旁边的?号</p>
<p> 228.jpg)</p>
<h3 id="Jenkins-SonarQube代码审查-1-安装SonarQube"><a href="#Jenkins-SonarQube代码审查-1-安装SonarQube" class="headerlink" title="Jenkins+SonarQube代码审查(1) - 安装SonarQube"></a>Jenkins+SonarQube<strong>代码审查</strong>(1) - <strong>安装</strong>SonarQube</h3><h4 id="SonaQube简介"><a href="#SonaQube简介" class="headerlink" title="SonaQube简介"></a>SonaQube<strong>简介</strong></h4><p> 229.jpg)</p>
<p>SonarQube是一个用于管理代码质量的开放平台，可以快速的定位代码中潜在的或者明显的错误。目前支持java,C#,C&#x2F;C++,Python,PL&#x2F;SQL,Cobol,JavaScrip,Groovy等二十几种编程语言的代码质量管理与检 测。</p>
<p> 230.png)</p>
<table>
<thead>
<tr>
<th>软件</th>
<th>服务器</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>JDK</td>
<td>192.168.66.101</td>
<td>1.8</td>
</tr>
<tr>
<td>MySQL</td>
<td>192.168.66.101</td>
<td>5.7</td>
</tr>
<tr>
<td>SonarQube</td>
<td>192.168.66.101</td>
<td>6.7.4</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://www.sonarqube.org/">官网：</a><a target="_blank" rel="noopener" href="https://www.sonarqube.org/">https://www.sonarqube.or</a><a target="_blank" rel="noopener" href="https://www.sonarqube.org/">g&#x2F;</a>环境要求</p>
<p><strong>安装****SonarQube</strong> 1）安装MySQL（已完成） 2）安装SonarQube</p>
<p>在MySQL创建sonar数据库</p>
<p> 231.jpg)</p>
<p> 232.png)</p>
<p>下载sonar<a target="_blank" rel="noopener" href="https://www.sonarqube.org/downloads/">压缩包： </a><a target="_blank" rel="noopener" href="https://www.sonarqube.org/downloads/">https://www.sonarqube.or</a><a target="_blank" rel="noopener" href="https://www.sonarqube.org/downloads/">g</a>&#x2F;downloads&#x2F;解压sonar，并设置权限</p>
<p>yum install unzip</p>
<p>unzip sonarqube-6.7.4.zip 解压</p>
<p>mkdir &#x2F;opt&#x2F;sonar 创建目录</p>
<p>mv sonarqube-6.7.4&#x2F;* &#x2F;opt&#x2F;sonar 移动文件</p>
<p>useradd sonar 创建sonar用户，必须sonar用于启动，否则报错</p>
<p>chown -R sonar. &#x2F;opt&#x2F;sonar 更改sonar目录及文件权限修改sonar配置文件</p>
<p> 233.png)</p>
<p>vi &#x2F;opt&#x2F;sonarqube-6.7.4&#x2F;conf&#x2F;sonar.properties</p>
<p>内容如下：</p>
<p>sonar.jdbc.username&#x3D;root sonar.jdbc.password&#x3D;Root@123</p>
<p>sonar.jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;sonar? useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;rewriteBatchedStatements&#x3D;true&amp;useConﬁgs&#x3D; maxPerformance&amp;useSSL&#x3D;false</p>
<p>注意：sonar默认监听9000端口，如果9000端口被占用，需要更改。启动sonar</p>
<p> 234.png)</p>
<p>cd &#x2F;opt&#x2F;sonarqube-6.7.4</p>
<p>su sonar .&#x2F;bin&#x2F;linux-x86-64&#x2F;sonar.sh start 启动</p>
<p>su sonar .&#x2F;bin&#x2F;linux-x86-64&#x2F;sonar.sh status 查看状态</p>
<p>su sonar .&#x2F;bin&#x2F;linux-x86-64&#x2F;sonar.sh stop 停止</p>
<p>tail -f logs&#x2F;sonar.logs 查看日志访问sonar <a target="_blank" rel="noopener" href="http://192.168.66.101:9000/">http://192.168.66.101:9000</a></p>
<p> 235.jpg)</p>
<p>默认账户：admin&#x2F;admin创建token</p>
<p> 236.jpg)</p>
<p> 237.png) <strong>bb8b6c53d9d921e101343cef0395243e6c1dc8a3</strong> token要记下来后面要使用 <strong>0151ae8c548a143eda9253e4334ad030b56047ee</strong></p>
<h3 id="Jenkins-SonarQube代码审查-2-实现代码审查"><a href="#Jenkins-SonarQube代码审查-2-实现代码审查" class="headerlink" title="Jenkins+SonarQube代码审查(2) - 实现代码审查"></a>Jenkins+SonarQube<strong>代码审查</strong>(2) - <strong>实现代码审查</strong></h3><p> 238.jpg)</p>
<p>安装<strong>SonarQube Scanner</strong>插件</p>
<p> 239.jpg)</p>
<p>添加<strong>SonarQube</strong>凭证</p>
<p> 240.jpg)</p>
<p> 241.jpg)</p>
<h4 id="Jenkins进行SonarQube配置"><a href="#Jenkins进行SonarQube配置" class="headerlink" title="Jenkins进行SonarQube配置"></a>Jenkins<strong>进行</strong>SonarQube<strong>配置</strong></h4><p>Manage Jenkins-&gt;Conﬁgure System-&gt;SonarQube servers</p>
<p> 242.jpg)</p>
<p>Manage Jenkins-&gt;Global Tool Conﬁguration</p>
<p> 243.jpg)</p>
<h4 id="SonaQube关闭审查结果上传到SCM功能"><a href="#SonaQube关闭审查结果上传到SCM功能" class="headerlink" title="SonaQube关闭审查结果上传到SCM功能"></a>SonaQube<strong>关闭审查结果上传到</strong>SCM<strong>功能</strong></h4><p> 244.jpg)</p>
<p>在项目添加<strong>SonaQube</strong>代码审查（非流水线项目）添加构建步骤：</p>
<p> 245.png)</p>
<p># must be unique in a given SonarQube instance sonar.projectKey&#x3D;web_demo</p>
<p># this is the name and version displayed in the SonarQube UI. Was mandatory prior to SonarQube 6.1.</p>
<p>sonar.projectName&#x3D;web_demo sonar.projectVersion&#x3D;1.0</p>
<p># Path is relative to the sonar-project.properties file. Replace “&quot; by “&#x2F;“ on Windows.</p>
<p># This property is optional if sonar.modules is set. sonar.sources&#x3D;. sonar.exclusions&#x3D;<strong>&#x2F;test&#x2F;</strong>,<strong>&#x2F;target&#x2F;</strong></p>
<p>sonar.java.source&#x3D;1.8 sonar.java.target&#x3D;1.8</p>
<p># Encoding of the source code. Default is default system encoding sonar.sourceEncoding&#x3D;UTF-8</p>
<p>在项目添加<strong>SonaQube</strong>代码审查（流水线项目）</p>
<ol>
<li><p>项目根目录下，创建sonar-project.properties文件</p>
<p> 246.jpg)</p>
<p> 247.png)</p>
<p># must be unique in a given SonarQube instance sonar.projectKey&#x3D;web_demo</p>
<p># this is the name and version displayed in the SonarQube UI. Was mandatory prior to SonarQube 6.1.</p>
<p>sonar.projectName&#x3D;web_demo sonar.projectVersion&#x3D;1.0</p>
<p># Path is relative to the sonar-project.properties file. Replace “&quot; by “&#x2F;“ on Windows.</p>
<p># This property is optional if sonar.modules is set. sonar.sources&#x3D;. sonar.exclusions&#x3D;<strong>&#x2F;test&#x2F;</strong>,<strong>&#x2F;target&#x2F;</strong></p>
<p>sonar.java.source&#x3D;1.8 sonar.java.target&#x3D;1.8</p>
<p># Encoding of the source code. Default is default system encoding sonar.sourceEncoding&#x3D;UTF-8</p>
</li>
<li><p>修改Jenkinsﬁle，加入SonarQube代码审查阶段</p>
<p> 248.png)</p>
<p> 249.png)</p>
<p>pipeline { agent any</p>
<p>stages {</p>
<p>stage(‘拉取代码’) { steps {</p>
<p>checkout([$class: ‘GitSCM’, branches: [[name: ‘*&#x2F;master’]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: ‘68f2087f-a034-4d39-a9ff-1f776dd3dfa8’, url: ‘<a href="mailto:&#x67;&#105;&#116;&#x40;&#x31;&#57;&#50;&#46;&#x31;&#x36;&#56;&#x2e;&#54;&#x36;&#46;&#49;&#x30;&#48;">&#x67;&#105;&#116;&#x40;&#x31;&#57;&#50;&#46;&#x31;&#x36;&#56;&#x2e;&#54;&#x36;&#46;&#49;&#x30;&#48;</a>:itheima_group&#x2F;web_demo.git’]]])</p>
<p>}</p>
<p>}</p>
<p>stage(‘编译构建’) { steps {</p>
<p>sh label: ‘’, script: ‘mvn clean package’</p>
<p>}</p>
<p>}</p>
<p>stage(‘SonarQube代码审查’) { steps{</p>
<p>script {</p>
<p>scannerHome &#x3D; tool ‘sonarqube-scanner’</p>
<p>}</p>
<p>withSonarQubeEnv(‘sonarqube6.7.4’) {</p>
<p>sh “${scannerHome}&#x2F;bin&#x2F;sonar-scanner”</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>stage(‘项目部署’) { steps {</p>
<p>deploy adapters: [tomcat8(credentialsId: ‘afc43e5e-4a4e-4de6-984f- b1d5a254e434’, path: ‘’, url: ‘<a target="_blank" rel="noopener" href="http://192.168.66.102:8080')]">http://192.168.66.102:8080&#39;)]</a>, contextPath: null, war: ‘target&#x2F;*.war’</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>post {</p>
<p>always {</p>
<p>emailext(</p>
<p>subject: ‘构建通知：${PROJECT_NAME} - Build # ${BUILD_NUMBER} -</p>
<p>${BUILD_STATUS}!’,</p>
<p>body: ‘${FILE,path&#x3D;”email.html”}’, to: ‘<a href="mailto:&#x31;&#x30;&#x31;&#x34;&#x36;&#x37;&#x31;&#52;&#x34;&#57;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#109;">&#x31;&#x30;&#x31;&#x34;&#x36;&#x37;&#x31;&#52;&#x34;&#57;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#109;</a>‘</p>
<p>)</p>
<p>}</p>
<p>}</p>
<p>}</p>
</li>
<li><p>到SonarQube的UI界面查看审查结果</p>
</li>
</ol>
<p> 250.jpg)</p>
<h2 id="4、Jenkins-Docker-SpringCloud微服务持续集成-上"><a href="#4、Jenkins-Docker-SpringCloud微服务持续集成-上" class="headerlink" title="4、Jenkins+Docker+SpringCloud微服务持续集成(上)"></a>4<strong>、</strong>Jenkins+Docker+SpringCloud<strong>微服务持续集成</strong>(<strong>上</strong>)</h2><h3 id="Jenkins-Docker-SpringCloud持续集成流程说明"><a href="#Jenkins-Docker-SpringCloud持续集成流程说明" class="headerlink" title="Jenkins+Docker+SpringCloud持续集成流程说明"></a>Jenkins+Docker+SpringCloud<strong>持续集成流程说明</strong></h3><p> 251.jpg)</p>
<p>大致流程说明：</p>
<ol>
<li>开发人员每天把代码提交到Gitlab代码仓库</li>
<li>Jenkins从Gitlab中拉取项目源码，编译并打成jar包，然后构建成Docker镜像，将镜像上传到 Harbor私有仓库。</li>
<li>Jenkins发送SSH远程命令，让生产部署服务器到Harbor私有仓库拉取镜像到本地，然后创建容器。</li>
<li>最后，用户可以访问到容器</li>
</ol>
<p><strong>服务列表</strong>(红色的软件为需要安装的软件，黑色代表已经安装)</p>
<table>
<thead>
<tr>
<th>服务器名称</th>
<th>IP<strong>地址</strong></th>
<th>安装的软件</th>
</tr>
</thead>
<tbody><tr>
<td>代码托管服务器</td>
<td>192.168.66.100</td>
<td>Gitlab</td>
</tr>
<tr>
<td>持续集成服务器</td>
<td>192.168.66.101</td>
<td>Jenkins，Maven，Docker18.06.1-ce</td>
</tr>
<tr>
<td>Docker仓库服务器</td>
<td>192.168.66.102</td>
<td>Docker18.06.1-ce，Harbor1.9.2</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>服生务产器部名署称服务器</td>
<td><strong>I</strong>1<strong>P</strong>9<strong>地</strong>2.<strong>址</strong>168.66.103</td>
<td>D<strong>安</strong>o<strong>装</strong>ck<strong>的</strong>er<strong>软</strong>18<strong>件</strong>.06.1-ce</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="SpringCloud微服务源码概述"><a href="#SpringCloud微服务源码概述" class="headerlink" title="SpringCloud微服务源码概述"></a>SpringCloud<strong>微服务源码概述</strong></h3><p>项目架构：前后端分离</p>
<p>后端技术栈：SpringBoot+SpringCloud+SpringDataJpa（Spring全家桶）微服务项目结构：</p>
<p> 252.jpg)</p>
<p> 253.png)</p>
<p> 254.png)</p>
<p> 255.png)</p>
<p> 256.png)</p>
<p> 257.png)</p>
<p> 258.png)</p>
<p>tensquare_parent：父工程，存放基础配置 tensquare_common：通用工程，存放工具类 tensquare_eureka_server：SpringCloud的Eureka注册中心 tensquare_zuul：SpringCloud的网关服务 tensquare_admin_service：基础权限认证中心，负责用户认证（使用JWT认证） tensquare_gathering：一个简单的业务模块，活动微服务相关逻辑</p>
<p>数据库结构：</p>
<p> 259.jpg)</p>
<p> 260.png)</p>
<p> 261.png)</p>
<p>tensquare_user：用户认证数据库，存放用户账户数据。对应tensquare_admin_service微服务 tensquare_gathering：活动微服务数据库。对应tensquare_gathering微服务</p>
<p>微服务配置分析：</p>
<p> 262.png)</p>
<p> 263.png)</p>
<p> 264.png)</p>
<p> 265.png)</p>
<p>tensquare_eureka tensquare_zuul tensquare_admin_service tensquare_gathering</p>
<p>本地部署**(1)-SpringCloud**微服务部署</p>
<p><strong>本地运行微服务</strong> 1）逐一启动微服务 2）使用postman测试功能是否可用</p>
<p> 266.png)</p>
<plugin>

<p><groupId>org.springframework.boot</groupId></p>
<p><artifactId>spring-boot-maven-plugin</artifactId></p>
</plugin>



<p><strong>本地部署微服务</strong> 1）SpringBoot微服务项目打包必须导入该插件</p>
<p>打包后在target下产生jar包 2）本地运行微服务的jar包  267.png) java -jar xxx.jar 3）查看效果</p>
<p><strong>本地部署</strong>**(2)-<strong><strong>前端静态</strong></strong>web**<strong>网站</strong>前端技术栈：NodeJS+VueJS+ElementUI使用Visual Studio Code打开源码 1）本地运行</p>
<p> 268.png) npm run dev 2）打包静态web网站  269.png) npm run build</p>
<p>打包后，产生dist目录的静态文件</p>
<ol>
<li><p>部署到nginx服务器</p>
<p>把dist目录的静态文件拷贝到nginx的html目录，启动nginx 4）启动nginx，并访问</p>
<p><a target="_blank" rel="noopener" href="http://localhost:82/">http://localhost:82</a></p>
<p>环境准备**(1)-Docker**快速入门</p>
<h4 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker<strong>简介</strong></h4><p> 270.jpg)</p>
<p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</p>
<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<p>Docker容器技术 vs 传统虚拟机技术</p>
<p> 271.jpg)</p>
<table>
<thead>
<tr>
<th></th>
<th>虚拟机</th>
<th>容器</th>
</tr>
</thead>
<tbody><tr>
<td>占用磁盘空间</td>
<td>非常大，GB级</td>
<td>小，MB甚至KB级</td>
</tr>
<tr>
<td>启动速度</td>
<td>慢，分钟级</td>
<td>快，秒级</td>
</tr>
<tr>
<td>运行形态</td>
<td>运行于Hypervisor上</td>
<td>直接运行在宿主机内核上</td>
</tr>
<tr>
<td>并发性</td>
<td>一台宿主机上十几个，最多几十个</td>
<td>上百个，甚至数百上千个</td>
</tr>
<tr>
<td>性能</td>
<td>逊于宿主机</td>
<td>接近宿主机本地进程</td>
</tr>
<tr>
<td>资源利用率</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<h4 id="简单一句话总结：Docker技术就是让我们更加高效轻松地将任何应用在Linux服务器部署和使用。"><a href="#简单一句话总结：Docker技术就是让我们更加高效轻松地将任何应用在Linux服务器部署和使用。" class="headerlink" title="简单一句话总结：Docker技术就是让我们更加高效轻松地将任何应用在Linux服务器部署和使用。"></a>简单一句话总结：Docker<strong>技术就是让我们更加高效轻松地将任何应用在</strong>Linux<strong>服务器部署和使用</strong>。</h4><h4 id="Docker安装-1）卸载旧版本"><a href="#Docker安装-1）卸载旧版本" class="headerlink" title="Docker安装 1）卸载旧版本"></a>Docker<strong>安装</strong> 1）卸载旧版本</h4><p> 272.png)</p>
<p>yum list installed | grep docker 列出当前所有docker的包</p>
<p>yum -y remove docker的包名称 卸载docker包</p>
<p> 273.png) rm -rf &#x2F;var&#x2F;lib&#x2F;docker 删除docker的所有镜像和容器</p>
<p>2）安装必要的软件包</p>
<p> 274.png)</p>
<p> 275.png) sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 3）设置下载的镜像仓库</p>
<p><a target="_blank" rel="noopener" href="https://download.docker.com/linux/centos/docker-ce.repo">sudo yum-conﬁg-manager \ –add-repo \ </a><a target="_blank" rel="noopener" href="https://download.docker.com/linux/centos/docker-ce.repo">https://download.docker.com/linux/centos/docker-</a><a target="_blank" rel="noopener" href="https://download.docker.com/linux/centos/docker-ce.repo"> </a><a target="_blank" rel="noopener" href="https://download.docker.com/linux/centos/docker-ce.repo">ce.repo</a></p>
</li>
<li><p>列出需要安装的版本列表</p>
<p> 276.png)</p>
<p> 277.png) yum list docker-ce –showduplicates | sort -r</p>
<table>
<thead>
<tr>
<th>docker-ce.x86_64</th>
<th>3:18.09.1-3.el7</th>
<th>docker-ce-stable</th>
</tr>
</thead>
<tbody><tr>
<td>docker-ce.x86_64</td>
<td>3:18.09.0-3.el7</td>
<td>docker-ce-stable</td>
</tr>
<tr>
<td>docker-ce.x86_64</td>
<td>18.06.1.ce-3.el7</td>
<td>docker-ce-stable</td>
</tr>
<tr>
<td>docker-ce.x86_64</td>
<td>18.06.0.ce-3.el7</td>
<td>docker-ce-stable</td>
</tr>
<tr>
<td>……</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>安装指定版本（这里使用18.0.1版本）  278.png) sudo yum install docker-ce-18.06.1.ce 6）查看版本</p>
</li>
</ol>
<p> 279.png)</p>
<p> 280.png) docker -v 7）启动Docker</p>
<p>sudo systemctl start docker 启动</p>
<p>sudo systemctl enable docker 设置开机启动</p>
<ol>
<li><p>添加阿里云镜像下载地址</p>
<p> 281.png) vi &#x2F;etc&#x2F;docker&#x2F;daemon.json</p>
<p> 282.png)</p>
<p>{</p>
<p>“registry-mirrors”: [“<a target="_blank" rel="noopener" href="https://zydiol88.mirror.aliyuncs.com"]">https://zydiol88.mirror.aliyuncs.com&quot;]</a></p>
<p>}</p>
<p>内容如下：</p>
</li>
<li><p>重启Docker</p>
</li>
</ol>
<p> 283.png) sudo systemctl restart docker</p>
<h4 id="Docker基本命令快速入门-1）镜像命令"><a href="#Docker基本命令快速入门-1）镜像命令" class="headerlink" title="Docker基本命令快速入门 1）镜像命令"></a>Docker<strong>基本命令快速入门</strong> 1）镜像命令</h4><p>镜像：相当于应用的安装包，在Docker部署的任何应用都需要先构建成为镜像</p>
<p> 284.png)</p>
<p>docker search 镜像名称 搜索镜像 docker pull 镜像名称 拉取镜像 docker images 查看本地所有镜像</p>
<p> 285.png) docker rmi -f 镜像名称 删除镜像</p>
<p> 286.png)</p>
<p>docker pull openjdk:8-jdk-alpine</p>
<ol>
<li><p>容器命令</p>
<p>容器：容器是由镜像创建而来。容器是Docker运行应用的载体，每个应用都分别运行在Docker的每个容器中。</p>
<p> 287.png)</p>
<p>docker run -i 镜像名称:标签 运行容器（默认是前台运行）</p>
<p>docker ps 查看运行的容器</p>
<p>docker ps -a 查询所有容器常用的参数：</p>
<p>-i：运行容器</p>
<p>-d：后台守方式运行（守护式）</p>
<p>–name：给容器添加名称</p>
<p>-p：公开容器端口给当前宿主机</p>
<p>-v：挂载目录</p>
<p> 288.png)</p>
<p>docker exec -it 容器ID&#x2F;容器名称 &#x2F;bin&#x2F;bash 进入容器内部 docker start&#x2F;stop&#x2F;restart 容器名称&#x2F;ID 启动&#x2F;停止&#x2F;重启容器 docker rm -f 容器名称&#x2F;ID 删除容器</p>
<p>环境准备**(2)-Dockerﬁle**镜像脚本快速入门</p>
<h4 id="Dockerﬁle简介"><a href="#Dockerﬁle简介" class="headerlink" title="Dockerﬁle简介"></a>Dockerﬁle<strong>简介</strong></h4><p>Dockerﬁle其实就是我们用来构建Docker镜像的源码，当然这不是所谓的编程源码，而是一些命令的组合，只要理解它的逻辑和语法格式，就可以编写Dockerﬁle了。</p>
<p>简单点说，Dockerﬁle的作用：它可以让用户个性化定制Docker镜像。因为工作环境中的需求各式各样，网络上的镜像很难满足实际的需求。</p>
<h4 id="Dockerﬁle常见命令"><a href="#Dockerﬁle常见命令" class="headerlink" title="Dockerﬁle常见命令"></a>Dockerﬁle<strong>常见命令</strong></h4><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>FROM image_name:tag</td>
<td></td>
</tr>
<tr>
<td>MAINTAINER user_name</td>
<td>声明镜像的作者</td>
</tr>
<tr>
<td>ENV key value</td>
<td>设置环境变量 (可以写多条)</td>
</tr>
<tr>
<td>RUN command</td>
<td>编译镜像时运行的脚本(可以写多条)</td>
</tr>
<tr>
<td>CMD</td>
<td>设置容器的启动命令</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>设置容器的入口程序</td>
</tr>
<tr>
<td>ADD source_dir&#x2F;ﬁle dest_dir&#x2F;ﬁle</td>
<td>将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压</td>
</tr>
<tr>
<td>COPY source_dir&#x2F;ﬁle dest_dir&#x2F;ﬁle</td>
<td>和ADD相似，但是如果有压缩文件并不能解压</td>
</tr>
<tr>
<td>WORKDIR path_dir</td>
<td>设置工作目录</td>
</tr>
<tr>
<td>ARG</td>
<td>设置编译镜像时加入的参数</td>
</tr>
<tr>
<td>VOLUMN</td>
<td>设置容器的挂载卷</td>
</tr>
</tbody></table>
<p>镜像构建示意图：</p>
<p> 289.jpg)</p>
<p>可以看到，新镜像是从基础镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层</p>
<p> 290.png)</p>
<p>RUN、CMD、ENTRYPOINT的区别？</p>
<p>RUN：用于指定 docker build 过程中要运行的命令，即是创建 Docker 镜像（image）的步骤</p>
<p>CMD：设置容器的启动命令， Dockerﬁle 中只能有一条 CMD 命令，如果写了多条则最后一条生效，</p>
<p>CMD不支持接收docker run的参数。</p>
<p>ENTRYPOINT：入口程序是容器启动时执行的程序， docker run 中最后的命令将作为参数传递给入口程序 ，ENTRYPOINY类似于 CMD 指令，但可以接收docker run的参数 。</p>
<p> 291.png)</p>
<p>FROM oraclelinux:7-slim</p>
<p>ARG MYSQL_SERVER_PACKAGE&#x3D;mysql-community-server-minimal-5.7.28 ARG MYSQL_SHELL_PACKAGE&#x3D;mysql-shell-8.0.18</p>
<p>以下是mysql官方镜像的Dockerﬁle示例：</p>
<p> 292.png)</p>
<p># Install server</p>
<p>RUN yum install -y <a target="_blank" rel="noopener" href="https://repo.mysql.com/mysql-community-minimal-release-">https://repo.mysql.com/mysql-community-minimal-release-</a> el7.rpm \</p>
<p><a target="_blank" rel="noopener" href="https://repo.mysql.com/mysql-community-release-el7.rpm">https://repo.mysql.com/mysql-community-release-el7.rpm</a> \ &amp;&amp; yum-config-manager –enable mysql57-server-minimal \</p>
<p>&amp;&amp; yum install -y \</p>
<p>$MYSQL_SERVER_PACKAGE \</p>
<p>$MYSQL_SHELL_PACKAGE \</p>
<p>libpwquality \ &amp;&amp; yum clean all \</p>
<p>&amp;&amp; mkdir &#x2F;docker-entrypoint-initdb.d</p>
<p>VOLUME &#x2F;var&#x2F;lib&#x2F;mysql</p>
<p>COPY docker-entrypoint.sh &#x2F;entrypoint.sh COPY healthcheck.sh &#x2F;healthcheck.sh ENTRYPOINT [“&#x2F;entrypoint.sh”] HEALTHCHECK CMD &#x2F;healthcheck.sh</p>
<p>EXPOSE 3306 33060</p>
<p>CMD [“mysqld”]</p>
<p>使用<strong>Dockerﬁle</strong>制作微服务镜像</p>
<p> 293.png)</p>
<p>FROM openjdk:8-jdk-alpine ARG JAR_FILE</p>
<p>COPY ${JAR_FILE} app.jar EXPOSE 10086</p>
<p>ENTRYPOINT [“java”,”-jar”,”&#x2F;app.jar”]</p>
<p>我们利用Dockerﬁle制作一个Eureka注册中心的镜像 1）上传Eureka的微服务jar包到linux 2）编写Dockerﬁle</p>
</li>
<li><p>构建镜像</p>
</li>
</ol>
<p> 294.png) docker build –build-arg JAR_FILE&#x3D;tensquare_eureka_server-1.0-SNAPSHOT.jar -t eureka:v1 . 4）查看镜像是否创建成功</p>
<p> 295.png) docker images</p>
<ol>
<li><p>创建容器</p>
<p> 296.png) docker run -i –name&#x3D;eureka -p 10086:10086 eureka:v1 6）访问容器</p>
<p><a target="_blank" rel="noopener" href="http://192.168.66.101:10086/">http://192.168.66.101:10086</a></p>
<p>环境准备**(3)-Harbor**镜像仓库安装及使用</p>
<h4 id="Harbor简介"><a href="#Harbor简介" class="headerlink" title="Harbor简介"></a>Harbor<strong>简介</strong></h4><p> 297.jpg)</p>
<p>Harbor（港口，港湾）是一个用于存储和分发Docker镜像的企业级Registry服务器。</p>
<p>除了Harbor这个私有镜像仓库之外，还有Docker官方提供的Registry。相对Registry，Harbor具有很多优势：</p>
<ol>
<li>提供分层传输机制，优化网络传输 Docker镜像是是分层的，而如果每次传输都使用全量文件(所以用FTP的方式并不适合)，显然不经济。必须提供识别分层传输的机制，以层的UUID为标识，确定传输的对象。</li>
<li>提供WEB界面，优化用户体验 只用镜像的名字来进行上传下载显然很不方便，需要有一个用户界面可以支持登陆、搜索功能，包括区分公有、私有镜像。</li>
<li>支持水平扩展集群 当有用户对镜像的上传下载操作集中在某服务器，需要对相应的访问压力作分解。</li>
<li>良好的安全机制 企业中的开发团队有很多不同的职位，对于不同的职位人员，分配不同的权限，具有更好的安全性。</li>
</ol>
</li>
</ol>
<h4 id="Harbor安装"><a href="#Harbor安装" class="headerlink" title="Harbor安装"></a>Harbor<strong>安装</strong></h4><p>Harbor需要安装在192.168.66.102上面 </p>
<p>1）先安装Docker并启动Docker（已完成）</p>
<p>参考之前的安装过程</p>
<p>2）先安装docker-compose</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo curl -L https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/docker/</span>compose<span class="hljs-regexp">/releases/</span>download<span class="hljs-regexp">/1.21.2/</span>docker-compose-$(uname -s)-$(uname -m) -o <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-compose<br><br></code></pre></td></tr></table></figure>

<p>3）给docker-compose添加执行权限</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo chmod +x <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-compose <br></code></pre></td></tr></table></figure>

<p>4）查看docker-compose是否安装成功</p>
 <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker-compose -<span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure>

<p>5）下载Harbor的压缩包（本课程版本为：v1.9.2<a target="_blank" rel="noopener" href="https://github.com/goharbor/harbor/releases">） </a></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/goharbor/</span>harbor/releases<br></code></pre></td></tr></table></figure>

<p>6）上传压缩包到linux，并解压</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xzf harbor-oﬄine-installer-v1.9.2.tgz<br><span class="hljs-built_in">mkdir</span> /opt/harbor<br><span class="hljs-built_in">mv</span> harbor/* /opt/harbor <br><span class="hljs-built_in">cd</span> /opt/harbor<br><br></code></pre></td></tr></table></figure>

<p>7）修改Harbor的配置</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">vi</span> harbor.yml<br></code></pre></td></tr></table></figure>

<p>修改hostname和port </p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hostname</span>: <span class="hljs-number">192.168.66.102</span><br><span class="hljs-attribute">port</span>: <span class="hljs-number">85</span><br><br></code></pre></td></tr></table></figure>

<p>8）安装Harbor</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./prepare<br>./install.sh<br><br></code></pre></td></tr></table></figure>

<p> 9）启动Harbor</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment">#启动</span><br>docker-compose up -d  <br><span class="hljs-comment">#停止</span><br>docker-compose <span class="hljs-literal">stop</span>  <br><span class="hljs-comment">#重新启动</span><br>docker-compose restart <br><br></code></pre></td></tr></table></figure>

<p>10）访问Harbor <a target="_blank" rel="noopener" href="http://192.168.66.102:85/">http://192.168.66.102:85</a></p>
<p>默认账户密码：admin&#x2F;Harbor12345</p>
<img src="/2024/01/31/jenkins-cicd/image-20240128132850493.png" srcset="/img/loading.gif" lazyload class="" title="image-20240128132850493">

<p>在<strong>Harbor</strong>创建用户和项目</p>
<ol>
<li><p>创建项目</p>
<p>Harbor的项目分为公开和私有的：</p>
<p>公开项目：所有用户都可以访问，通常存放公共的镜像，默认有一个library公开项目。私有项目：只有授权用户才可以访问，通常存放项目本身的镜像。</p>
<p>我们可以为微服务项目创建一个新的项目：</p>
<p> 307.jpg)</p>
<p> 308.jpg)</p>
</li>
<li><p>创建用户</p>
<p> 309.jpg)</p>
<p> 310.jpg)</p>
<p>创建的用户为： itcast&#x2F;Itcast123</p>
</li>
<li><p>给私有项目分配用户 进入tensquare项目-&gt;成员</p>
<p> 311.jpg)</p>
<p> 312.jpg)</p>
<p> 313.jpg)</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>权限说明</th>
</tr>
</thead>
<tbody><tr>
<td>访客</td>
<td>对于指定项目拥有只读权限</td>
</tr>
<tr>
<td>开发人员</td>
<td>对于指定项目拥有读写权限</td>
</tr>
<tr>
<td>维护人员</td>
<td>对于指定项目拥有读写权限，创建 Webhooks</td>
</tr>
<tr>
<td>项目管理员</td>
<td>除了读写权限，同时拥有用户管理&#x2F;镜像扫描等管理权限</td>
</tr>
</tbody></table>
</li>
<li><p>以新用户登录Harbor</p>
<p> 314.jpg)</p>
<p>把镜像上传到<strong>Harbor</strong> 1）给镜像打上标签</p>
<p> 315.png) docker tag eureka:v1 192.168.66.102:85&#x2F;tensquare&#x2F;eureka:v1 2）推送镜像</p>
<p>docker push 192.168.66.102:85&#x2F;tensquare&#x2F;eureka:v1</p>
<p> 316.png)</p>
<p>The push refers to repository [192.168.66.102:85&#x2F;tensquare&#x2F;eureka]</p>
<p>Get <a target="_blank" rel="noopener" href="https://192.168.66.102:85/v2/">https://192.168.66.102:85/v2/</a>: http: server gave HTTP response to HTTPS client</p>
<p>这时会出现以上报错，是因为Docker没有把Harbor加入信任列表中</p>
<p> 317.png)</p>
<p>3）把Harbor地址加入到Docker信任列表 vi &#x2F;etc&#x2F;docker&#x2F;daemon.json</p>
<p> 318.png)</p>
<p>{</p>
<p>“registry-mirrors”: [“<a target="_blank" rel="noopener" href="https://zydiol88.mirror.aliyuncs.com"]">https://zydiol88.mirror.aliyuncs.com&quot;]</a>, “insecure-registries”: [“192.168.66.102:85”]</p>
<p>}</p>
<p> 319.png)</p>
<p>denied: requested access to the resource is denied</p>
<p>需要重启Docker 4）再次执行推送命令，会提示权限不足</p>
<p>需要先登录Harbor，再推送镜像</p>
</li>
<li><p>登录Harbor</p>
</li>
</ol>
<p> 320.png)</p>
<p>WARNING! Using –password via the CLI is insecure. Use –password-stdin. WARNING! Your password will be stored unencrypted in &#x2F;root&#x2F;.docker&#x2F;config.json. Configure a credential helper to remove this warning. See <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/login/#credentials-store">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</a></p>
<p>Login Succeeded</p>
<p> 321.png) docker login -u 用户名 -p 密码 192.168.66.102:85</p>
<p> 322.jpg)</p>
<p>从<strong>Harbor</strong>下载镜像</p>
<p>需求：在192.168.66.103服务器完成从Harbor下载镜像 1）安装Docker，并启动Docker（已经完成） 2）修改Docker配置</p>
<p> 323.png)</p>
<p>{</p>
<p>“registry-mirrors”: [“<a target="_blank" rel="noopener" href="https://zydiol88.mirror.aliyuncs.com"]">https://zydiol88.mirror.aliyuncs.com&quot;]</a>, “insecure-registries”: [“192.168.66.102:85”]</p>
<p>}</p>
<p> 324.png) vi &#x2F;etc&#x2F;docker&#x2F;daemon.json</p>
<p>重启docker 3）先登录，再从Harbor下载镜像</p>
<p> 325.png)</p>
<p>docker login -u 用户名 -p 密码 192.168.66.102:85</p>
<p> 326.png)</p>
<p>docker pull 192.168.66.102:85&#x2F;tensquare&#x2F;eureka:v1</p>
<p>微服务持续集成**(1)-<strong>项目代码上传到</strong>Gitlab**</p>
<p>在IDEA操作即可，参考之前的步骤。包括后台微服务和前端web网站代码</p>
<p> 327.jpg)</p>
<p>微服务持续集成**(2)-<strong>从</strong>Gitlab**拉取项目源码</p>
<ol>
<li><p>创建Jenkinsﬁle文件</p>
<p> 328.jpg)</p>
<p> 329.png)</p>
<p>&#x2F;&#x2F;gitlab的凭证</p>
<p>def git_auth &#x3D; “68f2087f-a034-4d39-a9ff-1f776dd3dfa8”</p>
<p>node {</p>
<p>stage(‘拉取代码’) {</p>
<p>checkout([$class: ‘GitSCM’, branches: [[name: ‘*&#x2F;${branch}’]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: “${git_auth}”, url: ‘<a href="mailto:&#103;&#x69;&#x74;&#64;&#49;&#57;&#50;&#46;&#49;&#x36;&#56;&#46;&#x36;&#x36;&#x2e;&#x31;&#48;&#48;">&#103;&#x69;&#x74;&#64;&#49;&#57;&#50;&#46;&#49;&#x36;&#56;&#46;&#x36;&#x36;&#x2e;&#x31;&#48;&#48;</a>:itheima_group&#x2F;tensquare_back.git’]]])</p>
<p>}</p>
<p>}</p>
</li>
<li><p>拉取Jenkinsﬁle文件</p>
</li>
</ol>
<p> 330.jpg)</p>
<p>微服务持续集成**(3)-<strong>提交到</strong>SonarQube**代码审查</p>
<ol>
<li><p>创建项目，并设置参数</p>
<p>创建tensquare_back项目，添加两个参数</p>
<p> 331.jpg)</p>
</li>
<li><p>每个项目的根目录下添加sonar-project.properties</p>
</li>
</ol>
<p> 332.png)</p>
<p> 333.png)</p>
<p># must be unique in a given SonarQube instance sonar.projectKey&#x3D;tensquare_zuul</p>
<p># this is the name and version displayed in the SonarQube UI. Was mandatory prior to SonarQube 6.1.</p>
<p>sonar.projectName&#x3D;tensquare_zuul sonar.projectVersion&#x3D;1.0</p>
<p># Path is relative to the sonar-project.properties file. Replace “&quot; by “&#x2F;“ on Windows.</p>
<p># This property is optional if sonar.modules is set. sonar.sources&#x3D;. sonar.exclusions&#x3D;<strong>&#x2F;test&#x2F;</strong>,<strong>&#x2F;target&#x2F;</strong> sonar.java.binaries&#x3D;.</p>
<p>sonar.java.source&#x3D;1.8 sonar.java.target&#x3D;1.8 sonar.java.libraries&#x3D;<strong>&#x2F;target&#x2F;classes&#x2F;</strong></p>
<p># Encoding of the source code. Default is default system encoding sonar.sourceEncoding&#x3D;UTF-8</p>
<p> 334.png)</p>
<p>&#x2F;&#x2F;gitlab的凭证</p>
<p>def git_auth &#x3D; “68f2087f-a034-4d39-a9ff-1f776dd3dfa8”</p>
<p>&#x2F;&#x2F;构建版本的名称</p>
<p>def tag &#x3D; “latest”</p>
<p>node {</p>
<p>stage(‘拉取代码’) {</p>
<p>checkout([$class: ‘GitSCM’, branches: [[name: ‘*&#x2F;${branch}’]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: “${git_auth}”, url: ‘<a href="mailto:&#103;&#105;&#116;&#x40;&#x31;&#57;&#x32;&#x2e;&#x31;&#54;&#x38;&#46;&#54;&#x36;&#46;&#49;&#x30;&#x30;">&#103;&#105;&#116;&#x40;&#x31;&#57;&#x32;&#x2e;&#x31;&#54;&#x38;&#46;&#54;&#x36;&#46;&#49;&#x30;&#x30;</a>:itheima_group&#x2F;tensquare_back.git’]]])</p>
<p>}</p>
<p>stage(‘代码审查’) {</p>
<p>def scannerHome &#x3D; tool ‘sonarqube-scanner’ withSonarQubeEnv(‘sonarqube6.7.4’) {</p>
<p>sh “””</p>
<p>cd ${project_name}</p>
<p>${scannerHome}&#x2F;bin&#x2F;sonar-scanner</p>
<p>“””</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>注意：修改sonar.projectKey和sonar.projectName 3）修改Jenkinsﬁle构建脚本</p>
<p>微服务持续集成**(4)-<strong>使用</strong>Dockerﬁle**编译、生成镜像</p>
<p>利用dockerﬁle-maven-plugin插件构建Docker镜像</p>
<ol>
<li><p>在每个微服务项目的pom.xml加入dockerﬁle-maven-plugin插件</p>
<p> 335.png)</p>
<plugin>

<p><groupId>com.spotify</groupId></p>
<p><artifactId>dockerfile-maven-plugin</artifactId></p>
<p><version>1.3.6</version></p>
<configuration>

<p><repository>${project.artifactId}</repository></p>
<buildArgs>

<p><JAR_FILE>target&#x2F;${project.build.finalName}.jar</JAR_FILE></p>
</buildArgs>

</configuration>

</plugin>



<p> 336.png)</p>
<p>#FROM java:8</p>
<p>FROM openjdk:8-jdk-alpine ARG JAR_FILE</p>
<p>COPY ${JAR_FILE} app.jar EXPOSE 10086</p>
<p>ENTRYPOINT [“java”,”-jar”,”&#x2F;app.jar”]</p>
</li>
<li><p>在每个微服务项目根目录下建立Dockerﬁle文件</p>
<p>注意：每个项目公开的端口不一样</p>
<p> 337.png)</p>
<p>&#x2F;&#x2F;gitlab的凭证</p>
<p>def git_auth &#x3D; “68f2087f-a034-4d39-a9ff-1f776dd3dfa8”</p>
<p>&#x2F;&#x2F;构建版本的名称</p>
<p>def tag &#x3D; “latest”</p>
<p>&#x2F;&#x2F;Harbor私服地址</p>
<p>def harbor_url &#x3D; “192.168.66.102:85&#x2F;tensquare&#x2F;“</p>
<p>node {</p>
<p>stage(‘拉取代码’) {</p>
<p>checkout([$class: ‘GitSCM’, branches: [[name: ‘*&#x2F;${branch}’]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: “${git_auth}”, url: ‘<a href="mailto:&#x67;&#x69;&#x74;&#x40;&#x31;&#57;&#50;&#46;&#x31;&#54;&#56;&#46;&#54;&#54;&#46;&#49;&#x30;&#48;">&#x67;&#x69;&#x74;&#x40;&#x31;&#57;&#50;&#46;&#x31;&#54;&#56;&#46;&#54;&#54;&#46;&#49;&#x30;&#48;</a>:itheima_group&#x2F;tensquare_back.git’]]])</p>
<p>}</p>
<p>stage(‘代码审查’) {</p>
<p>def scannerHome &#x3D; tool ‘sonarqube-scanner’ withSonarQubeEnv(‘sonarqube6.7.4’) {</p>
<p>sh “””</p>
<p>cd ${project_name}</p>
<p>${scannerHome}&#x2F;bin&#x2F;sonar-scanner</p>
<p>“””</p>
<p>}</p>
<p>}</p>
<p>stage(‘编译，构建镜像’) {</p>
<p>&#x2F;&#x2F;定义镜像名称</p>
<p>def imageName &#x3D; “${project_name}:${tag}”</p>
<p>&#x2F;&#x2F;编译，安装公共工程</p>
</li>
<li><p>修改Jenkinsﬁle构建脚本</p>
</li>
</ol>
<p> 338.png)</p>
<p>sh “mvn -f tensquare_common clean install”</p>
<p>&#x2F;&#x2F;编译，构建本地镜像</p>
<p>sh “mvn -f ${project_name} clean package dockerfile:build”</p>
<p>}</p>
<p>}</p>
<p>注意：如果出现找不到父工程依赖，需要手动把父工程的依赖上传到仓库中</p>
<p>微服务持续集成**(5)-<strong>上传到</strong>Harbor**镜像仓库</p>
<p> 339.png)</p>
<p>&#x2F;&#x2F;gitlab的凭证</p>
<p>def git_auth &#x3D; “68f2087f-a034-4d39-a9ff-1f776dd3dfa8”</p>
<p>&#x2F;&#x2F;构建版本的名称</p>
<p>def tag &#x3D; “latest”</p>
<p>&#x2F;&#x2F;Harbor私服地址</p>
<p>def harbor_url &#x3D; “192.168.66.102:85”</p>
<p>&#x2F;&#x2F;Harbor的项目名称</p>
<p>def harbor_project_name &#x3D; “tensquare”</p>
<p>&#x2F;&#x2F;Harbor的凭证</p>
<p>def harbor_auth &#x3D; “ef499f29-f138-44dd-975e-ff1ca1d8c933”</p>
<p>node {</p>
<p>stage(‘拉取代码’) {</p>
<p>checkout([$class: ‘GitSCM’, branches: [[name: ‘*&#x2F;${branch}’]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: “${git_auth}”, url: ‘<a href="mailto:&#x67;&#105;&#116;&#x40;&#x31;&#x39;&#x32;&#46;&#x31;&#x36;&#x38;&#46;&#x36;&#54;&#x2e;&#x31;&#48;&#x30;">&#x67;&#105;&#116;&#x40;&#x31;&#x39;&#x32;&#46;&#x31;&#x36;&#x38;&#46;&#x36;&#54;&#x2e;&#x31;&#48;&#x30;</a>:itheima_group&#x2F;tensquare_back.git’]]])</p>
<p>}</p>
<p>stage(‘代码审查’) {</p>
<p>def scannerHome &#x3D; tool ‘sonarqube-scanner’ withSonarQubeEnv(‘sonarqube6.7.4’) {</p>
<p>sh “””</p>
<p>cd ${project_name}</p>
<p>${scannerHome}&#x2F;bin&#x2F;sonar-scanner</p>
<p>“””</p>
<p>}</p>
<p>}</p>
<p>stage(‘编译，构建镜像’) {</p>
<p>&#x2F;&#x2F;定义镜像名称</p>
<p>def imageName &#x3D; “${project_name}:${tag}”</p>
<p>&#x2F;&#x2F;编译，安装公共工程</p>
<p>sh “mvn -f tensquare_common clean install”</p>
<p>&#x2F;&#x2F;编译，构建本地镜像</p>
<p>sh “mvn -f ${project_name} clean package dockerfile:build”</p>
<p>&#x2F;&#x2F;给镜像打标签</p>
<p>sh “docker tag ${imageName}</p>
<p>${harbor_url}&#x2F;${harbor_project_name}&#x2F;${imageName}”</p>
<ol>
<li><p>修改Jenkinsﬁle构建脚本</p>
<p> 340.png)</p>
<p>&#x2F;&#x2F;登录Harbor，并上传镜像 withCredentials([usernamePassword(credentialsId: “${harbor_auth}”,</p>
<p>passwordVariable: ‘password’, usernameVariable: ‘username’)]) {</p>
<p>&#x2F;&#x2F;登录</p>
<p>sh “docker login -u ${username} -p ${password} ${harbor_url}”</p>
<p>&#x2F;&#x2F;上传镜像</p>
<p>sh “docker push ${harbor_url}&#x2F;${harbor_project_name}&#x2F;${imageName}”</p>
<p>}</p>
<p>&#x2F;&#x2F;删除本地镜像</p>
<p>sh “docker rmi -f ${imageName}”</p>
<p>sh “docker rmi -f ${harbor_url}&#x2F;${harbor_project_name}&#x2F;${imageName}”</p>
<p>}</p>
<p>}</p>
</li>
<li><p>使用凭证管理Harbor私服账户和密码</p>
</li>
</ol>
<p>先在凭证建立Harbor的凭证，在生成凭证脚本代码</p>
<p> 341.jpg)</p>
<p>微服务持续集成**(6)-**拉取镜像和发布应用</p>
<p> 342.jpg)</p>
<p>注意：192.168.66.103服务已经安装Docker并启动<strong>安装</strong> <strong>Publish Over SSH</strong> <strong>插件</strong></p>
<p>安装以下插件，可以实现远程发送Shell命令</p>
<p> 343.jpg)</p>
<p>配置远程部署服务器</p>
<ol>
<li><p>拷贝公钥到远程服务器</p>
<p> 344.png) ssh-copy-id 192.168.66.103 2）系统配置-&gt;添加远程服务器</p>
<p> 345.jpg)</p>
<p>修改<strong>Jenkinsﬁle</strong>构建脚本生成远程调用模板代码</p>
<p> 346.jpg)</p>
<p> 347.png)</p>
<p>&#x2F;&#x2F;gitlab的凭证</p>
<p>def git_auth &#x3D; “68f2087f-a034-4d39-a9ff-1f776dd3dfa8”</p>
<p>&#x2F;&#x2F;构建版本的名称</p>
<p>def tag &#x3D; “latest”</p>
<p>添加一个port参数</p>
<p> 348.jpg)</p>
<p>&#x2F;&#x2F;Harbor私服地址</p>
<p>def harbor_url &#x3D; “192.168.66.102:85”</p>
<p>&#x2F;&#x2F;Harbor的项目名称</p>
<p>def harbor_project_name &#x3D; “tensquare”</p>
<p>&#x2F;&#x2F;Harbor的凭证</p>
<p>def harbor_auth &#x3D; “ef499f29-f138-44dd-975e-ff1ca1d8c933”</p>
<p>node {</p>
<p>stage(‘拉取代码’) {</p>
<p>checkout([$class: ‘GitSCM’, branches: [[name: ‘*&#x2F;${branch}’]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: “${git_auth}”, url: ‘<a href="mailto:&#x67;&#105;&#116;&#64;&#49;&#57;&#50;&#46;&#x31;&#54;&#56;&#46;&#x36;&#54;&#x2e;&#49;&#48;&#48;">&#x67;&#105;&#116;&#64;&#49;&#57;&#50;&#46;&#x31;&#54;&#56;&#46;&#x36;&#54;&#x2e;&#49;&#48;&#48;</a>:itheima_group&#x2F;tensquare_back.git’]]])</p>
<p>}</p>
<p>stage(‘代码审查’) {</p>
<p>def scannerHome &#x3D; tool ‘sonarqube-scanner’ withSonarQubeEnv(‘sonarqube6.7.4’) {</p>
<p>sh “””</p>
<p>cd ${project_name}</p>
<p>${scannerHome}&#x2F;bin&#x2F;sonar-scanner</p>
<p>“””</p>
<p>}</p>
<p>}</p>
<p>stage(‘编译，构建镜像，部署服务’) {</p>
<p>&#x2F;&#x2F;定义镜像名称</p>
<p>def imageName &#x3D; “${project_name}:${tag}”</p>
<p>&#x2F;&#x2F;编译并安装公共工程</p>
<p>sh “mvn -f tensquare_common clean install”</p>
<p>&#x2F;&#x2F;编译，构建本地镜像</p>
<p>sh “mvn -f ${project_name} clean package dockerfile:build”</p>
<p>&#x2F;&#x2F;给镜像打标签</p>
<p>sh “docker tag ${imageName}</p>
<p>${harbor_url}&#x2F;${harbor_project_name}&#x2F;${imageName}”</p>
<p>&#x2F;&#x2F;登录Harbor，并上传镜像 withCredentials([usernamePassword(credentialsId: “${harbor_auth}”,</p>
<p>passwordVariable: ‘password’, usernameVariable: ‘username’)]) {</p>
<p>&#x2F;&#x2F;登录</p>
<p>sh “docker login -u ${username} -p ${password} ${harbor_url}”</p>
<p>&#x2F;&#x2F;上传镜像</p>
<p>sh “docker push ${harbor_url}&#x2F;${harbor_project_name}&#x2F;${imageName}”</p>
<p>}</p>
<p>&#x2F;&#x2F;删除本地镜像</p>
<p>sh “docker rmi -f ${imageName}”</p>
<p>sh “docker rmi -f ${harbor_url}&#x2F;${harbor_project_name}&#x2F;${imageName}”</p>
<p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;以下为远程调用进行项目部署&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p> 349.png)</p>
<p> 350.png)</p>
<p>sshPublisher(publishers: [sshPublisherDesc(configName: ‘master_server’, transfers: [sshTransfer(cleanRemote: false, excludes: ‘’, execCommand: “&#x2F;opt&#x2F;jenkins_shell&#x2F;deploy.sh $harbor_url $harbor_project_name $project_name</p>
<p>$tag $port”, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: ‘[, ]+’, remoteDirectory: ‘’, remoteDirectorySDF: false, removePrefix: ‘’, sourceFiles: ‘’)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])</p>
<p>}</p>
<p>}</p>
<p> 351.png)</p>
<p>编写<strong>deploy.sh</strong>部署脚本</p>
<p>#! &#x2F;bin&#x2F;sh #接收外部参数</p>
<p>harbor_url&#x3D;$1 harbor_project_name&#x3D;$2 project_name&#x3D;$3</p>
<p>tag&#x3D;$4 port&#x3D;$5</p>
<p>imageName&#x3D;$harbor_url&#x2F;$harbor_project_name&#x2F;$project_name:$tag</p>
<p>echo “$imageName”</p>
<p>#查询容器是否存在，存在则删除</p>
<p>containerId&#x3D;<code>docker ps -a | grep -w $&#123;project_name&#125;:$&#123;tag&#125; | awk &#39;&#123;print $1&#125;&#39;</code> if [ “$containerId” !&#x3D; “” ] ; then</p>
<p>#停掉容器</p>
<p>docker stop $containerId</p>
<p>#删除容器</p>
<p>docker rm $containerId</p>
<p>echo “成功删除容器”</p>
<p>fi</p>
<p>#查询镜像是否存在，存在则删除</p>
<p>imageId&#x3D;<code>docker images | grep -w $project_name | awk &#39;&#123;print $3&#125;&#39;</code></p>
<p>if [ “$imageId” !&#x3D; “” ] ; then #删除镜像</p>
<p>docker rmi -f $imageId</p>
<p>echo “成功删除镜像”</p>
<p>fi</p>
<p># 登录Harbor私服</p>
<p>docker login -u itcast -p Itcast123 $harbor_url</p>
<p># 下载镜像</p>
<p>docker pull $imageName</p>
<p># 启动容器</p>
<p>docker run -di -p $port:$port $imageName</p>
<p> 352.png)</p>
<p>echo “容器启动成功”</p>
<p>上传deploy.sh文件到&#x2F;opt&#x2F;jenkins_shell目录下，且文件至少有执行权限！</p>
<p> 353.jpg)</p>
<p> 354.png) chmod +x deploy.sh 添加执行权限<strong>导入数据，测试微服务</strong></p>
<p>微服务持续集成**(7)-<strong>部署前端静态</strong>web**网站</p>
<p> 355.jpg)</p>
<p>安装<strong>Nginx</strong>服务器</p>
<p> 356.png)</p>
<p>yum install epel-release yum -y install nginx 安装</p>
<p>修改nginx的端口，默认80，改为9090：</p>
<p> 357.png)</p>
<p>server {</p>
<p>listen 9090 default_server;</p>
<p>listen [::]:9090 default_server; server_name _;</p>
<p>root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</p>
<p> 358.png) vi &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</p>
<p> 359.png)</p>
<p>还需要关闭selinux，将SELINUX&#x3D;disabled setenforce 0 先临时关闭</p>
<p>vi &#x2F;etc&#x2F;selinux&#x2F;conﬁg 编辑文件，永久关闭 SELINUX&#x3D;disabled</p>
<p>启动Nginx</p>
<p> 360.png)</p>
<p>systemctl enable nginx 设置开机启动</p>
<p>systemctl start nginx 启动 systemctl stop nginx 停止 systemctl restart nginx 重启</p>
<p>访问：<a target="_blank" rel="noopener" href="http://192.168.66.103:9090/">http://192.168.66.103:9090/</a></p>
<p> 361.jpg)</p>
<p>安装<strong>NodeJS</strong>插件</p>
<p> 362.jpg)</p>
<h4 id="Jenkins配置Nginx服务器"><a href="#Jenkins配置Nginx服务器" class="headerlink" title="Jenkins配置Nginx服务器"></a>Jenkins<strong>配置</strong>Nginx<strong>服务器</strong></h4><p>Manage Jenkins-&gt;Global Tool Conﬁguration</p>
<p> 363.jpg)</p>
<p>创建前端流水线项目</p>
<p> 364.jpg)</p>
<p> 365.jpg)</p>
<p> 366.jpg)</p>
<p> 367.png)</p>
<p>&#x2F;&#x2F;gitlab的凭证</p>
<p>def git_auth &#x3D; “68f2087f-a034-4d39-a9ff-1f776dd3dfa8”</p>
<p>node {</p>
<p>stage(‘拉取代码’) {</p>
<p>checkout([$class: ‘GitSCM’, branches: [[name: ‘*&#x2F;${branch}’]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: “${git_auth}”, url: ‘<a href="mailto:&#x67;&#x69;&#116;&#x40;&#49;&#x39;&#50;&#46;&#x31;&#54;&#x38;&#x2e;&#x36;&#x36;&#x2e;&#x31;&#x30;&#x30;">&#x67;&#x69;&#116;&#x40;&#49;&#x39;&#50;&#46;&#x31;&#54;&#x38;&#x2e;&#x36;&#x36;&#x2e;&#x31;&#x30;&#x30;</a>:itheima_group&#x2F;tensquare_front.git’]]])</p>
<p>}</p>
<p>stage(‘打包，部署网站’) {</p>
<p>&#x2F;&#x2F;使用NodeJS的npm进行打包 nodejs(‘nodejs12’){</p>
<p>sh ‘’’</p>
<p>npm install npm run build</p>
<p>‘’’</p>
<p>}</p>
<p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;以下为远程调用进行项目部署&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>sshPublisher(publishers: [sshPublisherDesc(configName: ‘master_server’, transfers: [sshTransfer(cleanRemote: false, excludes: ‘’, execCommand: ‘’, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: ‘[, ]+’, remoteDirectory: ‘&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html’, remoteDirectorySDF: false, removePrefix: ‘dist’, sourceFiles: ‘dist&#x2F;**’)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])</p>
<p>}</p>
<p>}</p>
<p>建立<strong>Jenkinsﬁle</strong>构建脚本</p>
<p>完成后，访问：<a target="_blank" rel="noopener" href="http://192.168.66.103:9090/">http://192.168.66.103:9090</a> 进行测试。</p>
<h2 id="5、Jenkins-Docker-SpringCloud微服务持续集成-下"><a href="#5、Jenkins-Docker-SpringCloud微服务持续集成-下" class="headerlink" title="5、Jenkins+Docker+SpringCloud微服务持续集成(下)"></a>5<strong>、</strong>Jenkins+Docker+SpringCloud<strong>微服务持续集成</strong>(<strong>下</strong>)</h2><h3 id="Jenkins-Docker-SpringCloud部署方案优化"><a href="#Jenkins-Docker-SpringCloud部署方案优化" class="headerlink" title="Jenkins+Docker+SpringCloud部署方案优化"></a>Jenkins+Docker+SpringCloud<strong>部署方案优化</strong></h3><p>上面部署方案存在的问题：</p>
<ol>
<li>一次只能选择一个微服务部署</li>
<li>只有一台生产者部署服务器</li>
<li>每个微服务只有一个实例，容错率低</li>
</ol>
<p>优化方案：</p>
<ol>
<li>在一个Jenkins工程中可以选择多个微服务同时发布</li>
<li>在一个Jenkins工程中可以选择多台生产服务器同时部署</li>
<li>每个微服务都是以<strong>集群高可用</strong>形式部署</li>
</ol>
<h3 id="Jenkins-Docker-SpringCloud集群部署流程说明"><a href="#Jenkins-Docker-SpringCloud集群部署流程说明" class="headerlink" title="Jenkins+Docker+SpringCloud集群部署流程说明"></a>Jenkins+Docker+SpringCloud<strong>集群部署流程说明</strong></h3><p> 368.jpg)</p>
<p>修改所有微服务配置</p>
<p> 369.png)</p>
<p># 集群版</p>
<p>spring: application:</p>
<p>name: EUREKA-HA</p>
<p>-–</p>
<p>server: port: 10086</p>
<p>spring:</p>
<p># 指定profile&#x3D;eureka-server1 profiles: eureka-server1</p>
<p>eureka: instance:</p>
<p># 指定当profile&#x3D;eureka-server1时，主机名是eureka-server1</p>
<p>hostname: 192.168.66.103 client:</p>
<p>注册中心配置**(*)**</p>
<p> 370.png)</p>
<p>service-url:</p>
<p># 将自己注册到eureka-server1、eureka-server2这个Eureka上面去</p>
<p>defaultZone: <a target="_blank" rel="noopener" href="http://192.168.66.103:10086/eureka/,http://192.168.66.104:10086/eureka/">http://192.168.66.103:10086/eureka/,http://192.168.66.104:10086/eureka/</a></p>
<p>-–</p>
<p>server: port: 10086</p>
<p>spring:</p>
<p>profiles: eureka-server2 eureka:</p>
<p>instance:</p>
<p>hostname: 192.168.66.104 client:</p>
<p>service-url: defaultZone:</p>
<p><a target="_blank" rel="noopener" href="http://192.168.66.103:10086/eureka/,http://192.168.66.104:10086/eureka/">http://192.168.66.103:10086/eureka/,http://192.168.66.104:10086/eureka/</a></p>
<p>在启动微服务的时候，加入参数: <strong>spring.proﬁles.active</strong> 来读取对应的配置</p>
<p>其他微服务配置</p>
<p>除了Eureka注册中心以外，其他微服务配置都需要加入所有Eureka服务</p>
<p> 371.png)</p>
<p># Eureka配置 eureka:</p>
<p>client: service-url:</p>
<p>defaultZone: <a target="_blank" rel="noopener" href="http://192.168.66.103:10086/eureka,http://192.168.66.104:10086/eureka">http://192.168.66.103:10086/eureka,http://192.168.66.104:10086/eureka</a> # Eureka访问地址</p>
<p>instance:</p>
<p>prefer-ip-address: true</p>
<p>把代码提交到Gitlab中</p>
<p>设计<strong>Jenkins</strong>集群项目的构建参数 1）安装Extended Choice Parameter插件支持多选框</p>
<p> 372.jpg)</p>
</li>
<li><p>创建流水线项目</p>
<p> 373.jpg)</p>
</li>
<li><p>添加参数</p>
</li>
</ol>
<p>字符串参数：分支名称</p>
<p> 374.jpg)</p>
<p>多选框：项目名称</p>
<p> 375.jpg)</p>
<p> 376.jpg)</p>
<p> 377.jpg)</p>
<p> 378.jpg)</p>
<p> 379.png)</p>
<p>tensquare_eureka_server@10086,tensquare_zuul@10020,tensquare_admin_service@9001, tensquare_gathering@9002</p>
<p>最后效果：</p>
<p> 380.jpg)</p>
<p> 381.png)</p>
<p>&#x2F;&#x2F;gitlab的凭证</p>
<p>def git_auth &#x3D; “68f2087f-a034-4d39-a9ff-1f776dd3dfa8”</p>
<p>完成微服务构建镜像，上传私服</p>
<p>&#x2F;&#x2F;构建版本的名称</p>
<p>def tag &#x3D; “latest”</p>
<p>&#x2F;&#x2F;Harbor私服地址</p>
<p>def harbor_url &#x3D; “192.168.66.102:85”</p>
<p>&#x2F;&#x2F;Harbor的项目名称</p>
<p>def harbor_project_name &#x3D; “tensquare”</p>
<p>&#x2F;&#x2F;Harbor的凭证</p>
<p>def harbor_auth &#x3D; “ef499f29-f138-44dd-975e-ff1ca1d8c933”</p>
<p>node {</p>
<p>&#x2F;&#x2F;把选择的项目信息转为数组</p>
<p>def selectedProjects &#x3D; “${project_name}”.split(‘,’)</p>
<p>stage(‘拉取代码’) {</p>
<p>checkout([$class: ‘GitSCM’, branches: [[name: ‘*&#x2F;${branch}’]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: ‘${git_auth}’, url: ‘<a href="mailto:&#103;&#105;&#x74;&#x40;&#49;&#x39;&#50;&#x2e;&#49;&#x36;&#x38;&#46;&#x36;&#x36;&#46;&#x31;&#48;&#48;">&#103;&#105;&#x74;&#x40;&#49;&#x39;&#50;&#x2e;&#49;&#x36;&#x38;&#46;&#x36;&#x36;&#46;&#x31;&#48;&#48;</a>:itheima_group&#x2F;tensquare_back_cluster.git’]]])</p>
<p>}</p>
<p>stage(‘代码审查’) {</p>
<p>def scannerHome &#x3D; tool ‘sonarqube-scanner’ withSonarQubeEnv(‘sonarqube6.7.4’) {</p>
<p>for(int i&#x3D;0;i&lt;selectedProjects.size();i++){</p>
<p>&#x2F;&#x2F;取出每个项目的名称和端口</p>
<p>def currentProject &#x3D; selectedProjects[i];</p>
<p>&#x2F;&#x2F;项目名称</p>
<p>def currentProjectName &#x3D; currentProject.split(‘@’)[0]</p>
<p>&#x2F;&#x2F;项目启动端口</p>
<p>def currentProjectPort &#x3D; currentProject.split(‘@’)[1]</p>
<p>sh “””</p>
<p>“””</p>
<p>cd ${currentProjectName}</p>
<p>${scannerHome}&#x2F;bin&#x2F;sonar-scanner</p>
<p>echo “${currentProjectName}完成代码审查”</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>stage(‘编译，构建镜像，部署服务’) {</p>
<p>&#x2F;&#x2F;编译并安装公共工程</p>
<p>sh “mvn -f tensquare_common clean install”</p>
<p>for(int i&#x3D;0;i&lt;selectedProjects.size();i++){</p>
<p>&#x2F;&#x2F;取出每个项目的名称和端口</p>
<p>def currentProject &#x3D; selectedProjects[i];</p>
<p>&#x2F;&#x2F;项目名称</p>
<p>def currentProjectName &#x3D; currentProject.split(‘@’)[0]</p>
<p>&#x2F;&#x2F;项目启动端口</p>
<p>def currentProjectPort &#x3D; currentProject.split(‘@’)[1]</p>
<p>&#x2F;&#x2F;定义镜像名称</p>
<p>def imageName &#x3D; “${currentProjectName}:${tag}”</p>
<p>&#x2F;&#x2F;编译，构建本地镜像</p>
<p> 382.png)</p>
<p> 383.png)</p>
<p>sh “mvn -f ${currentProjectName} clean package</p>
<p>dockerfile:build”</p>
<p>&#x2F;&#x2F;给镜像打标签</p>
<p>sh “docker tag ${imageName}</p>
<p>${harbor_url}&#x2F;${harbor_project_name}&#x2F;${imageName}”</p>
<p>&#x2F;&#x2F;登录Harbor，并上传镜像 withCredentials([usernamePassword(credentialsId:</p>
<p>“${harbor_auth}”, passwordVariable: ‘password’, usernameVariable: ‘username’)])</p>
<p>{</p>
<p>&#x2F;&#x2F;登录</p>
<p>sh “docker login -u ${username} -p ${password}</p>
<p>${harbor_url}”</p>
<p>&#x2F;&#x2F;上传镜像</p>
<p>sh “docker push</p>
<p>${harbor_url}&#x2F;${harbor_project_name}&#x2F;${imageName}”</p>
<p>}</p>
<p>&#x2F;&#x2F;删除本地镜像</p>
<p>sh “docker rmi -f ${imageName}” sh “docker rmi -f</p>
<p>${harbor_url}&#x2F;${harbor_project_name}&#x2F;${imageName}”</p>
<p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;以下为远程调用进行项目部署&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>&#x2F;&#x2F;sshPublisher(publishers: [sshPublisherDesc(configName: ‘master_server’, transfers: [sshTransfer(cleanRemote: false, excludes: ‘’, execCommand: “&#x2F;opt&#x2F;jenkins_shell&#x2F;deployCluster.sh $harbor_url</p>
<p>$harbor_project_name $currentProjectName $tag $currentProjectPort”, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: ‘[, ]+’, remoteDirectory: ‘’, remoteDirectorySDF: false, removePrefix: ‘’, sourceFiles: ‘’)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])</p>
<p>echo “${currentProjectName}完成编译，构建镜像”</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>完成微服务多服务器远程发布</p>
<ol>
<li><p>配置远程部署服务器</p>
<p> 384.png)</p>
<p>拷贝公钥到远程服务器</p>
<p> 385.png) ssh-copy-id 192.168.66.104</p>
<p> 386.png)</p>
<p>系统配置-&gt;添加远程服务器</p>
<p> 387.jpg)</p>
</li>
<li><p>修改Docker配置信任Harbor私服地址</p>
<p> 388.png)</p>
<p>{</p>
<p>“registry-mirrors”: [“<a target="_blank" rel="noopener" href="https://zydiol88.mirror.aliyuncs.com"]">https://zydiol88.mirror.aliyuncs.com&quot;]</a>, “insecure-registries”: [“192.168.66.102:85”]</p>
<p>}</p>
<p>重启Docker</p>
</li>
<li><p>添加参数</p>
<p>多选框：部署服务器</p>
<p> 389.jpg)</p>
<p> 390.jpg)</p>
<p> 391.jpg)</p>
<p> 392.jpg)</p>
<p>最终效果：</p>
<p> 393.jpg)</p>
<p> 394.png)</p>
<p>&#x2F;&#x2F;gitlab的凭证</p>
<p>def git_auth &#x3D; “68f2087f-a034-4d39-a9ff-1f776dd3dfa8”</p>
<p>&#x2F;&#x2F;构建版本的名称</p>
<p>def tag &#x3D; “latest”</p>
<p>&#x2F;&#x2F;Harbor私服地址</p>
<p>def harbor_url &#x3D; “192.168.66.102:85”</p>
<p>&#x2F;&#x2F;Harbor的项目名称</p>
<p>def harbor_project_name &#x3D; “tensquare”</p>
<p>&#x2F;&#x2F;Harbor的凭证</p>
<p>def harbor_auth &#x3D; “ef499f29-f138-44dd-975e-ff1ca1d8c933”</p>
<p>node {</p>
<p>&#x2F;&#x2F;把选择的项目信息转为数组</p>
<p>def selectedProjects &#x3D; “${project_name}”.split(‘,’)</p>
<p>&#x2F;&#x2F;把选择的服务区信息转为数组</p>
<p>def selectedServers &#x3D; “${publish_server}”.split(‘,’)</p>
<p>stage(‘拉取代码’) {</p>
<p>checkout([$class: ‘GitSCM’, branches: [[name: ‘*&#x2F;${branch}’]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: ‘${git_auth}’, url: ‘<a href="mailto:&#x67;&#x69;&#x74;&#64;&#x31;&#x39;&#x32;&#x2e;&#49;&#x36;&#56;&#46;&#x36;&#54;&#46;&#49;&#48;&#48;">&#x67;&#x69;&#x74;&#64;&#x31;&#x39;&#x32;&#x2e;&#49;&#x36;&#56;&#46;&#x36;&#54;&#46;&#49;&#48;&#48;</a>:itheima_group&#x2F;tensquare_back_cluster.git’]]])</p>
<p>}</p>
</li>
<li><p>修改Jenkinsﬁle构建脚本</p>
<p>stage(‘代码审查’) {</p>
<p>def scannerHome &#x3D; tool ‘sonarqube-scanner’ withSonarQubeEnv(‘sonarqube6.7.4’) {</p>
<p>for(int i&#x3D;0;i&lt;selectedProjects.size();i++){</p>
<p>&#x2F;&#x2F;取出每个项目的名称和端口</p>
<p>def currentProject &#x3D; selectedProjects[i];</p>
<p>&#x2F;&#x2F;项目名称</p>
<p>def currentProjectName &#x3D; currentProject.split(‘@’)[0]</p>
<p>&#x2F;&#x2F;项目启动端口</p>
<p>def currentProjectPort &#x3D; currentProject.split(‘@’)[1]</p>
<p>sh “””</p>
<p>“””</p>
<p>cd ${currentProjectName}</p>
<p>${scannerHome}&#x2F;bin&#x2F;sonar-scanner</p>
<p>echo “${currentProjectName}完成代码审查”</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>stage(‘编译，构建镜像，部署服务’) {</p>
<p>&#x2F;&#x2F;编译并安装公共工程</p>
<p>sh “mvn -f tensquare_common clean install”</p>
<p>for(int i&#x3D;0;i&lt;selectedProjects.size();i++){</p>
<p>&#x2F;&#x2F;取出每个项目的名称和端口</p>
<p>def currentProject &#x3D; selectedProjects[i];</p>
<p>&#x2F;&#x2F;项目名称</p>
<p>def currentProjectName &#x3D; currentProject.split(‘@’)[0]</p>
<p>&#x2F;&#x2F;项目启动端口</p>
<p>def currentProjectPort &#x3D; currentProject.split(‘@’)[1]</p>
<p>&#x2F;&#x2F;定义镜像名称</p>
<p>def imageName &#x3D; “${currentProjectName}:${tag}”</p>
<p>&#x2F;&#x2F;编译，构建本地镜像</p>
<p>sh “mvn -f ${currentProjectName} clean package</p>
<p>dockerfile:build”</p>
<p>&#x2F;&#x2F;给镜像打标签</p>
<p>sh “docker tag ${imageName}</p>
<p>${harbor_url}&#x2F;${harbor_project_name}&#x2F;${imageName}”</p>
<p>&#x2F;&#x2F;登录Harbor，并上传镜像 withCredentials([usernamePassword(credentialsId:</p>
<p>“${harbor_auth}”, passwordVariable: ‘password’, usernameVariable: ‘username’)])</p>
<p>{</p>
<p>${harbor_url}”</p>
<p>&#x2F;&#x2F;登录</p>
<p>sh “docker login -u ${username} -p ${password}</p>
<p>&#x2F;&#x2F;上传镜像</p>
<p>sh “docker push</p>
<p>${harbor_url}&#x2F;${harbor_project_name}&#x2F;${imageName}”</p>
<p>}</p>
<p> 395.png)</p>
<p> 396.png)</p>
<p>&#x2F;&#x2F;删除本地镜像</p>
<p>sh “docker rmi -f ${imageName}” sh “docker rmi -f</p>
<p>${harbor_url}&#x2F;${harbor_project_name}&#x2F;${imageName}”</p>
<p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;以下为远程调用进行项目部署&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; for(int j&#x3D;0;j&lt;selectedServers.size();j++){</p>
<p>&#x2F;&#x2F;每个服务名称</p>
<p>def currentServer &#x3D; selectedServers[j]</p>
<p>&#x2F;&#x2F;添加微服务运行时的参数：spring.profiles.active def activeProfile &#x3D; “–spring.profiles.active&#x3D;”</p>
<p>if(currentServer&#x3D;&#x3D;”master_server”){</p>
<p>activeProfile &#x3D; activeProfile+”eureka-server1”</p>
<p>}else if(currentServer&#x3D;&#x3D;”slave_server1”){ activeProfile &#x3D; activeProfile+”eureka-server2”</p>
<p>}</p>
<p>sshPublisher(publishers: [sshPublisherDesc(configName: “${currentServer}”, transfers: [sshTransfer(cleanRemote: false, excludes: ‘’, execCommand: “&#x2F;opt&#x2F;jenkins_shell&#x2F;deployCluster.sh $harbor_url</p>
<p>$harbor_project_name $currentProjectName $tag $currentProjectPort</p>
<p>$activeProfile”, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: ‘[, ]+’, remoteDirectory: ‘’, remoteDirectorySDF: false, removePrefix: ‘’, sourceFiles: ‘’)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])</p>
<p>}</p>
<p>echo “${currentProjectName}完成编译，构建镜像”</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p> 397.png)</p>
<p>#! &#x2F;bin&#x2F;sh #接收外部参数</p>
<p>harbor_url&#x3D;$1 harbor_project_name&#x3D;$2 project_name&#x3D;$3</p>
<p>tag&#x3D;$4 port&#x3D;$5 profile&#x3D;$6</p>
<p>imageName&#x3D;$harbor_url&#x2F;$harbor_project_name&#x2F;$project_name:$tag</p>
<p>echo “$imageName”</p>
<p>#查询容器是否存在，存在则删除</p>
<p>containerId&#x3D;<code>docker ps -a | grep -w $&#123;project_name&#125;:$&#123;tag&#125; | awk &#39;&#123;print $1&#125;&#39;</code> if [ “$containerId” !&#x3D; “” ] ; then</p>
<p>#停掉容器</p>
</li>
<li><p>编写deployCluster.sh部署脚本</p>
<p> 398.png)</p>
<p>docker stop $containerId</p>
<p>#删除容器</p>
<p>docker rm $containerId</p>
<p>echo “成功删除容器”</p>
<p>fi</p>
<p>#查询镜像是否存在，存在则删除</p>
<p>imageId&#x3D;<code>docker images | grep -w $project_name | awk &#39;&#123;print $3&#125;&#39;</code></p>
<p>if [ “$imageId” !&#x3D; “” ] ; then #删除镜像</p>
<p>docker rmi -f $imageId</p>
<p>echo “成功删除镜像”</p>
<p>fi</p>
<p># 登录Harbor私服</p>
<p>docker login -u itcast -p Itcast123 $harbor_url</p>
<p># 下载镜像</p>
<p>docker pull $imageName</p>
<p># 启动容器</p>
<p>docker run -di -p $port:$port $imageName $profile</p>
<p>echo “容器启动成功”</p>
</li>
<li><p>集群效果</p>
</li>
</ol>
<h3 id="Nginx-Zuul集群实现高可用网关"><a href="#Nginx-Zuul集群实现高可用网关" class="headerlink" title="Nginx+Zuul集群实现高可用网关"></a>Nginx+Zuul<strong>集群实现高可用网关</strong></h3><p> 399.jpg)</p>
<ol>
<li>安装Nginx（已完成） 2）修改Nginx配置</li>
</ol>
<p> 400.png) vi &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</p>
<p> 401.png)</p>
<p>upstream zuulServer{</p>
<p>内容如下：</p>
<p> 402.png)</p>
<p>server 192.168.66.103:10020 weight&#x3D;1;</p>
<p>server 192.168.66.104:10020 weight&#x3D;1;</p>
<p>}</p>
<p>server {</p>
<p>listen 85 default_server;</p>
<p>listen [::]:85 default_server; server_name _;</p>
<p>root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</p>
<p># Load configuration files for the default server block. include &#x2F;etc&#x2F;nginx&#x2F;default.d&#x2F;*.conf;</p>
<p>location &#x2F; {</p>
<p>### 指定服务器负载均衡服务器</p>
<p><a target="_blank" rel="noopener" href="http://zuulserver/%3B">proxy_pass http</a><a target="_blank" rel="noopener" href="http://zuulserver/%3B">:</a><a target="_blank" rel="noopener" href="http://zuulserver/%3B">&#x2F;&#x2F;zuulServer&#x2F;;</a></p>
<p>}</p>
<p>3）重启Nginx： systemctl restart nginx 4）修改前端Nginx的访问地址</p>
<p> 403.jpg)</p>
<h2 id="6、基于Kubernetes-K8S构建Jenkins持续集成平台-上"><a href="#6、基于Kubernetes-K8S构建Jenkins持续集成平台-上" class="headerlink" title="6、基于Kubernetes&#x2F;K8S构建Jenkins持续集成平台(上)"></a>6<strong>、基于</strong>Kubernetes&#x2F;K8S<strong>构建</strong>Jenkins<strong>持续集成平台</strong>(<strong>上</strong>)</h2><h3 id="Jenkins的Master-Slave分布式构建"><a href="#Jenkins的Master-Slave分布式构建" class="headerlink" title="Jenkins的Master-Slave分布式构建"></a>Jenkins<strong>的</strong>Master-Slave<strong>分布式构建</strong></h3><p>什么是<strong>Master-Slave</strong>分布式构建</p>
<p> 404.jpg)</p>
<p>Jenkins的Master-Slave分布式构建，就是通过将构建过程分配到从属Slave节点上，从而减轻Master节点的压力，而且可以同时构建多个，有点类似负载均衡的概念。</p>
<p>如何实现<strong>Master-Slave</strong>分布式构建</p>
<ol>
<li><p>开启代理程序的TCP端口</p>
<p>Manage Jenkins -&gt; Conﬁgure Global Security</p>
<p> 405.jpg)</p>
</li>
<li><p>新建节点</p>
</li>
</ol>
<p>Manage Jenkins—Manage Nodes—新建节点</p>
<p> 406.jpg)</p>
<p> 407.jpg)</p>
<p> 408.jpg)</p>
<p>有两种在Slave节点连接Master节点的方法</p>
<p> 409.jpg)</p>
<p>我们选择第二种：</p>
<ol>
<li><p>安装和配置节点</p>
<p>下载agent.jar，并上传到Slave节点，然后执行页面提示的命令：</p>
<p> 410.png)</p>
<p>java -jar agent.jar -jnlpUrl <a target="_blank" rel="noopener" href="http://192.168.66.101:8888/computer/slave1/slave-">http://192.168.66.101:8888/computer/slave1/slave-</a> agent.jnlp -secret f2ecbb99e0c81331e8b7a7917a94d478f39cb9763fc6c66d9a9741c61f9ae6d6 -workDir “&#x2F;root&#x2F;jenkins”</p>
<p>刷新页面</p>
<p> 411.jpg)</p>
</li>
<li><p>测试节点是否可用</p>
</li>
</ol>
<p>自由风格和Maven风格的项目：</p>
<p> 412.jpg)</p>
<p> 413.png)</p>
<p>node(‘slave1’) {</p>
<p>stage(‘check out’) {</p>
<p>checkout([$class: ‘GitSCM’, branches: [[name: ‘*&#x2F;master’]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: ‘68f2087f-a034-4d39-a9ff-1f776dd3dfa8’, url: ‘<a href="mailto:&#x67;&#105;&#x74;&#64;&#49;&#57;&#50;&#x2e;&#x31;&#54;&#56;&#x2e;&#54;&#x36;&#x2e;&#x31;&#x30;&#x30;">&#x67;&#105;&#x74;&#64;&#49;&#57;&#50;&#x2e;&#x31;&#54;&#56;&#x2e;&#54;&#x36;&#x2e;&#x31;&#x30;&#x30;</a>:itheima_group&#x2F;tensquare_back_cluster.git’]]])</p>
<p>}</p>
<p>}</p>
<p>流水线风格的项目：</p>
<h3 id="Kubernetes实现Master-Slave分布式构建方案"><a href="#Kubernetes实现Master-Slave分布式构建方案" class="headerlink" title="Kubernetes实现Master-Slave分布式构建方案"></a>Kubernetes<strong>实现</strong>Master-Slave<strong>分布式构建方案</strong></h3><p>传统<strong>Jenkins</strong>的<strong>Master-Slave</strong>方案的缺陷</p>
<p> 414.png)</p>
<p>Master节点发生单点故障时，整个流程都不可用了</p>
<p> 415.png)</p>
<p>每个 Slave节点的配置环境不一样，来完成不同语言的编译打包等操作，但是这些差异化的配置导致管理起来非常不方便，维护起来也是比较费劲</p>
<p> 416.png)</p>
<p>资源分配不均衡，有的 Slave节点要运行的job出现排队等待，而有的Slave节点处于空闲状态</p>
<p> 417.png)</p>
<p>资源浪费，每台 Slave节点可能是实体机或者VM，当Slave节点处于空闲状态时，也不会完全释放掉资源</p>
<p>以上种种问题，我们可以引入Kubernates来解决！</p>
<h4 id="Kubernates简介"><a href="#Kubernates简介" class="headerlink" title="Kubernates简介"></a>Kubernates<strong>简介</strong></h4><p>Kubernetes（简称，K8S）是Google开源的容器集群管理系统，在Docker技术的基础上，为容器化的应用提供部署运行、资源调度、服务发现和动态伸缩等一系列完整功能，提高了大规模容器集群管理的便捷性。 其主要功能如下：</p>
<p> 418.png)</p>
<p>使用Docker对应用程序包装(package)、实例化(instantiate)、运行(run)。</p>
<p> 419.png)</p>
<p> 420.png)</p>
<p> 421.png)</p>
<p>以集群的方式运行、管理跨机器的容器。以集群的方式运行、管理跨机器的容器。解决Docker跨机器容器之间的通讯问题。解决Docker跨机器容器之间的通讯问题。 Kubernetes的自我修复机制使得容器集群总是运行在用户期望的状态。</p>
<h4 id="Kubernates-Docker-Jenkins持续集成架构图"><a href="#Kubernates-Docker-Jenkins持续集成架构图" class="headerlink" title="Kubernates+Docker+Jenkins持续集成架构图"></a>Kubernates+Docker+Jenkins<strong>持续集成架构图</strong></h4><p> 422.jpg)</p>
<p> 423.jpg)</p>
<p>大致工作流程：手动&#x2F;自动构建 -&gt; Jenkins 调度 K8S API -＞动态生成 Jenkins Slave pod -＞ Slave pod拉取 Git 代码／编译／打包镜像 -＞推送到镜像仓库 Harbor -＞ Slave 工作完成，Pod 自动销毁 -＞部署到测试或生产 Kubernetes平台。（完全自动化，无需人工干预）</p>
<h4 id="Kubernates-Docker-Jenkins持续集成方案好处"><a href="#Kubernates-Docker-Jenkins持续集成方案好处" class="headerlink" title="Kubernates+Docker+Jenkins持续集成方案好处"></a>Kubernates+Docker+Jenkins<strong>持续集成方案好处</strong></h4><p> 424.png)</p>
<p>服务高可用：当 Jenkins Master 出现故障时，Kubernetes 会自动创建一个新的 Jenkins Master</p>
<p>容器，并且将 Volume 分配给新创建的容器，保证数据不丢失，从而达到集群服务高可用。</p>
<p> 425.png)</p>
<p>动态伸缩，合理使用资源：每次运行 Job 时，会自动创建一个 Jenkins Slave，Job 完成后，Slave自动注销并删除容器，资源自动释放，而且 Kubernetes 会根据每个资源的使用情况，动态分配 Slave 到空闲的节点上创建，降低出现因某节点资源利用率高，还排队等待在该节点的情况。</p>
<p> 426.png)</p>
<p>扩展性好：当 Kubernetes 集群的资源严重不足而导致 Job 排队等待时，可以很容易的添加一个</p>
<p>Kubernetes Node 到集群中，从而实现扩展。</p>
<h3 id="Kubeadm安装Kubernetes"><a href="#Kubeadm安装Kubernetes" class="headerlink" title="Kubeadm安装Kubernetes"></a>Kubeadm<strong>安装</strong>Kubernetes</h3><h4 id="Kubernetes的架构"><a href="#Kubernetes的架构" class="headerlink" title="Kubernetes的架构"></a>Kubernetes<strong>的架构</strong></h4><p> 427.jpg)</p>
<p>API Server：用于暴露Kubernetes API，任何资源的请求的调用操作都是通过kube-apiserver提供的接口进行的。</p>
<p>Etcd：是Kubernetes提供默认的存储系统，保存所有集群数据，使用时需要为etcd数据提供备份计划。</p>
<p>Controller-Manager：作为集群内部的管理控制中心，负责集群内的Node、Pod副本、服务端点</p>
<p>（Endpoint）、命名空间（Namespace）、服务账号（ServiceAccount）、资源定额</p>
<p>（ResourceQuota）的管理，当某个Node意外宕机时，Controller Manager会及时发现并执行自动化修复流程，确保集群始终处于预期的工作状态。</p>
<p>Scheduler：监视新创建没有分配到Node的Pod，为Pod选择一个Node。</p>
<p>Kubelet：负责维护容器的生命周期，同时负责Volume和网络的管理</p>
<p>Kube proxy：是Kubernetes的核心组件，部署在每个Node节点上，它是实现Kubernetes Service的通信与负载均衡机制的重要组件。</p>
<p>安装环境说明</p>
<table>
<thead>
<tr>
<th>主机名称</th>
<th>IP<strong>地址</strong></th>
<th>安装的软件</th>
</tr>
</thead>
<tbody><tr>
<td>代码托管服务器</td>
<td>192.168.66.100</td>
<td>Gitlab-12.4.2</td>
</tr>
<tr>
<td>Docker仓库服务器</td>
<td>192.168.66.102</td>
<td>Harbor1.9.2</td>
</tr>
<tr>
<td>k8s-master</td>
<td>192.168.66.101</td>
<td>kube-apiserver、kube-controller-manager、kube- scheduler、docker、etcd、calico，NFS</td>
</tr>
<tr>
<td>k8s-node1</td>
<td>192.168.66.103</td>
<td>kubelet、kubeproxy、Docker18.06.1-ce</td>
</tr>
<tr>
<td>k8s-node2</td>
<td>192.168.66.104</td>
<td>kubelet、kubeproxy、Docker18.06.1-ce</td>
</tr>
</tbody></table>
<p>三台机器都需要完成</p>
<p>修改三台机器的<strong>hostname</strong>及<strong>hosts</strong>文件</p>
<p> 428.png)</p>
<p>hostnamectl set-hostname k8s-master</p>
<p>hostnamectl set-hostname k8s-node1 hostnamectl set-hostname k8s-node2</p>
<p> 429.png)</p>
<p>cat &gt;&gt;&#x2F;etc&#x2F;hosts&lt;&lt;EOF 192.168.66.101 k8s-master 192.168.66.103 k8s-node1</p>
<p>192.168.66.104 k8s-node2 EOF</p>
<p>关闭防火墙和关闭<strong>SELinux</strong></p>
<p> 430.png)</p>
<p>systemctl stop ﬁrewalld systemctl disable ﬁrewalld</p>
<p>setenforce 0 临时关闭</p>
<p>vi &#x2F;etc&#x2F;sysconﬁg&#x2F;selinux 永久关闭改为SELINUX&#x3D;disabled</p>
<p>设置系统参数</p>
<p>设置允许路由转发，不对bridge的数据进行处理创建文件</p>
<p> 431.png)</p>
<p>vi &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf</p>
<p>内容如下：</p>
<p>net.bridge.bridge-nf-call-ip6tables &#x3D; 1 net.bridge.bridge-nf-call-iptables &#x3D; 1</p>
<p>net.ipv4.ip_forward &#x3D; 1 vm.swappiness &#x3D; 0</p>
<p>执行文件</p>
<p> 432.png)</p>
<p>sysctl -p &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf</p>
<p> 433.png)</p>
<p>cat &gt; &#x2F;etc&#x2F;sysconfig&#x2F;modules&#x2F;ipvs.modules &lt;&lt;EOF #!&#x2F;bin&#x2F;bash</p>
<p>modprobe – ip_vs modprobe – ip_vs_rr modprobe – ip_vs_wrr modprobe – ip_vs_sh</p>
<p>modprobe – nf_conntrack_ipv4 EOF</p>
<p>chmod 755 &#x2F;etc&#x2F;sysconfig&#x2F;modules&#x2F;ipvs.modules &amp;&amp; bash</p>
<p>&#x2F;etc&#x2F;sysconfig&#x2F;modules&#x2F;ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4</p>
<p>kube-proxy<strong>开启</strong>ipvs<strong>的前置条件</strong></p>
<p> 434.png)</p>
<p><strong>所有节点关闭****swap</strong> swapoﬀ -a 临时关闭 vi &#x2F;etc&#x2F;fstab 永久关闭注释掉以下字段</p>
<p>&#x2F;dev&#x2F;mapper&#x2F;cl-swap swap swap defaults 0 0</p>
<p> 435.png)</p>
<p>安装<strong>kubelet</strong>、<strong>kubeadm</strong>、<strong>kubectl</strong> kubeadm: 用来初始化集群的指令。</p>
<p> 436.png)</p>
<p>kubelet: 在集群中的每个节点上用来启动 pod 和 container 等。</p>
<p> 437.png)</p>
<p>kubectl: 用来与集群通信的命令行工具。</p>
<p>清空yum缓存</p>
<p> 438.png)</p>
<p>yum clean all</p>
<p>设置yum安装源</p>
<p> 439.png)</p>
<p>cat &lt;<EOF > &#x2F;etc&#x2F;yum.repos.d&#x2F;kubernetes.repo [kubernetes]</p>
<p>name&#x3D;Kubernetes baseurl&#x3D;<a target="_blank" rel="noopener" href="https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/">https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</a> enabled&#x3D;1</p>
<p>gpgcheck&#x3D;0 repo_gpgcheck&#x3D;0</p>
<p>gpgkey&#x3D;<a target="_blank" rel="noopener" href="https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg">https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</a> <a target="_blank" rel="noopener" href="https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg">https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</a> EOF</p>
<p>安装：</p>
<p> 440.png)</p>
<p>yum install -y kubelet kubeadm kubectl</p>
<p>kubelet设置开机启动（注意：先不启动，现在启动的话会报错）</p>
<p> 441.png)</p>
<p>systemctl enable kubelet</p>
<p> 442.png)</p>
<p>kubelet –version</p>
<p>查看版本</p>
<p>安装的是最新版本：Kubernetes v1.16.3（可能会变化）</p>
<p> 443.png)</p>
<p>kubeadm init –kubernetes-version&#x3D;1.17.0 \</p>
<p>–apiserver-advertise-address&#x3D;192.168.66.101 \</p>
<p>–image-repository registry.aliyuncs.com&#x2F;google_containers \</p>
<p>–service-cidr&#x3D;10.1.0.0&#x2F;16 \</p>
<p>–pod-network-cidr&#x3D;10.244.0.0&#x2F;16</p>
<h4 id="Master节点需要完成-1）运行初始化命令"><a href="#Master节点需要完成-1）运行初始化命令" class="headerlink" title="Master节点需要完成 1）运行初始化命令"></a>Master<strong>节点需要完成</strong> 1）运行初始化命令</h4><p>注意：apiserver-advertise-address这个地址必须是master机器的IP常用错误：</p>
<p>错误一：[WARNING IsDockerSystemdCheck]: detected “cgroupfs” as the Docker cgroup driver</p>
<p>作为Docker cgroup驱动程序。，Kubernetes推荐的Docker驱动程序是“systemd”</p>
<p>解决方案：修改Docker的配置: vi &#x2F;etc&#x2F;docker&#x2F;daemon.json，加入</p>
<p> 444.png)</p>
<p>{</p>
<p>“exec-opts”:[“native.cgroupdriver&#x3D;systemd”]</p>
<p>}</p>
<p>然后重启Docker</p>
<p>错误二：[ERROR NumCPU]: the number of available CPUs 1 is less than the required 2</p>
<p>解决方案：修改虚拟机的CPU的个数，至少为2个</p>
<p> 445.jpg)</p>
<p>安装过程日志：</p>
<p> 446.jpg)</p>
<p> 447.png)</p>
<p>kubeadm join 192.168.66.101:6443 –token 754snw.9xq9cotze1ybwnti \</p>
<p>–discovery-token-ca-cert-hash sha256:3372ff6717ea5997121213e2c9d63fa7c8cdfb031527e17f2e20254f382ea03a</p>
<p>最后，会提示节点安装的命令，必须记下来</p>
<p> 448.png)</p>
<p>systemctl restart kubelet</p>
<ol>
<li><p>启动kubelet</p>
<p> 449.jpg)</p>
<p> 450.png)</p>
<p>mkdir -p $HOME&#x2F;.kube</p>
<p>sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config</p>
</li>
<li><p>配置kubectl工具</p>
</li>
<li><p>安装Calico</p>
<p> 451.png)</p>
<p>mkdir k8s cd k8s</p>
<p>wget <a target="_blank" rel="noopener" href="https://docs.projectcalico.org/v3.10/getting-">https://docs.projectcalico.org/v3.10/getting-</a> started&#x2F;kubernetes&#x2F;installation&#x2F;hosted&#x2F;kubernetes-datastore&#x2F;calico- networking&#x2F;1.7&#x2F;calico.yaml</p>
<p>sed -i ‘s&#x2F;192.168.0.0&#x2F;10.244.0.0&#x2F;g’ calico.yaml</p>
<p>kubectl apply -f calico.yaml</p>
<p> 452.png)</p>
<p>kubectl get pod –all-namespaces -o wide</p>
</li>
<li><p>等待几分钟，查看所有Pod的状态，确保所有Pod都是Running状态</p>
</li>
</ol>
<p> 453.jpg)</p>
<h4 id="Slave节点需要完成-1）让所有节点让集群环境"><a href="#Slave节点需要完成-1）让所有节点让集群环境" class="headerlink" title="Slave节点需要完成 1）让所有节点让集群环境"></a>Slave<strong>节点需要完成</strong> 1）让所有节点让集群环境</h4><p>使用之前Master节点产生的命令加入集群</p>
<p> 454.png)</p>
<p>kubeadm join 192.168.66.101:6443 –token 754snw.9xq9cotze1ybwnti \</p>
<p>–discovery-token-ca-cert-hash sha256:3372ff6717ea5997121213e2c9d63fa7c8cdfb031527e17f2e20254f382ea03a</p>
<p> 455.png)</p>
<p>systemctl start kubelet</p>
<ol>
<li><p>启动kubelet</p>
<p> 456.jpg)</p>
<p> 457.png)</p>
<p>kubectl get nodes</p>
</li>
<li><p>回到Master节点查看，如果Status全部为Ready，代表集群环境搭建成功！！！</p>
</li>
</ol>
<p> 458.jpg)</p>
<p> 459.png)</p>
<p>kubectl get nodes 查看所有主从节点的状态</p>
<p>kubectl get ns 获取所有namespace资源</p>
<p>kubectl get pods -n {$nameSpace} 获取指定namespace的pod</p>
<p>kubectl describe pod的名称 -n {$nameSpace} 查看某个pod的执行过程</p>
<p>kubectl logs –tail&#x3D;1000 pod的名称 | less 查看日志 kubectl create -f xxx.yml 通过配置文件创建一个集群资源对象 kubectl delete -f xxx.yml 通过配置文件删除一个集群资源对象</p>
<p>kubectl delete pod名称 -n {$nameSpace} 通过pod删除集群资源</p>
<p>kubectl get service -n {$nameSpace} 查看pod的service情况</p>
<h4 id="kubectl常用命令"><a href="#kubectl常用命令" class="headerlink" title="kubectl常用命令"></a>kubectl<strong>常用命令</strong></h4><h2 id="7、基于Kubernetes-K8S构建Jenkins持续集成平台-下"><a href="#7、基于Kubernetes-K8S构建Jenkins持续集成平台-下" class="headerlink" title="7、基于Kubernetes&#x2F;K8S构建Jenkins持续集成平台(下)"></a>7<strong>、基于</strong>Kubernetes&#x2F;K8S<strong>构建</strong>Jenkins<strong>持续集成平台</strong>(<strong>下</strong>)</h2><p>Jenkins-Master-Slave架构图回顾：</p>
<p> 460.jpg)</p>
<p>安装和配置<strong>NFS</strong></p>
<h4 id="NFS简介"><a href="#NFS简介" class="headerlink" title="NFS简介"></a>NFS<strong>简介</strong></h4><p>NFS（Network File System），它最大的功能就是可以通过网络，让不同的机器、不同的操作系统可以共享彼此的文件。我们可以利用NFS共享Jenkins运行的配置文件、Maven的仓库依赖文件等</p>
<h4 id="NFS安装"><a href="#NFS安装" class="headerlink" title="NFS安装"></a>NFS<strong>安装</strong></h4><p>我们把NFS服务器安装在192.168.66.101机器上</p>
<ol>
<li><p>安装NFS服务（在所有K8S的节点都需要安装）</p>
<p> 461.png)</p>
<p>yum install -y nfs-utils</p>
</li>
<li><p>创建共享目录</p>
<table>
<thead>
<tr>
<th>mkdir -p &#x2F;opt&#x2F;nfs&#x2F;jenkins</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>vi &#x2F;etc&#x2F;exports</td>
<td>编写NFS的共享配置</td>
<td></td>
</tr>
<tr>
<td>内容如下:</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&#x2F;opt&#x2F;nfs&#x2F;jenkins</td>
<td>*(rw,no_root_squash)</td>
<td>*代表对所有IP都开放此目录，rw是读写</td>
</tr>
</tbody></table>
<p> 462.png)</p>
<p>systemctl enable nfs 开机启动</p>
<p>systemctl start nfs 启动</p>
</li>
<li><p>启动服务</p>
<p> 463.png)</p>
<p>showmount -e 192.168.66.101</p>
</li>
<li><p>查看NFS共享目录</p>
</li>
</ol>
<p>在<strong>Kubernetes</strong>安装<strong>Jenkins-Master</strong></p>
<p>创建<strong>NFS client provisioner</strong></p>
<p>nfs-client-provisioner 是一个Kubernetes的简易NFS的外部provisioner，本身不提供NFS，需要现有的NFS服务器提供存储。</p>
<ol>
<li><p>上传nfs-client-provisioner构建文件</p>
<p> 464.jpg)</p>
<p>其中注意修改deployment.yaml，使用之前配置NFS服务器和目录</p>
<p> 465.jpg)</p>
</li>
<li><p>构建nfs-client-provisioner的pod资源</p>
<p> 466.png)</p>
<p>cd nfs-client kubectl create -f .</p>
</li>
<li><p>查看pod是否创建成功</p>
</li>
</ol>
<p> 467.jpg)</p>
<p><strong>安装****Jenkins-Master</strong> 1）上传Jenkins-Master构建文件</p>
<p> 468.jpg)</p>
<p>其中有两点注意：</p>
<p>第一、在StatefulSet.yaml文件，声明了利用nfs-client-provisioner进行Jenkins-Master文件存储</p>
<p> 469.jpg)</p>
<p>第二、Service发布方法采用NodePort，会随机产生节点访问端口</p>
<p> 470.jpg)</p>
<ol>
<li><p>创建kube-ops的namespace</p>
<p> 471.png)</p>
<p>kubectl create namespace kube-ops</p>
<p>因为我们把Jenkins-Master的pod放到kube-ops下</p>
<p> 472.png)</p>
<p>cd jenkins-master kubectl create -f .</p>
</li>
<li><p>构建Jenkins-Master的pod资源</p>
<p> 473.png)</p>
<p>kubectl get pods -n kube-ops</p>
</li>
<li><p>查看pod是否创建成功</p>
</li>
<li><p>查看信息，并访问</p>
<p> 474.png)</p>
<p>kubectl describe pods -n kube-ops</p>
<p>查看Pod运行在那个Node上</p>
<p> 475.jpg)</p>
<p> 476.png)</p>
<p>kubectl get service -n kube-ops</p>
<p>查看分配的端口</p>
<p> 477.jpg)</p>
<p>最终访问地址为：<a target="_blank" rel="noopener" href="http://192.168.66.103:30136/">http://192.168.66.103:30136</a> （192.168.66.103为k8s-node1的IP）</p>
<p> 478.jpg)</p>
<p>安装过程跟之前是一样的！</p>
</li>
<li><p>先安装基本的插件</p>
</li>
</ol>
<p> 479.png)</p>
<p> 480.png)</p>
<p>Localization:Chinese Git</p>
<p> 481.png)</p>
<p>Pipeline</p>
<p> 482.png)</p>
<p>Extended Choice Parameter</p>
<h3 id="Jenkins与Kubernetes整合"><a href="#Jenkins与Kubernetes整合" class="headerlink" title="Jenkins与Kubernetes整合"></a>Jenkins<strong>与</strong>Kubernetes<strong>整合</strong></h3><p>安装<strong>Kubernetes</strong>插件</p>
<p>系统管理-&gt;插件管理-&gt;可选插件</p>
<p> 483.jpg)</p>
<p>实现<strong>Jenkins</strong>与<strong>Kubernetes</strong>整合</p>
<p>系统管理-&gt;系统配置-&gt;云-&gt;新建云-&gt;Kubernetes</p>
<p> 484.jpg)</p>
<p> 485.png)</p>
<p> 486.png)</p>
<p>kubernetes地址采用了kube<a target="_blank" rel="noopener" href="https://kubernetes.default.svc.cluster.local/">的服务器发现：</a><a target="_blank" rel="noopener" href="https://kubernetes.default.svc.cluster.local/">https://kubernetes.default.svc.cluster.local</a> namespace填kube-ops，然后点击Test Connection，如果出现 Connection test successful 的提示信息证明 Jenkins 已经可以和 Kubernetes 系统正常通信</p>
<p> 487.png)</p>
<p>Jenkins URL 地址：<a target="_blank" rel="noopener" href="http://jenkins.kube-ops.svc.cluster.local:8080/">http://jenkins.kube-ops.svc.cluster.local:8080</a></p>
<p>构建<strong>Jenkins-Slave</strong>自定义镜像</p>
<p>Jenkins-Master在构建Job的时候，Kubernetes会创建Jenkins-Slave的Pod来完成Job的构建。我们选择运行Jenkins-Slave的镜像为官方推荐镜像：jenkins&#x2F;jnlp-slave:latest，但是这个镜像里面并没有Maven环境，为了方便使用，我们需要自定义一个新的镜像：</p>
<p>准备材料：</p>
<p> 488.jpg)</p>
<p> 489.png)</p>
<p>FROM jenkins&#x2F;jnlp-slave:latest</p>
<p>MAINTAINER itcast</p>
<p># 切换到 root 账户进行操作</p>
<p>USER root</p>
<p># 安装 maven</p>
<p>COPY apache-maven-3.6.2-bin.tar.gz .</p>
<p>RUN tar -zxf apache-maven-3.6.2-bin.tar.gz &amp;&amp; \ mv apache-maven-3.6.2 &#x2F;usr&#x2F;local &amp;&amp; \</p>
<p>rm -f apache-maven-3.6.2-bin.tar.gz &amp;&amp; \</p>
<p>ln -s &#x2F;usr&#x2F;local&#x2F;apache-maven-3.6.2&#x2F;bin&#x2F;mvn &#x2F;usr&#x2F;bin&#x2F;mvn &amp;&amp; \</p>
<p>Dockerﬁle文件内容如下：</p>
<p> 490.png)</p>
<p>ln -s &#x2F;usr&#x2F;local&#x2F;apache-maven-3.6.2 &#x2F;usr&#x2F;local&#x2F;apache-maven &amp;&amp; \ mkdir -p &#x2F;usr&#x2F;local&#x2F;apache-maven&#x2F;repo</p>
<p>COPY settings.xml &#x2F;usr&#x2F;local&#x2F;apache-maven&#x2F;conf&#x2F;settings.xml</p>
<p>USER jenkins</p>
<p> 491.png)</p>
<p>docker tag jenkins-slave-maven:latest 192.168.66.102:85&#x2F;library&#x2F;jenkins-slave- maven:latest</p>
<p>docker push 192.168.66.102:85&#x2F;library&#x2F;jenkins-slave-maven:latest</p>
<p>构建出一个新镜像：jenkins-slave-maven:latest然把镜像上传到Harbor的公共库library中</p>
<p>测试<strong>Jenkins-Slave</strong>是否可以创建</p>
<ol>
<li><p>创建一个Jenkins流水线项目</p>
<p> 492.jpg)</p>
<p> 493.png)</p>
<p>def git_address &#x3D; “<a target="_blank" rel="noopener" href="http://192.168.66.100:82/itheima_group/tensquare_back_cluster.git">http://192.168.66.100:82/itheima_group/tensquare_back_cluster.git</a>“ def git_auth &#x3D; “9d9a2707-eab7-4dc9-b106-e52f329cbc95”</p>
<p>&#x2F;&#x2F;创建一个Pod的模板，label为jenkins-slave</p>
<p>podTemplate(label: ‘jenkins-slave’, cloud: ‘kubernetes’, containers: [ containerTemplate(</p>
<p>name: ‘jnlp’,</p>
<p>image: “192.168.66.102:85&#x2F;library&#x2F;jenkins-slave-maven:latest”</p>
<p>)</p>
<p>]</p>
<p>)</p>
<p>{</p>
<p>&#x2F;&#x2F;引用jenkins-slave的pod模块来构建Jenkins-Slave的pod node(“jenkins-slave”){</p>
<p>&#x2F;&#x2F; 第一步</p>
<p>stage(‘拉取代码’){</p>
<p>checkout([$class: ‘GitSCM’, branches: [[name: ‘master’]], userRemoteConfigs: [[credentialsId: “${git_auth}”, url: “${git_address}”]]])</p>
<p>}</p>
<p>}</p>
</li>
<li><p>编写Pipeline，从GItlab拉取代码</p>
<p> 494.png)</p>
<p>}</p>
</li>
<li><p>查看构建日志</p>
</li>
</ol>
<p> 495.jpg)</p>
<h3 id="Jenkins-Kubernetes-Docker完成微服务持续集成"><a href="#Jenkins-Kubernetes-Docker完成微服务持续集成" class="headerlink" title="Jenkins+Kubernetes+Docker完成微服务持续集成"></a>Jenkins+Kubernetes+Docker<strong>完成微服务持续集成</strong></h3><p>拉取代码，构建镜像</p>
<ol>
<li><p>创建NFS共享目录</p>
<p> 496.png)</p>
<p>vi &#x2F;etc&#x2F;exports</p>
<p>添加内容：</p>
<p>&#x2F;opt&#x2F;nfs&#x2F;jenkins</p>
<p>&#x2F;opt&#x2F;nfs&#x2F;maven</p>
<p>*(rw,no_root_squash)</p>
<p>*(rw,no_root_squash)</p>
<p>systemctl restart nfs 重启NFS</p>
<p>让所有Jenkins-Slave构建指向NFS的Maven的共享仓库目录</p>
</li>
<li><p>创建项目，编写构建Pipeline</p>
</li>
</ol>
<p> 497.png)</p>
<p>def git_address &#x3D; “<a target="_blank" rel="noopener" href="http://192.168.66.100:82/itheima_group/tensquare_back_cluster.git">http://192.168.66.100:82/itheima_group/tensquare_back_cluster.git</a>“ def git_auth &#x3D; “9d9a2707-eab7-4dc9-b106-e52f329cbc95”</p>
<p>&#x2F;&#x2F;构建版本的名称</p>
<p>def tag &#x3D; “latest”</p>
<p>&#x2F;&#x2F;Harbor私服地址</p>
<p>def harbor_url &#x3D; “192.168.66.102:85”</p>
<p>&#x2F;&#x2F;Harbor的项目名称</p>
<p>def harbor_project_name &#x3D; “tensquare”</p>
<p>&#x2F;&#x2F;Harbor的凭证</p>
<p>def harbor_auth &#x3D; “71eff071-ec17-4219-bae1-5d0093e3d060”</p>
<p>podTemplate(label: ‘jenkins-slave’, cloud: ‘kubernetes’, containers: [ containerTemplate(</p>
<p>name: ‘jnlp’,</p>
<p>image: “192.168.66.102:85&#x2F;library&#x2F;jenkins-slave-maven:latest”</p>
<p>),</p>
<p>containerTemplate( name: ‘docker’,</p>
<p>image: “docker:stable”, ttyEnabled: true, command: ‘cat’</p>
<p>),</p>
<p>],</p>
<p>volumes: [</p>
<p>hostPathVolume(mountPath: ‘&#x2F;var&#x2F;run&#x2F;docker.sock’, hostPath: ‘&#x2F;var&#x2F;run&#x2F;docker.sock’),</p>
<p>nfsVolume(mountPath: ‘&#x2F;usr&#x2F;local&#x2F;apache-maven&#x2F;repo’, serverAddress: ‘192.168.66.101’ , serverPath: ‘&#x2F;opt&#x2F;nfs&#x2F;maven’),</p>
<p>],</p>
<p>)</p>
<p>{</p>
<p>node(“jenkins-slave”){</p>
<p>&#x2F;&#x2F; 第一步</p>
<p>stage(‘拉取代码’){</p>
<p>checkout([$class: ‘GitSCM’, branches: [[name: ‘${branch}’]],</p>
<p>userRemoteConfigs: [[credentialsId: “${git_auth}”, url: “${git_address}”]]])</p>
<p>}</p>
<p>&#x2F;&#x2F; 第二步</p>
<p>stage(‘代码编译’){</p>
<p>&#x2F;&#x2F;编译并安装公共工程</p>
<p>sh “mvn -f tensquare_common clean install”</p>
<p>}</p>
<p>&#x2F;&#x2F; 第三步</p>
<p>stage(‘构建镜像，部署项目’){</p>
<p>&#x2F;&#x2F;把选择的项目信息转为数组</p>
<p>def selectedProjects &#x3D; “${project_name}”.split(‘,’)</p>
<p>for(int i&#x3D;0;i&lt;selectedProjects.size();i++){</p>
<p>&#x2F;&#x2F;取出每个项目的名称和端口</p>
<p>def currentProject &#x3D; selectedProjects[i];</p>
<p>&#x2F;&#x2F;项目名称</p>
<p>def currentProjectName &#x3D; currentProject.split(‘@’)[0]</p>
<p>&#x2F;&#x2F;项目启动端口</p>
<p>def currentProjectPort &#x3D; currentProject.split(‘@’)[1]</p>
<p>&#x2F;&#x2F;定义镜像名称</p>
<p> 498.png)</p>
<p> 499.png)</p>
<p>def imageName &#x3D; “${currentProjectName}:${tag}”</p>
<p>&#x2F;&#x2F;编译，构建本地镜像</p>
<p>sh “mvn -f ${currentProjectName} clean package dockerfile:build”</p>
<p>container(‘docker’) {</p>
<p>&#x2F;&#x2F;给镜像打标签</p>
<p>sh “docker tag ${imageName}</p>
<p>${harbor_url}&#x2F;${harbor_project_name}&#x2F;${imageName}”</p>
<p>&#x2F;&#x2F;登录Harbor，并上传镜像 withCredentials([usernamePassword(credentialsId:</p>
<p>“${harbor_auth}”, passwordVariable: ‘password’, usernameVariable: ‘username’)])</p>
<p>{</p>
<p>&#x2F;&#x2F;登录</p>
<p>sh “docker login -u ${username} -p ${password}</p>
<p>${harbor_url}”</p>
<p>&#x2F;&#x2F;上传镜像</p>
<p>sh “docker push</p>
<p>${harbor_url}&#x2F;${harbor_project_name}&#x2F;${imageName}”</p>
<p>}</p>
<p>&#x2F;&#x2F;删除本地镜像</p>
<p>sh “docker rmi -f ${imageName}” sh “docker rmi -f</p>
<p>${harbor_url}&#x2F;${harbor_project_name}&#x2F;${imageName}”</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p> 500.png)</p>
<p>chown -R jenkins:jenkins &#x2F;opt&#x2F;nfs&#x2F;maven chmod -R 777 &#x2F;opt&#x2F;nfs&#x2F;maven</p>
<p>注意：在构建过程会发现无法创建仓库目录，是因为NFS共享目录权限不足，需更改权限</p>
<p>还有Docker命令执行权限问题</p>
<p> 501.png)</p>
<p>chmod 777 &#x2F;var&#x2F;run&#x2F;docker.sock</p>
<p>需要手动上传父工程依赖到NFS的Maven共享仓库目录中</p>
<p> 502.jpg)</p>
<p>微服务部署到<strong>K8S</strong></p>
<p> 503.png)</p>
<p>server:</p>
<p>port: ${PORT:10086}</p>
<p>spring: application:</p>
<p>name: eureka</p>
<p>eureka: server:</p>
<p># 续期时间，即扫描失效服务的间隔时间（缺省为60*1000ms）</p>
<p>eviction-interval-timer-in-ms: 5000 enable-self-preservation: false use-read-only-response-cache: false</p>
<p>client:</p>
<p># eureka client间隔多久去拉取服务注册信息 默认30s registry-fetch-interval-seconds: 5 serviceUrl:</p>
<p>defaultZone: ${EUREKA_SERVER:<a href="http://127.0.0.1:${server.port}/eureka/}">http://127.0.0.1:${server.port}/eureka/}</a> instance:</p>
<p># 心跳间隔时间，即发送一次心跳之后，多久在发起下一次（缺省为30s）</p>
<p>lease-renewal-interval-in-seconds: 5</p>
<p># 在收到一次心跳之后，等待下一次心跳的空档时间，大于心跳间隔即可，即服务续约到期时间（缺省为90s）</p>
<p>lease-expiration-duration-in-seconds: 10 instance-id:</p>
<p>${EUREKA_INSTANCE_HOSTNAME:${spring.application.name}}:${server.port}@${random.l ong(1000000,9999999)}</p>
<p>hostname: ${EUREKA_INSTANCE_HOSTNAME:${spring.application.name}}</p>
<p>修改每个微服务的application.yml Eureka</p>
<p> 504.png)</p>
<p># Eureka配置 eureka:</p>
<p>client: serviceUrl:</p>
<p>defaultZone: <a href="http://eureka-0.eureka:[10086/eureka/](http://eureka-/),http[:](http://eureka-/)//eureka-">http://eureka-0.eureka:[10086/eureka/](http://eureka-/),http[:](http://eureka-/)//eureka-</a> 1.eureka:10086&#x2F;eureka&#x2F; # Eureka访问地址</p>
<p>instance: preferIpAddress: true</p>
<p>其他微服务需要注册到所有Eureka中</p>
<ol>
<li><p>安装Kubernetes Continuous Deploy插件</p>
<p> 505.jpg)</p>
</li>
<li><p>修改后的流水线脚本</p>
<p> 506.png)</p>
<p>def deploy_image_name &#x3D; “${harbor_url}&#x2F;${harbor_project_name}&#x2F;${imageName}”</p>
<p>&#x2F;&#x2F;部署到K8S sh “””</p>
<p>sed -i ‘s#$IMAGE_NAME#${deploy_image_name}#’</p>
<p>${currentProjectName}&#x2F;deploy.yml</p>
<p>sed -i ‘s#$SECRET_NAME#${secret_name}#’</p>
<p>${currentProjectName}&#x2F;deploy.yml</p>
<p>“””</p>
<p>kubernetesDeploy configs: “${currentProjectName}&#x2F;deploy.yml”, kubeconfigId: “${k8s_auth}”</p>
</li>
<li><p>建立k8s认证凭证</p>
</li>
</ol>
<p> 507.jpg)</p>
<p> 508.png)</p>
<p>cat &#x2F;root&#x2F;.kube&#x2F;config</p>
<p>kubeconﬁg到k8s的Master节点复制</p>
<ol>
<li><p>生成Docker凭证</p>
<p> 509.png)</p>
<p>docker login -u itcast -p Itcast123 192.168.66.102:85 登录Harbor</p>
<p>kubectl create secret docker-registry registry-auth-secret –docker- server&#x3D;192.168.66.102:85 –docker-username&#x3D;itcast –docker-password&#x3D;Itcast123 <a href="mailto:docker-email=itcast@itcast.cn">– docker-email</a><a href="mailto:docker-email=itcast@itcast.cn">&#x3D;</a><a href="mailto:&#x69;&#x74;&#99;&#97;&#115;&#x74;&#x40;&#105;&#x74;&#99;&#x61;&#115;&#x74;&#46;&#99;&#110;">&#x69;&#x74;&#99;&#97;&#115;&#x74;&#x40;&#105;&#x74;&#99;&#x61;&#115;&#x74;&#46;&#99;&#110;</a> 生成</p>
<p>kubectl get secret 查看密钥</p>
<p>Docker凭证，用于Kubernetes到Docker私服拉取镜像</p>
</li>
<li><p>在每个项目下建立deploy.xml Eureka的deply.yml</p>
<p> 510.png)</p>
<p> 511.png)</p>
<p>-–</p>
<p>apiVersion: v1 kind: Service metadata:</p>
<p>name: eureka labels:</p>
<p>app: eureka spec:</p>
<p>type: NodePort ports:</p>
<p>- port: 10086 name: eureka targetPort: 10086</p>
<p>selector: app: eureka</p>
<p>-–</p>
<p>apiVersion: apps&#x2F;v1 kind: StatefulSet metadata:</p>
<p>name: eureka spec:</p>
<p>serviceName: “eureka” replicas: 2</p>
<p>selector: matchLabels:</p>
<p>app: eureka template:</p>
<p>metadata: labels:</p>
<p>app: eureka spec:</p>
<p>imagePullSecrets:</p>
<ul>
<li><p>name: $SECRET_NAME containers:</p>
</li>
<li><p>name: eureka image: $IMAGE_NAME ports:</p>
<ul>
<li><p>containerPort: 10086 env:</p>
</li>
<li><p>name: MY_POD_NAME valueFrom:</p>
<p>fieldRef:</p>
<p>fieldPath: metadata.name</p>
</li>
<li><p>name: EUREKA_SERVER</p>
<p>value: <a target="_blank" rel="noopener" href="http://eureka-/">“http://eureka-0.eureka:10086/eureka/,</a><a target="_blank" rel="noopener" href="http://eureka-/">http://eureka-</a> 1.eureka:10086&#x2F;eureka&#x2F;“</p>
</li>
<li><p>name: EUREKA_INSTANCE_HOSTNAME</p>
</li>
</ul>
</li>
</ul>
<p>value: ${MY_POD_NAME}.eureka podManagementPolicy: “Parallel”</p>
<p> 512.png)</p>
<p>-–</p>
<p>apiVersion: v1 kind: Service metadata:</p>
<p>其他项目的deploy.yml主要把名字和端口修改：</p>
<p> 513.png)</p>
<p>name: zuul labels:</p>
<p>app: zuul spec:</p>
<p>type: NodePort ports:</p>
<p>- port: 10020 name: zuul targetPort: 10020</p>
<p>selector: app: zuul</p>
<p>-–</p>
<p>apiVersion: apps&#x2F;v1 kind: StatefulSet metadata:</p>
<p>name: zuul spec:</p>
<p>serviceName: “zuul” replicas: 2 selector:</p>
<p>matchLabels: app: zuul</p>
<p>template: metadata:</p>
<p>labels: app: zuul</p>
<p>spec:</p>
<p>imagePullSecrets:</p>
<ul>
<li>name: $SECRET_NAME containers:</li>
<li>name: zuul</li>
</ul>
<p>image: $IMAGE_NAME ports:</p>
<p>- containerPort: 10020 podManagementPolicy: “Parallel”</p>
<p> 514.png)</p>
<p>kubectl get pods -owide kubectl get service</p>
</li>
<li><p>项目构建后，查看服务创建情况</p>
</li>
</ol>
<p>效果如下：</p>
<p> 515.jpg)</p>
<p> 516.jpg)</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/" class="category-chain-item">持续集成</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Jenkins/" class="print-no-link">#Jenkins</a>
      
        <a href="/tags/CICD-Docker-k8s-SpringCloud/" class="print-no-link">#CICD - Docker - k8s - SpringCloud</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Jenkins持续集成入门到精通</div>
      <div>http://coderdream.github.io/2024/01/31/jenkins-cicd/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>CoderDream</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年1月31日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/01/31/hub-docker/" title="DockerHub相关">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">DockerHub相关</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/01/31/nvm-nodejs/" title="安装nvm，并使用nvm安装nodejs及配置环境变量">
                        <span class="hidden-mobile">安装nvm，并使用nvm安装nodejs及配置环境变量</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
