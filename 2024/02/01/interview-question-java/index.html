

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/babyking_v4_128_128.png">
  <link rel="icon" href="/img/babyking_v4_128_128.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="CoderDream">
  <meta name="keywords" content="">
  
    <meta name="description" content="Java 基础什么是字节码？采用字节码的最大好处是什么字节码：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。 采用字节码的好处： Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Ja">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试题">
<meta property="og:url" content="http://coderdream.github.io/2024/02/01/interview-question-java/index.html">
<meta property="og:site_name" content="CoderDream Studio">
<meta property="og:description" content="Java 基础什么是字节码？采用字节码的最大好处是什么字节码：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。 采用字节码的好处： Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Ja">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://coderdream.github.io/images/interview-question_index_img.png">
<meta property="article:published_time" content="2024-02-01T08:31:03.000Z">
<meta property="article:modified_time" content="2024-02-01T08:30:39.000Z">
<meta property="article:author" content="CoderDream">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="多线程 - JVM - Spring - SpringCloud">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://coderdream.github.io/images/interview-question_index_img.png">
  
  
  
  <title>Java面试题 - CoderDream Studio</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"coderdream.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>CoderDream</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java面试题"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-02-01 16:31" pubdate>
          2024年2月1日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          95k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          795 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Java面试题</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><h2 id="什么是字节码？采用字节码的最大好处是什么"><a href="#什么是字节码？采用字节码的最大好处是什么" class="headerlink" title="什么是字节码？采用字节码的最大好处是什么"></a>什么是字节码？采用字节码的最大好处是什么</h2><p>字节码：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
<p>采用字节码的好处：</p>
<p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>
<p>先看下java中的编译器和解释器：</p>
<p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。</p>
<p>Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。<br>⑧.<br>————————————————<br>版权声明：本文为CSDN博主「Java程序员-张凯」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41701956/article/details/110119625">https://blog.csdn.net/qq_41701956/article/details/110119625</a></p>
<h3 id="15-Java-中-IO-流分为几种？"><a href="#15-Java-中-IO-流分为几种？" class="headerlink" title="15. Java 中 IO 流分为几种？"></a>15. Java 中 IO 流分为几种？</h3><p>按功能来分：输入流（input）、输出流（output）。</p>
<p>按类型来分：字节流和字符流。</p>
<p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p>
<h3 id="16-BIO、NIO、AIO-有什么区别？"><a href="#16-BIO、NIO、AIO-有什么区别？" class="headerlink" title="16. BIO、NIO、AIO 有什么区别？"></a>16. BIO、NIO、AIO 有什么区别？</h3><ul>
<li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li>
<li>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li>
<li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li>
</ul>
<h2 id="面试总结之-JDK1-8新特性"><a href="#面试总结之-JDK1-8新特性" class="headerlink" title="面试总结之[JDK1.8新特性]"></a>面试总结之[JDK1.8新特性]</h2><p>分类专栏： 基础篇 文章标签： 面试 JDK8 新特性 java HashMap<br>版权<br>这几天面试中,问到JDK的基本都会问到有关JDK1.8的新特性,基于这点,自己简单总结了下;<br>看到网上有个人总结了这样一句话,感觉比较通俗易懂;</p>
<ul>
<li><p>速度更快 – 红黑树</p>
</li>
<li><p>代码更少 – Lambda</p>
</li>
<li><p>强大的Stream API – Stream</p>
</li>
<li><p>便于并行 – Parallel</p>
</li>
<li><p>最大化减少空指针异常 – Optional</p>
</li>
</ul>
<h3 id="1、HashMap"><a href="#1、HashMap" class="headerlink" title="1、HashMap"></a>1、HashMap</h3><p>有人会在问你HashMap的时候会问你JDK1.7和1.8有什么变化;<br>主要还是HashMap中链长度大于8时采取红黑树的结构存储。(1.7的时候是链表结构)<br>红黑树，除了添加，效率高于链表结构。</p>
<h3 id="2、ConcurrentHashMap-阻塞-zu-se"><a href="#2、ConcurrentHashMap-阻塞-zu-se" class="headerlink" title="2、ConcurrentHashMap  阻塞[zǔ sè]"></a>2、ConcurrentHashMap  阻塞[zǔ sè]</h3><p>Jdk1.7时隔壁级别ConcurrentLevel（锁分段机制）默认为16。</p>
<p>JDK1.8采取了CAS算法<br>CAS原理主要涉及的有锁机制、CAS 操作;具体可以参考CAS原理分析</p>
<p>Jdk1.8没有永久区，取而代之的是MetaSpace元空间，用的是物理内存。<br>(当你跟面试官聊到JVM的时候可以聊到1.8后用就去是被取代了,这回事一个加分项)</p>
<h3 id="3、Lambda表达式"><a href="#3、Lambda表达式" class="headerlink" title="3、Lambda表达式"></a>3、Lambda表达式</h3><p>1、Lambda表达式的基础语法：Java8引入了一个新的操作符“-&gt;”，该操作符成为箭头操作符或者Lambda操作符，箭头操作符将Lambda表达式拆分成两部分</p>
<p>左侧：Lambda表达式的参数列表<br>右侧：Lambda表达式中所需执行的功能，即Lambda体。</p>
<p>语法格式一：无参数，无返回值</p>
<p>Runnable r2 &#x3D; () -&gt; System.out.println(“hello lambda”);<br>        r2.run();</p>
<p>语法格式二：有一个参数，并且无返回值</p>
<p>(x) -&gt; System.out.print(x);<br>1<br>语法格式三：若只有一个参数，小括号可以省略不写</p>
<p>x -&gt; System.out.print(x);<br>1<br>语法格式四：有两个以上的参数，有返回值，并且Lambda体中有多条语句</p>
<pre><code class="hljs">    Comparator&lt;Integer&gt; c1 = (x, y) -&gt; &#123;
        System.out.print(Integer.compare(x, y)+&quot;函数式接口&quot;);
        return Integer.compare(x, y);
    &#125;  ;
    c1.compare(1, 2);
</code></pre>
<p>语法格式五：若Lambda体中只有一条语句，return和大括号都可以省略不写</p>
<p>Comparator c1 &#x3D; (x,y) -&gt; Integer.compare(x,y);</p>
<p>语法格式六：Lambda表达式的参数列表的数据类型可以省略不写，因为JVM编译器可以通过上下文进行类型推断出数据类型，既“类型推断”。(Integer x,Integer y) -&gt; Integre.compare(x,y);<br>结论：<br>左右遇一括号省，左侧推断类型省， 能省则省。</p>
<h3 id="4、并行流"><a href="#4、并行流" class="headerlink" title="4、并行流"></a>4、并行流</h3><p>Fork&#x2F;Join框架：<br>在必要的情况下，将一个大任务进行必要的拆分Fork成若干个小任务，再将小任务的运算结果进行Join汇总。</p>
<p>Fork&#x2F;Join框架和传统线程池的区别：<br>采用“工作窃取”模式（Working-stealing），即当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。</p>
<p>相对于一般的线程池实现，fork&#x2F;join框架的优势体现在对其中包含的任务的处理方式上，如果一个线程正在执行的任务由于某些原因无法继续运行，那么该线程会处于等待状态，而在fork&#x2F;join框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行，那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行，这种方式减少了线程等待的时间，提高了性能。</p>
<p>并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。<br>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与sequential() 在并行流与顺序流之间进行切换。</p>
<h3 id="5、Optional-类"><a href="#5、Optional-类" class="headerlink" title="5、Optional 类"></a>5、Optional 类</h3><p>Optional 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在Optional 可以更好的表达这个概念。并且可以避免空指针异常。</p>
<p>常用方法：</p>
<ul>
<li>Optional.of(T t) : 创建一个Optional 实例</li>
<li>Optional.empty() : 创建一个空的Optional 实例</li>
<li>Optional.ofNullable(T t):若t 不为null,创建Optional 实例,否则创建空实例</li>
<li>isPresent() : 判断是否包含值</li>
<li>orElse(T t) : 如果调用对象包含值，返回该值，否则返回t</li>
<li>orElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回s 获取的值</li>
<li>map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回Optional.empty()</li>
<li>flatMap(Function mapper):与map 类似，要求返回值必须是Optional<br>————————————————<br>版权声明：本文为CSDN博主「有糖哥」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/hequan199411/article/details/81713827">https://blog.csdn.net/hequan199411/article/details/81713827</a></li>
</ul>
<h2 id="十九、JVM"><a href="#十九、JVM" class="headerlink" title="十九、JVM"></a>十九、JVM</h2><h3 id="194-说一下-JVM-的主要组成部分及其作用？"><a href="#194-说一下-JVM-的主要组成部分及其作用？" class="headerlink" title="194. 说一下 JVM 的主要组成部分及其作用？"></a>194. 说一下 JVM 的主要组成部分及其作用？</h3><ul>
<li>类加载器（ClassLoader）</li>
<li>运行时数据区（Runtime Data Area）</li>
<li>执行引擎（Execution Engine）</li>
<li>本地库接口（Native Interface）</li>
</ul>
<p>组件的作用： </p>
<ul>
<li>首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，</li>
<li>运行时数据区（Runtime Data Area）再把字节码加载到内存中，</li>
<li>而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），</li>
<li>将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</li>
</ul>
<h3 id="说一下-JVM运行时数据区？"><a href="#说一下-JVM运行时数据区？" class="headerlink" title="说一下 JVM运行时数据区？"></a>说一下 JVM运行时数据区？</h3><ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>堆</li>
<li>方法区</li>
</ul>
<p>有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户进程的启动和结束而创建和销毁。</p>
 <img src="/2024/02/01/interview-question-java/640-17067762970382.webp" srcset="/img/loading.gif" lazyload class="" title="图片">

<h3 id="196-说一下堆栈的区别？"><a href="#196-说一下堆栈的区别？" class="headerlink" title="196. 说一下堆栈的区别？"></a>196. 说一下堆栈的区别？</h3><ol>
<li>栈内存存储的是局部变量而堆内存存储的是实体；</li>
<li>栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</li>
<li>栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</li>
</ol>
<h3 id="197-队列和栈是什么？有什么区别？"><a href="#197-队列和栈是什么？有什么区别？" class="headerlink" title="197. 队列和栈是什么？有什么区别？"></a>197. 队列和栈是什么？有什么区别？</h3><ul>
<li>队列和栈都是被用来预存储数据的。</li>
<li>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。</li>
<li>栈和队列很相似，但它运行对元素进行后进先出进行检索。</li>
</ul>
<h3 id="198-什么是双亲委派模型？"><a href="#198-什么是双亲委派模型？" class="headerlink" title="198. 什么是双亲委派模型？"></a>198. 什么是双亲委派模型？</h3><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>
<p>类加载器分类：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME&#x2F;lib&#x2F;目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li>
<li>其他类加载器：</li>
<li>扩展类加载器（Extension ClassLoader）：负责加载<java_home style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; outline: 0px !important;">\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</java_home></li>
<li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li>
</ul>
<p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p>
<h3 id="199-说一下类加载的执行过程？"><a href="#199-说一下类加载的执行过程？" class="headerlink" title="199. 说一下类加载的执行过程？"></a>199. 说一下类加载的执行过程？</h3><p>类加载分为以下 5 个步骤：</p>
<ol>
<li>加载：根据查找路径找到相应的 class 文件然后导入；</li>
<li>检查：检查加载的 class 文件的正确性；</li>
<li>准备：给类中的静态变量分配内存空间；</li>
<li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li>
<li>初始化：对静态变量和静态代码块执行初始化工作。</li>
</ol>
<h3 id="200-怎么判断对象是否可以被回收？"><a href="#200-怎么判断对象是否可以被回收？" class="headerlink" title="200. 怎么判断对象是否可以被回收？"></a>200. 怎么判断对象是否可以被回收？</h3><p>一般有两种方法来判断：</p>
<ul>
<li>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li>
<li>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li>
</ul>
<h3 id="201-Java-中都有哪些引用类型？"><a href="#201-Java-中都有哪些引用类型？" class="headerlink" title="201. Java 中都有哪些引用类型？"></a>201. Java 中都有哪些引用类型？</h3><ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用（幽灵引用&#x2F;幻影引用）</li>
</ul>
<h3 id="202-说一下-JVM-有哪些垃圾回收算法？"><a href="#202-说一下-JVM-有哪些垃圾回收算法？" class="headerlink" title="202. 说一下 JVM 有哪些垃圾回收算法？"></a>202. 说一下 JVM 有哪些垃圾回收算法？</h3><ul>
<li>标记-清除算法</li>
<li>标记-整理算法</li>
<li>复制算法</li>
<li>分代算法</li>
</ul>
<h3 id="203-说一下-JVM-有哪些垃圾回收器？"><a href="#203-说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="203. 说一下 JVM 有哪些垃圾回收器？"></a>203. 说一下 JVM 有哪些垃圾回收器？</h3><ul>
<li>Serial：最早的单线程串行垃圾回收器。</li>
<li>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。</li>
<li>ParNew：是 Serial 的多线程版本。</li>
<li>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</li>
<li>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。</li>
<li>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B&#x2F;S 系统。</li>
<li>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</li>
</ul>
<h3 id="204-详细介绍一下-CMS-垃圾回收器？"><a href="#204-详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="204. 详细介绍一下 CMS 垃圾回收器？"></a>204. 详细介绍一下 CMS 垃圾回收器？</h3><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p>
<p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<h3 id="205-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#205-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="205. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a>205. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h3><ul>
<li>新生代回收器：Serial、ParNew、Parallel Scavenge</li>
<li>老年代回收器：Serial Old、Parallel Old、CMS</li>
<li>整堆回收器：G1</li>
</ul>
<p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p>
<h3 id="206-简述分代垃圾回收器是怎么工作的？"><a href="#206-简述分代垃圾回收器是怎么工作的？" class="headerlink" title="206. 简述分代垃圾回收器是怎么工作的？"></a>206. 简述分代垃圾回收器是怎么工作的？</h3><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1&#x2F;3，老生代的默认占比是 2&#x2F;3。</p>
<p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>
<ul>
<li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li>
<li>清空 Eden 和 From Survivor 分区；</li>
<li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li>
</ul>
<p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p>
<p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>
<h3 id="207-说一下-JVM-调优的工具？"><a href="#207-说一下-JVM-调优的工具？" class="headerlink" title="207. 说一下 JVM 调优的工具？"></a>207. 说一下 JVM 调优的工具？</h3><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>
<ul>
<li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li>
<li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li>
</ul>
<h3 id="208-常用的-jvm-调优的参数都有哪些？"><a href="#208-常用的-jvm-调优的参数都有哪些？" class="headerlink" title="208. 常用的 jvm 调优的参数都有哪些？"></a>208. 常用的 jvm 调优的参数都有哪些？</h3><ul>
<li>-Xms2g：初始化推大小为 2g；</li>
<li>-Xmx2g：堆最大内存为 2g；</li>
<li>-XX:NewRatio&#x3D;4：设置年轻的和老年代的内存比例为 1:4；</li>
<li>-XX:SurvivorRatio&#x3D;8：设置新生代 Eden 和 Survivor 比例为 8:2；</li>
<li>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</li>
<li>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</li>
<li>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</li>
<li>-XX:+PrintGC：开启打印 gc 信息；</li>
<li>-XX:+PrintGCDetails：打印 gc 详细信息。</li>
</ul>
<p><strong>（完）</strong></p>
<h1 id="Java-多线程编程"><a href="#Java-多线程编程" class="headerlink" title="Java 多线程编程"></a>Java 多线程编程</h1><p>Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<p>多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。</p>
<p>这里定义和线程相关的另一个术语 - 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。</p>
<p>多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。</p>
<hr>
<h2 id="一个线程的生命周期"><a href="#一个线程的生命周期" class="headerlink" title="一个线程的生命周期"></a>一个线程的生命周期</h2><p>线程是一个动态执行的过程，它也有一个从产生到死亡的过程。</p>
<p>下图显示了一个线程完整的生命周期。</p>
<img src="/2024/02/01/interview-question-java/java-thread.jpg" srcset="/img/loading.gif" lazyload class="" title="img">

<ul>
<li><p>新建状态:</p>
<p>使用 <strong>new</strong> 关键字和 <strong>Thread</strong> 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 <strong>start()</strong> 这个线程。</p>
</li>
<li><p>就绪状态:</p>
<p>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p>
</li>
<li><p>运行状态:</p>
<p>如果就绪状态的线程获取 CPU 资源，就可以执行 **run()**，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p>
</li>
<li><p>阻塞状态:</p>
<p>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p>
<ul>
<li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li>
<li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li>
<li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I&#x2F;O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I&#x2F;O 处理完毕，线程重新转入就绪状态。</li>
</ul>
</li>
<li><p>死亡状态:</p>
<p>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p>
</li>
</ul>
<hr>
<h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。</p>
<p>Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</p>
<p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p>
<p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p>
<hr>
<h2 id="创建一个线程"><a href="#创建一个线程" class="headerlink" title="创建一个线程"></a>创建一个线程</h2><p>Java 提供了三种创建线程的方法：</p>
<ul>
<li>通过实现 Runnable 接口；</li>
<li>通过继承 Thread 类本身；</li>
<li>通过 Callable 和 Future 创建线程。</li>
</ul>
<hr>
<h2 id="通过实现-Runnable-接口来创建线程"><a href="#通过实现-Runnable-接口来创建线程" class="headerlink" title="通过实现 Runnable 接口来创建线程"></a>通过实现 Runnable 接口来创建线程</h2><p>创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。</p>
<p>为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下：</p>
<p>public void run()</p>
<p>你可以重写该方法，重要的是理解的 run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。</p>
<p>在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。</p>
<p>Thread 定义了几个构造方法，下面的这个是我们经常使用的：</p>
<p>Thread(Runnable threadOb,String threadName);</p>
<p>这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。</p>
<p>新线程创建之后，你调用它的 start() 方法它才会运行。</p>
<p>void start();</p>
<p>下面是一个创建线程并开始让它执行的实例：</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 文件名 : DisplayMessage.java</span><br><span class="hljs-comment">// 通过实现 Runnable 接口创建线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DisplayMessage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>   <span class="hljs-keyword">private</span> String message;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">DisplayMessage</span><span class="hljs-params">(String message)</span> &#123;<br>      <span class="hljs-built_in">this</span>.message = message;<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>         System.out.println(message);<br>      &#125;<br>   &#125;<br>&#125;<br><br>GuessANumber.java 文件代码：<br><span class="hljs-comment">// 文件名 : GuessANumber.java</span><br><span class="hljs-comment">// 通过继承 Thread 类创建线程</span><br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GuessANumber</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">GuessANumber</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>      <span class="hljs-built_in">this</span>.number = number;<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">guess</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">do</span> &#123;<br>         guess = (<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>         System.out.println(<span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot; guesses &quot;</span> + guess);<br>         counter++;<br>      &#125; <span class="hljs-keyword">while</span>(guess != number);<br>      System.out.println(<span class="hljs-string">&quot;** Correct!&quot;</span> + <span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot;in&quot;</span> + counter + <span class="hljs-string">&quot;guesses.**&quot;</span>);<br>   &#125;<br>&#125;<br><br>ThreadClassDemo.java 文件代码：<br><span class="hljs-comment">// 文件名 : ThreadClassDemo.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadClassDemo</span> &#123;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String [] args)</span> &#123;<br>      <span class="hljs-type">Runnable</span> <span class="hljs-variable">hello</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DisplayMessage</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(hello);<br>      thread1.setDaemon(<span class="hljs-literal">true</span>);<br>      thread1.setName(<span class="hljs-string">&quot;hello&quot;</span>);<br>      System.out.println(<span class="hljs-string">&quot;Starting hello thread...&quot;</span>);<br>      thread1.start();<br>      <br>      <span class="hljs-type">Runnable</span> <span class="hljs-variable">bye</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DisplayMessage</span>(<span class="hljs-string">&quot;Goodbye&quot;</span>);<br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(bye);<br>      thread2.setPriority(Thread.MIN_PRIORITY);<br>      thread2.setDaemon(<span class="hljs-literal">true</span>);<br>      System.out.println(<span class="hljs-string">&quot;Starting goodbye thread...&quot;</span>);<br>      thread2.start();<br> <br>      System.out.println(<span class="hljs-string">&quot;Starting thread3...&quot;</span>);<br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">thread3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuessANumber</span>(<span class="hljs-number">27</span>);<br>      thread3.start();<br>      <span class="hljs-keyword">try</span> &#123;<br>         thread3.join();<br>      &#125;<span class="hljs-keyword">catch</span>(InterruptedException e) &#123;<br>         System.out.println(<span class="hljs-string">&quot;Thread interrupted.&quot;</span>);<br>      &#125;<br>      System.out.println(<span class="hljs-string">&quot;Starting thread4...&quot;</span>);<br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">thread4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuessANumber</span>(<span class="hljs-number">75</span>);<br>      <br>      thread4.start();<br>      System.out.println(<span class="hljs-string">&quot;main() is ending...&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<p>class RunnableDemo implements Runnable {   private Thread t;   private String threadName;      RunnableDemo( String name) {      threadName &#x3D; name;      System.out.println(“Creating “ +  threadName );   }      public void run() {      System.out.println(“Running “ +  threadName );      try {         for(int i &#x3D; 4; i &gt; 0; i–) {            System.out.println(“Thread: “ + threadName + “, “ + i);            &#x2F;&#x2F; 让线程睡眠一会            Thread.sleep(50);         }      }catch (InterruptedException e) {         System.out.println(“Thread “ +  threadName + “ interrupted.”);      }      System.out.println(“Thread “ +  threadName + “ exiting.”);   }      public void start () {      System.out.println(“Starting “ +  threadName );      if (t &#x3D;&#x3D; null) {         t &#x3D; new Thread (this, threadName);         t.start ();      }   } }  public class TestThread {    public static void main(String args[]) {      RunnableDemo R1 &#x3D; new RunnableDemo( “Thread-1”);      R1.start();            RunnableDemo R2 &#x3D; new RunnableDemo( “Thread-2”);      R2.start();   }    }</p>
<p>编译以上程序运行结果如下：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Creating</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><br><span class="hljs-variable">Starting</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><br><span class="hljs-variable">Creating</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span><br><span class="hljs-variable">Starting</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span><br><span class="hljs-variable">Running</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><br><span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><span class="hljs-operator">,</span> <span class="hljs-number">4</span><br><span class="hljs-variable">Running</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span><br><span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span><span class="hljs-operator">,</span> <span class="hljs-number">4</span><br><span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><span class="hljs-operator">,</span> <span class="hljs-number">3</span><br><span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span><span class="hljs-operator">,</span> <span class="hljs-number">3</span><br><span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><span class="hljs-operator">,</span> <span class="hljs-number">2</span><br><span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span><span class="hljs-operator">,</span> <span class="hljs-number">2</span><br><span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><span class="hljs-operator">,</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span><span class="hljs-operator">,</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">Thread</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span> <span class="hljs-variable">exiting</span><span class="hljs-operator">.</span><br><span class="hljs-built_in">Thread</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span> <span class="hljs-variable">exiting</span><span class="hljs-operator">.</span><br></code></pre></td></tr></table></figure>

<hr>
<h2 id="通过继承Thread来创建线程"><a href="#通过继承Thread来创建线程" class="headerlink" title="通过继承Thread来创建线程"></a>通过继承Thread来创建线程</h2><p>创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。</p>
<p>继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。</p>
<p>该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>class ThreadDemo extends Thread {   private Thread t;   private String threadName;      ThreadDemo( String name) {      threadName &#x3D; name;      System.out.println(“Creating “ +  threadName );   }      public void run() {      System.out.println(“Running “ +  threadName );      try {         for(int i &#x3D; 4; i &gt; 0; i–) {            System.out.println(“Thread: “ + threadName + “, “ + i);            &#x2F;&#x2F; 让线程睡眠一会            Thread.sleep(50);         }      }catch (InterruptedException e) {         System.out.println(“Thread “ +  threadName + “ interrupted.”);      }      System.out.println(“Thread “ +  threadName + “ exiting.”);   }      public void start () {      System.out.println(“Starting “ +  threadName );      if (t &#x3D;&#x3D; null) {         t &#x3D; new Thread (this, threadName);         t.start ();      }   } }  public class TestThread {    public static void main(String args[]) {      ThreadDemo T1 &#x3D; new ThreadDemo( “Thread-1”);      T1.start();            ThreadDemo T2 &#x3D; new ThreadDemo( “Thread-2”);      T2.start();   }    }</p>
<p>编译以上程序运行结果如下：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Creating</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><br><span class="hljs-variable">Starting</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><br><span class="hljs-variable">Creating</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span><br><span class="hljs-variable">Starting</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span><br><span class="hljs-variable">Running</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><br><span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><span class="hljs-operator">,</span> <span class="hljs-number">4</span><br><span class="hljs-variable">Running</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span><br><span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span><span class="hljs-operator">,</span> <span class="hljs-number">4</span><br><span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><span class="hljs-operator">,</span> <span class="hljs-number">3</span><br><span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span><span class="hljs-operator">,</span> <span class="hljs-number">3</span><br><span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><span class="hljs-operator">,</span> <span class="hljs-number">2</span><br><span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span><span class="hljs-operator">,</span> <span class="hljs-number">2</span><br><span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><span class="hljs-operator">,</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span><span class="hljs-operator">,</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">Thread</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span> <span class="hljs-variable">exiting</span><span class="hljs-operator">.</span><br><span class="hljs-built_in">Thread</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span> <span class="hljs-variable">exiting</span><span class="hljs-operator">.</span><br></code></pre></td></tr></table></figure>

<hr>
<h2 id="Thread-方法"><a href="#Thread-方法" class="headerlink" title="Thread 方法"></a>Thread 方法</h2><p>下表列出了Thread类的一些重要方法：</p>
<table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="center"><strong>方法描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="center"><strong>public void start()</strong> 使该线程开始执行；<strong>Java</strong> 虚拟机调用该线程的 run 方法。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="center"><strong>public void run()</strong> 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="center"><strong>public final void setName(String name)</strong> 改变线程名称，使之与参数 name 相同。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="center"><strong>public final void setPriority(int priority)</strong>  更改线程的优先级。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="center"><strong>public final void setDaemon(boolean on)</strong> 将该线程标记为守护线程或用户线程。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="center"><strong>public final void join(long millisec)</strong> 等待该线程终止的时间最长为 millis 毫秒。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="center"><strong>public void interrupt()</strong> 中断线程。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="center"><strong>public final boolean isAlive()</strong> 测试线程是否处于活动状态。</td>
</tr>
</tbody></table>
<p>上述方法是被 Thread 对象调用的，下面表格的方法是 Thread 类的静态方法。</p>
<table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="center"><strong>方法描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="center"><strong>public static void yield()</strong> 暂停当前正在执行的线程对象，并执行其他线程。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="center"><strong>public static void sleep(long millisec)</strong> 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="center"><strong>public static boolean holdsLock(Object x)</strong> 当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="center"><strong>public static Thread currentThread()</strong> 返回对当前正在执行的线程对象的引用。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="center"><strong>public static void dumpStack()</strong> 将当前线程的堆栈跟踪打印至标准错误流。</td>
</tr>
</tbody></table>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>如下的ThreadClassDemo 程序演示了Thread类的一些方法：</p>
<h2 id="DisplayMessage-java-文件代码："><a href="#DisplayMessage-java-文件代码：" class="headerlink" title="DisplayMessage.java 文件代码："></a>DisplayMessage.java 文件代码：</h2><p>&#x2F;&#x2F; 文件名 : DisplayMessage.java &#x2F;&#x2F; 通过实现 Runnable 接口创建线程 public class DisplayMessage implements Runnable {   private String message;      public DisplayMessage(String message) {      this.message &#x3D; message;   }      public void run() {      while(true) {         System.out.println(message);      }   } }</p>
<h2 id="GuessANumber-java-文件代码："><a href="#GuessANumber-java-文件代码：" class="headerlink" title="GuessANumber.java 文件代码："></a>GuessANumber.java 文件代码：</h2><p>&#x2F;&#x2F; 文件名 : GuessANumber.java &#x2F;&#x2F; 通过继承 Thread 类创建线程  public class GuessANumber extends Thread {   private int number;   public GuessANumber(int number) {      this.number &#x3D; number;   }      public void run() {      int counter &#x3D; 0;      int guess &#x3D; 0;      do {         guess &#x3D; (int) (Math.random() * 100 + 1);         System.out.println(this.getName() + “ guesses “ + guess);         counter++;      } while(guess !&#x3D; number);      System.out.println(“** Correct!” + this.getName() + “in” + counter + “guesses.**”);   } }</p>
<h2 id="ThreadClassDemo-java-文件代码："><a href="#ThreadClassDemo-java-文件代码：" class="headerlink" title="ThreadClassDemo.java 文件代码："></a>ThreadClassDemo.java 文件代码：</h2><p>&#x2F;&#x2F; 文件名 : ThreadClassDemo.java public class ThreadClassDemo {    public static void main(String [] args) {      Runnable hello &#x3D; new DisplayMessage(“Hello”);      Thread thread1 &#x3D; new Thread(hello);      thread1.setDaemon(true);      thread1.setName(“hello”);      System.out.println(“Starting hello thread…”);      thread1.start();            Runnable bye &#x3D; new DisplayMessage(“Goodbye”);      Thread thread2 &#x3D; new Thread(bye);      thread2.setPriority(Thread.MIN_PRIORITY);      thread2.setDaemon(true);      System.out.println(“Starting goodbye thread…”);      thread2.start();       System.out.println(“Starting thread3…”);      Thread thread3 &#x3D; new GuessANumber(27);      thread3.start();      try {         thread3.join();      }catch(InterruptedException e) {         System.out.println(“Thread interrupted.”);      }      System.out.println(“Starting thread4…”);      Thread thread4 &#x3D; new GuessANumber(75);            thread4.start();      System.out.println(“main() is ending…”);   } }</p>
<p>运行结果如下，每一次运行的结果都不一样。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lasso">Starting hello <span class="hljs-keyword">thread</span><span class="hljs-params">...</span><br>Starting goodbye <span class="hljs-keyword">thread</span><span class="hljs-params">...</span><br>Hello<br>Hello<br>Hello<br>Hello<br>Hello<br>Hello<br>Goodbye<br>Goodbye<br>Goodbye<br>Goodbye<br>Goodbye<br><span class="hljs-params">...</span><span class="hljs-params">...</span>.<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="通过-Callable-和-Future-创建线程"><a href="#通过-Callable-和-Future-创建线程" class="headerlink" title="通过 Callable 和 Future 创建线程"></a>通过 Callable 和 Future 创建线程</h2><ul>
<li>\1. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</li>
<li>\2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li>
<li>\3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li>
<li>\4. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</li>
</ul>
<h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><p>public class CallableThreadTest implements Callable<Integer> {    public static void main(String[] args)      {          CallableThreadTest ctt &#x3D; new CallableThreadTest();          FutureTask<Integer> ft &#x3D; new FutureTask&lt;&gt;(ctt);          for(int i &#x3D; 0;i &lt; 100;i++)          {              System.out.println(Thread.currentThread().getName()+” 的循环变量i的值”+i);              if(i&#x3D;&#x3D;20)              {                  new Thread(ft,”有返回值的线程”).start();              }          }          try          {              System.out.println(“子线程的返回值：”+ft.get());          } catch (InterruptedException e)          {              e.printStackTrace();          } catch (ExecutionException e)          {              e.printStackTrace();          }        }    @Override      public Integer call() throws Exception      {          int i &#x3D; 0;          for(;i&lt;100;i++)          {              System.out.println(Thread.currentThread().getName()+” “+i);          }          return i;      }   }</p>
<hr>
<h2 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h2><ul>
<li>\1. 采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li>
<li>\2. 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li>
</ul>
<hr>
<h2 id="线程的几个主要概念"><a href="#线程的几个主要概念" class="headerlink" title="线程的几个主要概念"></a>线程的几个主要概念</h2><p>在多线程编程时，你需要了解以下几个概念：</p>
<ul>
<li>线程同步</li>
<li>线程间通信</li>
<li>线程死锁</li>
<li>线程控制：挂起、停止和恢复</li>
</ul>
<hr>
<h2 id="多线程的使用"><a href="#多线程的使用" class="headerlink" title="多线程的使用"></a>多线程的使用</h2><p>有效利用多线程的关键是理解程序是并发执行而不是串行执行的。例如：程序中有两个子系统需要并发执行，这时候就需要利用多线程编程。</p>
<p>通过对多线程的使用，可以编写出非常高效的程序。不过请注意，如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了。</p>
<p>请记住，上下文的切换开销也很重要，如果你创建了太多的线程，CPU 花费在上下文的切换的时间将多于执行程序的时间！</p>
<h2 id="Java面试题及答案2019版"><a href="#Java面试题及答案2019版" class="headerlink" title="Java面试题及答案2019版"></a>Java面试题及答案2019版</h2><p>Java程序员-张凯 2019-07-15 16:25:48  111579  收藏 998<br>分类专栏： java面试题 文章标签： java面试题<br>版权</p>
<h3 id="1、面向对象的特征有哪些方面？"><a href="#1、面向对象的特征有哪些方面？" class="headerlink" title="1、面向对象的特征有哪些方面？"></a>1、面向对象的特征有哪些方面？</h3><p>答：面向对象的特征主要有以下几个方面：</p>
<p>抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p>
<p>继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。</p>
<p>封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。</p>
<p>多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</p>
<h3 id="2、访问修饰符public-private-protected-以及不写（默认）时的区别？"><a href="#2、访问修饰符public-private-protected-以及不写（默认）时的区别？" class="headerlink" title="2、访问修饰符public,private,protected,以及不写（默认）时的区别？"></a>2、访问修饰符public,private,protected,以及不写（默认）时的区别？</h3><p>答：类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java中，外部类的修饰符只能是public或默认，类的成员（包括内部类）的修饰符可以是以上四种。</p>
<h3 id="3、String是最基本的数据类型吗？"><a href="#3、String是最基本的数据类型吗？" class="headerlink" title="3、String是最基本的数据类型吗？"></a>3、String是最基本的数据类型吗？</h3><p>答：不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5以后引入的枚举类型也算是一种比较特殊的引用类型。</p>
<h3 id="4、float-f-3-4-是否正确？"><a href="#4、float-f-3-4-是否正确？" class="headerlink" title="4、float f&#x3D;3.4;是否正确？"></a>4、float f&#x3D;3.4;是否正确？</h3><p>答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f &#x3D;(float)3.4; 或者写成float f &#x3D;3.4F;。</p>
<h3 id="5、short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？"><a href="#5、short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？" class="headerlink" title="5、short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗？"></a>5、short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗？</h3><p>答：对于short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确编译，因为s1+&#x3D; 1;相当于s1 &#x3D; (short)(s1 + 1);其中有隐含的强制类型转换。<br>示例代码如下：</p>
<p>前者有错，s1会自动提升为int类型，结果赋值给short类型，所以报错。<br>后者无错，+&#x3D;这种赋值运算符隐含了强制类型转换。其实变量s1的值未被使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(Math.round(<span class="hljs-number">11.5</span>));    <span class="hljs-comment">// 12</span><br>        System.out.println(Math.round(-<span class="hljs-number">11.5</span>));   <span class="hljs-comment">// -11</span><br><br>        <span class="hljs-comment">// short s1 = 1; </span><br>        <span class="hljs-comment">// s1 = s1 + 1; // Type mismatch: cannot convert from int to short 类型不匹配：不能从int转换为short</span><br>     <br>        <span class="hljs-type">short</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// The value of the local variable s1 is not used 局部变量s1的值未被使用 出现了警告</span><br>        s1 += <span class="hljs-number">1</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6、Java有没有goto？"><a href="#6、Java有没有goto？" class="headerlink" title="6、Java有没有goto？"></a>6、Java有没有goto？</h3><p>答：goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字）</p>
<h3 id="7、int和Integer有什么区别？"><a href="#7、int和Integer有什么区别？" class="headerlink" title="7、int和Integer有什么区别？"></a>7、int和Integer有什么区别？</h3><p>答：Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱&#x2F;拆箱机制，使得二者可以相互转换。<br>Java 为每个原始类型提供了包装类型：</p>
<p>原始类型：boolean，char，byte，short，int，long，float，double<br>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double<br>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoUnboxingTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;                  <span class="hljs-comment">// 将3自动装箱成Integer类型</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        System.out.println(a == b);     <span class="hljs-comment">// false 两个引用没有引用同一对象</span><br>        System.out.println(a == c);     <span class="hljs-comment">// true  a自动拆箱成int类型再和c比较</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test03</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>, f2 = <span class="hljs-number">100</span>, f3 = <span class="hljs-number">150</span>, f4 = <span class="hljs-number">150</span>;<br>     <br>        System.out.println(f1 == f2);<br>        System.out.println(f3 == f4);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>


<p>如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象引用，所以下面的&#x3D;&#x3D;运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。</p>
<pre><code class="hljs">public static Integer valueOf(int i) &#123;
    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
&#125;
</code></pre>
<p>IntegerCache是Integer的内部类，其代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Cache to support the object identity semantics of autoboxing for values between</span><br><span class="hljs-comment">     * -128 and 127 (inclusive) as required by JLS.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * The cache is initialized on first usage.  The size of the cache</span><br><span class="hljs-comment">     * may be controlled by the &#123;<span class="hljs-doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span><br><span class="hljs-comment">     * During VM initialization, java.lang.Integer.IntegerCache.high property</span><br><span class="hljs-comment">     * may be set and saved in the private system properties in the</span><br><span class="hljs-comment">     * sun.misc.VM class.</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegerCache</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> -<span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> high;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br> <br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// high value may be configured by property</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">integerCacheHighPropValue</span> <span class="hljs-operator">=</span><br>            sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>        <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> parseInt(integerCacheHighPropValue);<br>                i = Math.max(i, <span class="hljs-number">127</span>);<br>                <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>                <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span><br>            &#125;<br>        &#125;<br>        high = h;<br> <br>        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[(high - low) + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> low;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>            cache[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(j++);<br> <br>        <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>        <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IntegerCache</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1&#x3D;&#x3D;f2的结果是true，而f3&#x3D;&#x3D;f4的结果是false。</p>
<p>提醒：越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。</p>
<h3 id="8、-和-的区别？"><a href="#8、-和-的区别？" class="headerlink" title="8、&amp;和&amp;&amp;的区别？"></a>8、&amp;和&amp;&amp;的区别？</h3><p>答：&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username !&#x3D; null &amp;&amp; !username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p>
<p>补充：如果你熟悉JavaScript，那你可能更能感受到短路运算的强大，想成为JavaScript的高手就先从玩转短路运算开始吧。</p>
<h3 id="9、解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法。"><a href="#9、解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法。" class="headerlink" title="9、解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。"></a>9、解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。</h3><p>答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间；而通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。</p>
<p>String str &#x3D; new String(“hello”);<br>上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而”hello”这个字面量是放在方法区的。</p>
<p>补充1：较新版本的Java（从Java 6的某个更新开始）中，由于JIT编译器的发展和”逃逸分析”技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象一定分配在堆上这件事情已经变得不那么绝对了。<br>补充2：运行时常量池相当于Class文件常量池具有动态性，Java语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String类的intern()方法就是这样的。</p>
<p>看看下面代码的执行结果是什么并且比较一下jdk7以前和以后的运行结果是否一致。</p>
<p>String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含了一个等于此String对象的字符串，则返回代表池(运行时常量池)中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中并且返回此String对象的引用。此方法在jdk1.6和jdk1.7中有差异。</p>
<p>String s1 &#x3D; new StringBuilder(“go”).append(“od”).toString();<br>System.out.println(s1.intern() &#x3D;&#x3D; s1);<br>String s2 &#x3D; new StringBuilder(“ja”).append(“va”).toString();<br>System.out.println(s2.intern() &#x3D;&#x3D; s2);</p>
<p>这段代码在jdk1.6中运行，会得到两个false，而在jdk1.7中运行会得到一个true一个false。产生差异的原因是：在jdk1.6中，intern()方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而用StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。而jdk1.7中的intern()实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个。对比str2返回false是因为“java”这个字符串在执行StringBuilder.toString()之前已经出现过，字符串常量池中已经有它的引用了，不符合首次出现的原则，而“good”这个字符串则是首次出现的，因此返回true。</p>
<p>现在的疑问是“java”这个字符串在常量池中什么时候存在了？<br>我最开始的猜想是“java”这个字符串是不是常驻在常量池中的？那为什么常驻在常量池中呢？Java虚拟机什么时候加载了“java”这个字符串？<br>  答：java虚拟机会自动调用System类，代码如下：</p>
<p>&#x2F;* register the natives via the static initializer.<br> *</p>
<ul>
<li>VM will invoke the initializeSystemClass method to complete</li>
<li>the initialization for this class separated from clinit.</li>
<li>Note that to use properties set by the VM, see the constraints</li>
<li>described in the initializeSystemClass method.<br> *&#x2F;<br> 在System类中的注释可以知道，调用了initializeSystemClass方法，在此方法中调用了Version对象的init静态方法<br> sun.misc.Version.init();<br> 因此sun.misc.Version类会在JDK类库的初始化过程中被加载并初始化。<br> 查看Version类定义的私有静态字符串常量如下：<br> private static final String launcher_name &#x3D; “java”;<br> private static final String java_version &#x3D; “1.7.0_51”;<br> private static final String java_runtime_name &#x3D; “Java(TM) SE Runtime Environment”;<br> private static final String java_runtime_version &#x3D; “1.7.0_51-b13”;<br> 在初始化Version类时，对其静态常量字段根据指定的常量值做默认初始化，所以”java”被加载到了字符串常量池中，修改上面代码使字符串值为上面常量中的任意一个都会返回false。<br> String str2&#x3D;new StringBuilder(“1.7.0”).append(“_51”).toString();<br> System.out.println(str2.intern()&#x3D;&#x3D;str2);<br>   这个问题解决了，上面这些在虚拟机加载时就初始化的常量，我们再定义其他的字符串常量试试，比如“xiaoyi and heize”，运行结果：true，可以知道”xiaoyi and heize”这个字符串常量没有被预先加载到常量池中。</li>
</ul>
<p>ps：在虚拟机上进行开发的开发人员称方法区为“永久代”，但两者本质上并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集器扩展至方法区，或者说使用永久代来实现方法区而已，但现在看来使用永久代实现方法区并不是一个好主意，因为这样更容易遇到内存溢出问题，在jdk1.7中的HotSpot中，已经把原本放在永久代中的字符串常量池移除—摘自《深入理解Java虚拟机》</p>
<h3 id="10、Math-round-11-5-等于多少？Math-round-11-5-等于多少？"><a href="#10、Math-round-11-5-等于多少？Math-round-11-5-等于多少？" class="headerlink" title="10、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？"></a>10、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？</h3><p>答：Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。</p>
<p>Math类的成员方法：<br>    public static int round(float a) 　　四舍五入(参数为double的自学)<br>    要深刻理解四舍五入的具体含义：<br>        满足五入的条件后，得到的值要比原来的值大；<br>        满足四舍的条件后，得到的值要比原来的值小；<br>        不管是正数还是负数。</p>
<h3 id="11、switch是否能作用在byte上，是否能作用在long上，是否能作用在String上？"><a href="#11、switch是否能作用在byte上，是否能作用在long上，是否能作用在String上？" class="headerlink" title="11、switch是否能作用在byte上，是否能作用在long上，是否能作用在String上？"></a>11、switch是否能作用在byte上，是否能作用在long上，是否能作用在String上？</h3><p>答：在Java 5以前，switch(expr)中，expr只能是byte、short、char、int；从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型；从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p>
<h3 id="12、用最有效率的方法计算2乘以8？"><a href="#12、用最有效率的方法计算2乘以8？" class="headerlink" title="12、用最有效率的方法计算2乘以8？"></a>12、用最有效率的方法计算2乘以8？</h3><p>答： 2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。</p>
<p>补充：我们为编写的类重写hashCode方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择31这个数？前两个问题的答案你可以自己百度一下，选择31是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num 等价于(num &lt;&lt; 5) - num，左移5位相当于乘以2的5次方再减去自身就相当于乘以31，现在的VM都能自动完成这个优化。</p>
<p>为编写的类重写hashCode方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhoneNumber</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> areaCode;<br>    <span class="hljs-keyword">private</span> String prefix;<br>    <span class="hljs-keyword">private</span> String lineNumber;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">prime</span> <span class="hljs-operator">=</span> <span class="hljs-number">31</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        result = prime * result + areaCode;<br>        result = prime * result<br>                + ((lineNumber == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : lineNumber.hashCode());<br>        result = prime * result + ((prefix == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : prefix.hashCode());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>     <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == obj)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (getClass() != obj.getClass())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">PhoneNumber</span> <span class="hljs-variable">other</span> <span class="hljs-operator">=</span> (PhoneNumber) obj;<br>        <span class="hljs-keyword">if</span> (areaCode != other.areaCode)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (lineNumber == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (other.lineNumber != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!lineNumber.equals(other.lineNumber))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (prefix == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (other.prefix != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!prefix.equals(other.prefix))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="13、数组有没有length-方法？String有没有length-方法？"><a href="#13、数组有没有length-方法？String有没有length-方法？" class="headerlink" title="13、数组有没有length()方法？String有没有length()方法？"></a>13、数组有没有length()方法？String有没有length()方法？</h3><p>答：数组没有length()方法，有length的属性。<br>String有length()方法。在JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。</p>
<h3 id="14、在Java中，如何跳出当前的多重嵌套循环？"><a href="#14、在Java中，如何跳出当前的多重嵌套循环？" class="headerlink" title="14、在Java中，如何跳出当前的多重嵌套循环？"></a>14、在Java中，如何跳出当前的多重嵌套循环？</h3><p>答：在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好，为什么会让程序变得不优雅呢？一个程序跳来跳去，太灵活了，我们不能够控制了，就不好了）</p>
<h3 id="15、构造器（constructor）是否可被重写（override）？"><a href="#15、构造器（constructor）是否可被重写（override）？" class="headerlink" title="15、构造器（constructor）是否可被重写（override）？"></a>15、构造器（constructor）是否可被重写（override）？</h3><p>答：构造器不能被继承，因此不能被重写，但可以被重载。</p>
<h3 id="16、两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#16、两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="16、两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？"></a>16、两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？</h3><p>答：不对，如果两个对象x和y满足x.equals(y) &#x3D;&#x3D; true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：<br>  (1) 如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；<br>  (2) 如果两个对象的hashCode相同，它们并不一定相同。<br>当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。</p>
<p>补充：关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective Java》、《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍，如果你还没看过，那就赶紧去亚马逊买一本吧）中是这样介绍equals方法的：首先equals方法必须满足自反性（x.equals(x)必须返回true）、对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。<br>实现高质量的equals方法的诀窍包括：<br>  1. 使用&#x3D;&#x3D;操作符检查”参数是否为这个对象的引用”；<br>  2. 使用instanceof操作符检查”参数是否为正确的类型”；<br>  3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；<br>  4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性；<br>  5. 重写equals时总是要重写hashCode；<br>  6. 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。</p>
<h3 id="17、是否可以继承String类？"><a href="#17、是否可以继承String类？" class="headerlink" title="17、是否可以继承String类？"></a>17、是否可以继承String类？</h3><p>答：String 类是final类，不可以被继承。</p>
<p>补充：继承String本身就是一个错误的行为，对String类型最好的重用方式是关联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。</p>
<h3 id="18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"><a href="#18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？" class="headerlink" title="18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"></a>18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</h3><p>答：是值传递。Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用（地址值）。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。在C#中可以编写如下所示的代码，但是在Java中却做不到。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">CS01</span> &#123;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> x, <span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> y</span>)</span> &#123;<br>            <span class="hljs-built_in">int</span> temp = x;<br>            x = y;<br>            y = temp;<br>        &#125;<br>     <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span> (<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span> &#123;<br>            <span class="hljs-built_in">int</span> a = <span class="hljs-number">5</span>, b = <span class="hljs-number">10</span>;<br>            swap (<span class="hljs-keyword">ref</span> a, <span class="hljs-keyword">ref</span> b);<br>            <span class="hljs-comment">// a = 10, b = 5;</span><br>            Console.WriteLine (<span class="hljs-string">&quot;a = &#123;0&#125;, b = &#123;1&#125;&quot;</span>, a, b);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>


<p>说明：Java中没有传引用实在是非常的不方便，这一点在Java 8中仍然没有得到改进，正是如此在Java编写的代码中才会出现大量的Wrapper类（将需要通过方法调用修改的引用置于一个Wrapper类中，再将Wrapper对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从C和C++转型为Java程序员的开发者无法容忍。</p>
<p>其实还是不够明白，我们来看看下面的例子吧：<br>强烈推荐鄙人的例子，参考链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenmingjun/p/8698719.html">https://www.cnblogs.com/chenmingjun/p/8698719.html</a></p>
<h3 id="19、String和StringBuilder、StringBuffer的区别？"><a href="#19、String和StringBuilder、StringBuffer的区别？" class="headerlink" title="19、String和StringBuilder、StringBuffer的区别？"></a>19、String和StringBuilder、StringBuffer的区别？</h3><p>答：Java平台提供了两种类型的字符串：String和StringBuffer&#x2F;StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer&#x2F;StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰（非同步），因此它的效率也比StringBuffer要高。</p>
<p>面试题1：什么情况下用+运算符进行字符串连接比调用StringBuffer&#x2F;StringBuilder对象的append方法连接字符串性能更好？<br>面试题2：请说出下面程序的输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringEqualTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Programming&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Programming&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Program&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ming&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Program&quot;</span> + <span class="hljs-string">&quot;ming&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s6</span> <span class="hljs-operator">=</span> s3 + s4;<br>        System.out.println(s1 == s2); <span class="hljs-comment">// false</span><br>        System.out.println(s1 == s5); <span class="hljs-comment">// true</span><br>        System.out.println(s1 == s6); <span class="hljs-comment">// false</span><br>        System.out.println(s1 == s6.intern()); <span class="hljs-comment">// true</span><br>        System.out.println(s2 == s2.intern()); <span class="hljs-comment">// false</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>


<p>补充：解答上面的面试题需要清除两点：</p>
<p>String对象的intern方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与String对象的equals结果是true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用。<br>字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象，这一点可以用javap -c StringEqualTest.class命令获得class文件对应的JVM字节码指令就可以看出来。<br>要想获取对象的内存地址应使用System.identityHashCode()方法。</p>
<h3 id="20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h3><p>答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</p>
<p>面试题：华为的面试题中曾经问过这样一个问题：”为什么不能根据返回类型来区分重载”，快说出你的答案吧！</p>
<h3 id="21、描述一下JVM加载class文件的原理机制？"><a href="#21、描述一下JVM加载class文件的原理机制？" class="headerlink" title="21、描述一下JVM加载class文件的原理机制？"></a>21、描述一下JVM加载class文件的原理机制？</h3><p>答：JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。</p>
<p>由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1) 如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2) 如果类中存在初始化语句，就依次执行这些初始化语句。</p>
<p>类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：</p>
<p>Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；<br>Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；<br>System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</p>
<h3 id="22、char-型变量中能不能存贮一个中文汉字，为什么？"><a href="#22、char-型变量中能不能存贮一个中文汉字，为什么？" class="headerlink" title="22、char 型变量中能不能存贮一个中文汉字，为什么？"></a>22、char 型变量中能不能存贮一个中文汉字，为什么？</h3><p>答：char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16比特），所以放一个中文是没问题的。</p>
<p>补充：使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于C程序员来说，要完成这样的编码转换恐怕要依赖于union（联合体&#x2F;共用体）共享内存的特征来实现了。</p>
<h3 id="23、抽象类（abstract-class）和接口（interface）有什么异同？"><a href="#23、抽象类（abstract-class）和接口（interface）有什么异同？" class="headerlink" title="23、抽象类（abstract class）和接口（interface）有什么异同？"></a>23、抽象类（abstract class）和接口（interface）有什么异同？</h3><p>答：抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。</p>
<h3 id="24、静态嵌套类（Static-Nested-Class）和内部类（Inner-Class）的不同？"><a href="#24、静态嵌套类（Static-Nested-Class）和内部类（Inner-Class）的不同？" class="headerlink" title="24、静态嵌套类（Static Nested Class）和内部类（Inner Class）的不同？"></a>24、静态嵌套类（Static Nested Class）和内部类（Inner Class）的不同？</h3><p>答：Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的。</p>
<p>面试题：下面的代码哪些地方会产生编译错误？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;&#125;<br>     <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123; <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>(); <br>    &#125;<br>     <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span> &#123; <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>(); <br>    &#125;<br>     <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>


<p>注意：Java中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中foo和main方法都是静态方法，静态方法中没有this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做：new Outer().new Inner();</p>
<h3 id="25、Java中会存在内存泄漏吗？请简单描述。"><a href="#25、Java中会存在内存泄漏吗？请简单描述。" class="headerlink" title="25、Java中会存在内存泄漏吗？请简单描述。"></a>25、Java中会存在内存泄漏吗？请简单描述。</h3><p>答：理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。下面例子中的代码也会导致内存泄露。</p>
<p>import java.util.Arrays;<br>import java.util.EmptyStackException;</p>
<p>public class MyStack<T> {<br>    private T[] elements;<br>    private int size &#x3D; 0;</p>
<pre><code class="hljs">private static final int INIT_CAPACITY = 16;
 
public MyStack() &#123;
    elements = (T[]) new Object[INIT_CAPACITY];
&#125;
 
public void push(T elem) &#123;
    ensureCapacity();
    elements[size++] = elem;
&#125;
 
public T pop() &#123;
    if(size == 0) 
        throw new EmptyStackException();
    return elements[--size];
&#125;
 
private void ensureCapacity() &#123;
    if(elements.length == size) &#123;
        elements = Arrays.copyOf(elements, 2 * size + 1);
    &#125;
&#125;
</code></pre>
<p>}<br>上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。</p>
<p>26、抽象的（abstract）方法是否可同时是静态的（static），是否可同时是本地方法（native），是否可同时被synchronized修饰？<br>答：都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</p>
<h3 id="27、阐述静态变量和实例变量的区别。"><a href="#27、阐述静态变量和实例变量的区别。" class="headerlink" title="27、阐述静态变量和实例变量的区别。"></a>27、阐述静态变量和实例变量的区别。</h3><p>答：静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。</p>
<p>补充：在Java开发中，上下文类和工具类中通常会有大量的静态成员。</p>
<h3 id="28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><a href="#28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？" class="headerlink" title="28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"></a>28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</h3><p>答：不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。</p>
<h3 id="29、如何实现对象克隆？"><a href="#29、如何实现对象克隆？" class="headerlink" title="29、如何实现对象克隆？"></a>29、如何实现对象克隆？</h3><p>答：有两种方式：<br>  1) 实现Cloneable接口并重写Object类中的clone()方法；<br>  2) 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</p>
<p>注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。</p>
<h3 id="30、GC是什么？为什么要有GC？"><a href="#30、GC是什么？为什么要有GC？" class="headerlink" title="30、GC是什么？为什么要有GC？"></a>30、GC是什么？为什么要有GC？</h3><p>答：GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或 Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。<br>  垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。</p>
<p>补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会跟据Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域：</p>
<p>伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。<br>幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。<br>终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。<br>与垃圾回收相关的JVM参数：</p>
<p>-Xms &#x2F; -Xmx –&gt; 堆的初始大小 &#x2F; 堆的最大大小<br>-Xmn –&gt; 堆中年轻代的大小<br>-XX:-DisableExplicitGC –&gt; 让System.gc()不产生任何作用<br>-XX:+PrintGCDetails –&gt; 打印GC的细节<br>-XX:+PrintGCDateStamps –&gt; 打印GC操作的时间戳<br>-XX:NewSize –&gt; 设置新生代大小<br>-XX:MaxNewSize –&gt; 设置新生代最大大小<br>-XX:NewRatio –&gt; 可以设置老生代和新生代的比例<br>-XX:PrintTenuringDistribution –&gt; 设置每次新生代GC后输出幸存者乐园中对象年龄的分布<br>-XX:InitialTenuringThreshold –&gt; 设置老年代阀值的初始值<br>-XX:MaxTenuringThreshold –&gt; 设置老年代阀值的最大值<br>-XX:TargetSurvivorRatio –&gt; 设置幸存区的目标使用率</p>
<h3 id="31、String-s-new-String-“xyz”-创建了几个字符串对象？"><a href="#31、String-s-new-String-“xyz”-创建了几个字符串对象？" class="headerlink" title="31、String s &#x3D; new String(“xyz”);创建了几个字符串对象？"></a>31、String s &#x3D; new String(“xyz”);创建了几个字符串对象？</h3><p>答：两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p>
<h3 id="32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete-class）？"><a href="#32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete-class）？" class="headerlink" title="32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？"></a>32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？</h3><p>答：接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。</p>
<h3 id="33、一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><a href="#33、一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？" class="headerlink" title="33、一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"></a>33、一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</h3><p>答：可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。</p>
<h3 id="34、Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？"><a href="#34、Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？" class="headerlink" title="34、Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？"></a>34、Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</h3><p>答：可以继承其他类或实现其他接口，在Swing编程和Android开发中常用此方式来实现事件监听和回调。</p>
<h3 id="35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><a href="#35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"></a>35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</h3><p>答：一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</p>
<h3 id="36、Java-中的final关键字有哪些用法？"><a href="#36、Java-中的final关键字有哪些用法？" class="headerlink" title="36、Java 中的final关键字有哪些用法？"></a>36、Java 中的final关键字有哪些用法？</h3><p>答：<br>　　(1)修饰类：表示该类不能被继承；<br>　　(2)修饰方法：表示方法不能被重写；<br>　　(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。</p>
<h3 id="37、指出下面程序的运行结果。"><a href="#37、指出下面程序的运行结果。" class="headerlink" title="37、指出下面程序的运行结果。"></a>37、指出下面程序的运行结果。</h3><p>class A {</p>
<pre><code class="hljs">static &#123;
    System.out.print(&quot;1&quot;);
&#125;
 
public A() &#123;
    System.out.print(&quot;2&quot;);
&#125;
</code></pre>
<p>}</p>
<p>class B extends A {</p>
<pre><code class="hljs">static &#123;
    System.out.print(&quot;a&quot;);
&#125;
 
public B() &#123;
    System.out.print(&quot;b&quot;);
&#125;
</code></pre>
<p>}</p>
<p>public class Hello {</p>
<pre><code class="hljs">public static void main(String[] args) &#123;
    A ab = new B();
    ab = new B();
&#125;
</code></pre>
<p>}<br>答：执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。</p>
<p>提示：如果不能给出此题的正确答案，说明之前第21题Java类加载机制还没有完全理解，赶紧再看看吧。</p>
<h3 id="38、数据类型之间的转换"><a href="#38、数据类型之间的转换" class="headerlink" title="38、数据类型之间的转换"></a>38、数据类型之间的转换</h3><p>如何将字符串转换为基本数据类型？<br>  答：调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本数据类型。<br>如何将基本数据类型转换为字符串？<br>  答：一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf()方法返回相应字符串。</p>
<h3 id="39、如何实现字符串的反转及替换？"><a href="#39、如何实现字符串的反转及替换？" class="headerlink" title="39、如何实现字符串的反转及替换？"></a>39、如何实现字符串的反转及替换？</h3><p>答：方法很多，可以自己写实现也可以使用String或StringBuffer&#x2F;StringBuilder中的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示：</p>
<pre><code class="hljs">public static String reverse(String originStr) &#123;
    if (originStr == null || originStr.length() &lt;= 1)
        return originStr;
    return reverse(originStr.substring(1)) + originStr.charAt(0);
&#125;
</code></pre>
<h3 id="40、怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"><a href="#40、怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？" class="headerlink" title="40、怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"></a>40、怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</h3><p>答：代码如下所示：</p>
<p>String s1 &#x3D; “你好”;<br>String s2 &#x3D; new String(s1.getBytes(“GB2312”), “ISO-8859-1”);</p>
<h3 id="41、日期和时间"><a href="#41、日期和时间" class="headerlink" title="41、日期和时间"></a>41、日期和时间</h3><p>如何取得年月日、小时分钟秒？<br>如何取得从1970年1月1日0时0分0秒到现在的毫秒数？<br>如何取得某月的最后一天？<br>如何格式化日期？<br>答：<br>问题1：创建java.util.Calendar实例，调用其get()方法传入不同的参数即可获得参数所对应的值。<br>Java 8中可以使用java.time.LocalDateTimel来获取，代码如下所示。<br>public class DateTimeTest {<br>    public static void main(String[] args) {<br>        Calendar cal &#x3D; Calendar.getInstance();<br>        System.out.println(cal.get(Calendar.YEAR));<br>        System.out.println(cal.get(Calendar.MONTH)); &#x2F;&#x2F; 0 - 11<br>        System.out.println(cal.get(Calendar.DATE));<br>        System.out.println(cal.get(Calendar.HOUR_OF_DAY));<br>        System.out.println(cal.get(Calendar.MINUTE));<br>        System.out.println(cal.get(Calendar.SECOND));</p>
<pre><code class="hljs">    // Java 8
    LocalDateTime dt = LocalDateTime.now();
    System.out.println(dt.getYear());
    System.out.println(dt.getMonthValue()); // 1 - 12
    System.out.println(dt.getDayOfMonth());
    System.out.println(dt.getHour());
    System.out.println(dt.getMinute());
    System.out.println(dt.getSecond());
&#125;
</code></pre>
<p>}<br>问题2：以下方法均可获得该毫秒数。</p>
<pre><code class="hljs">Calendar.getInstance().getTimeInMillis();
System.currentTimeMillis();
Clock.systemDefaultZone().millis(); // Java 8
</code></pre>
<p>问题3：代码如下所示。</p>
<pre><code class="hljs">Calendar time = Calendar.getInstance();
time.getActualMaximum(Calendar.DAY_OF_MONTH);
</code></pre>
<p>问题4：利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化。Java 8中可以用java.time.format.DateTimeFormatter来格式化时间日期，代码如下所示。</p>
<p>import java.text.SimpleDateFormat;<br>import java.time.LocalDate;<br>import java.time.format.DateTimeFormatter;<br>import java.util.Date;</p>
<p>class DateFormatTest {</p>
<pre><code class="hljs">public static void main(String[] args) &#123;
    SimpleDateFormat oldFormatter = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;);
    Date date1 = new Date();
    System.out.println(oldFormatter.format(date1));
 
    // Java 8
    DateTimeFormatter newFormatter = DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd&quot;);
    LocalDate date2 = LocalDate.now();
    System.out.println(date2.format(newFormatter));
&#125;
</code></pre>
<p>}<br>补充：Java的时间日期API一直以来都是被诟病的东西，为了解决这一问题，Java 8中引入了新的时间日期API，其中包括LocalDate、LocalTime、LocalDateTime、Clock、Instant等类，这些的类的设计都使用了不变模式，因此是线程安全的设计。如果不理解这些内容，可以参考我的另一篇文章《关于Java并发编程的总结和思考》。</p>
<h3 id="42、打印昨天的当前时刻。"><a href="#42、打印昨天的当前时刻。" class="headerlink" title="42、打印昨天的当前时刻。"></a>42、打印昨天的当前时刻。</h3><p>import java.util.Calendar;</p>
<p>class YesterdayCurrent {<br>    public static void main(String[] args){<br>        Calendar cal &#x3D; Calendar.getInstance();<br>        cal.add(Calendar.DATE, -1);<br>        System.out.println(cal.getTime());<br>    }<br>}<br>在Java 8中，可以用下面的代码实现相同的功能。</p>
<p>import java.time.LocalDateTime;</p>
<p>class YesterdayCurrent {</p>
<pre><code class="hljs">public static void main(String[] args) &#123;
    LocalDateTime today = LocalDateTime.now();
    LocalDateTime yesterday = today.minusDays(1);
 
    System.out.println(yesterday);
&#125;
</code></pre>
<p>}</p>
<h3 id="43、比较一下Java和JavaSciprt。"><a href="#43、比较一下Java和JavaSciprt。" class="headerlink" title="43、比较一下Java和JavaSciprt。"></a>43、比较一下Java和JavaSciprt。</h3><p>答：JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun Microsystems公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言。JavaScript的前身是LiveScript；而Java的前身是Oak语言。<br>下面对两种语言间的异同作如下比较：</p>
<p>基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。<br>解释和编译：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率）<br>强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。<br>代码格式不一样。</p>
<p>补充：上面列出的四点是网上流传的所谓的标准答案。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民，因此JavaScript支持函数式编程，可以使用Lambda函数和闭包（closure），当然Java 8也开始支持函数式编程，提供了对Lambda表达式以及函数式接口的支持。对于这类问题，在面试的时候最好还是用自己的语言回答会更加靠谱，不要背网上所谓的标准答案。</p>
<h3 id="44、什么时候用断言（assert）？"><a href="#44、什么时候用断言（assert）？" class="headerlink" title="44、什么时候用断言（assert）？"></a>44、什么时候用断言（assert）？</h3><p>答：断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式的值为false，那么系统会报告一个AssertionError。断言的使用如下面的代码所示：</p>
<p>assert(a &gt; 0); &#x2F;&#x2F; throws an AssertionError if a &lt;&#x3D; 0</p>
<p>断言可以有两种形式：<br>  assert Expression1;<br>  assert Expression1 : Expression2 ;<br>Expression1 应该总是产生一个布尔值。<br>Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。</p>
<p>要在运行时启用断言，可以在启动JVM时使用-enableassertions或者-ea标记。要在运行时选择禁用断言，可以在启动JVM时使用-da或者-disableassertions标记。要在系统类中启用或禁用断言，可使用-esa或-dsa标记。还可以在包的基础上启用或者禁用断言。</p>
<p>注意：断言不应该以任何方式改变程序的状态。简单的说，如果希望在不满足某些条件时阻止代码的执行，就可以考虑用断言来阻止它。</p>
<h3 id="45、Error和Exception有什么区别？"><a href="#45、Error和Exception有什么区别？" class="headerlink" title="45、Error和Exception有什么区别？"></a>45、Error和Exception有什么区别？</h3><p>答：Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。</p>
<p>面试题：2005年摩托罗拉的面试中曾经问过这么一个问题“If a process reports a stack overflow run-time error, what’s the most possible cause?”，给了四个选项a. lack of memory; b. write on an invalid memory space; c. recursive function calling; d. array index out of boundary. Java程序在运行时也可能会遭遇StackOverflowError，这是一个无法恢复的错误，只能重新修改代码了，这个面试题的答案是c。如果写了不能迅速收敛的递归，则很有可能引发栈溢出的错误，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StackOverflowErrorTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    	main(<span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>提示：用递归编写程序时一定要牢记两点：1. 递归公式；2. 收敛条件（什么时候就不再继续递归）。</p>
<h3 id="46、try-里有一个return语句，那么紧跟在这个try后的finally-里的代码会不会被执行，什么时候被执行，在return前还是后？"><a href="#46、try-里有一个return语句，那么紧跟在这个try后的finally-里的代码会不会被执行，什么时候被执行，在return前还是后？" class="headerlink" title="46、try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后？"></a>46、try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后？</h3><p>答：会执行，在方法返回调用者前执行。</p>
<p>注意：在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，就会返回修改后的值。显然，在finally中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java中也可以通过提升编译器的语法检查级别来产生警告或错误，Eclipse中可以在如图所示的地方进行设置，强烈建议将此项设置为编译错误。</p>
<h3 id="47、Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"><a href="#47、Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？" class="headerlink" title="47、Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"></a>47、Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？</h3><p>答：Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try用来指定一块预防所有异常的程序；catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；throw语句用来明确地抛出一个异常；throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally为确保一段代码不管发生什么异常状况都要被执行；try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。</p>
<h3 id="48、运行时异常与受检异常有何异同？"><a href="#48、运行时异常与受检异常有何异同？" class="headerlink" title="48、运行时异常与受检异常有何异同？"></a>48、运行时异常与受检异常有何异同？</h3><p>答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在《Effective Java》中对异常的使用给出了以下指导原则：</p>
<p>不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）<br>对可以恢复的情况使用受检异常，对编程错误使用运行时异常<br>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）<br>优先使用标准的异常<br>每个方法抛出的异常都要有文档<br>保持异常的原子性<br>不要在catch中忽略掉捕获到的异常</p>
<h3 id="49、列出一些你常见的运行时异常？"><a href="#49、列出一些你常见的运行时异常？" class="headerlink" title="49、列出一些你常见的运行时异常？"></a>49、列出一些你常见的运行时异常？</h3><p>答：</p>
<p>ArithmeticException（算术异常）<br>ClassCastException （类转换异常）<br>IllegalArgumentException （非法参数异常）<br>IndexOutOfBoundsException （下标越界异常）<br>NullPointerException （空指针异常）<br>SecurityException （安全异常）</p>
<h3 id="50、阐述final、finally、finalize的区别。"><a href="#50、阐述final、finally、finalize的区别。" class="headerlink" title="50、阐述final、finally、finalize的区别。"></a>50、阐述final、finally、finalize的区别。</h3><p>答：</p>
<p>final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final的方法也同样只能使用，不能在子类中被重写。<br>finally：通常放在try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。<br>finalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。<br>————————————————<br>版权声明：本文为CSDN博主「Java程序员-张凯」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41701956/article/details/86686492">https://blog.csdn.net/qq_41701956/article/details/86686492</a></p>
<h3 id="51、类ExampleA继承Exception，类ExampleB继承ExampleA。"><a href="#51、类ExampleA继承Exception，类ExampleB继承ExampleA。" class="headerlink" title="51、类ExampleA继承Exception，类ExampleB继承ExampleA。"></a>51、类ExampleA继承Exception，类ExampleB继承ExampleA。</h3><p>有如下代码片断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExampleB</span>(<span class="hljs-string">&quot;b&quot;</span>)<br>&#125; <span class="hljs-keyword">catch</span>（ExampleA e）&#123;<br>    System.out.println(<span class="hljs-string">&quot;ExampleA&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span>（Exception e）&#123;<br>    System.out.println(<span class="hljs-string">&quot;Exception&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>请问执行此段代码的输出是什么？<br>答：输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取ExampleA类型异常的catch块能够抓住try块中抛出的ExampleB类型的异常）</p>
<p>面试题：说出下面代码的运行结果。（此题的出处是《Java编程思想》一书）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>            &#125; <br>            <span class="hljs-keyword">catch</span> (A a) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Caught A&quot;</span>);<br>                <span class="hljs-keyword">throw</span> a;<br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">catch</span> (B b) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Caught B&quot;</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序输出结果为：</p>
<p>Caught A<br>Caught B<br>Hello World!</p>
<h3 id="52、List、Set、Map是否继承自Collection接口？"><a href="#52、List、Set、Map是否继承自Collection接口？" class="headerlink" title="52、List、Set、Map是否继承自Collection接口？"></a>52、List、Set、Map是否继承自Collection接口？</h3><p>答：List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。</p>
<h3 id="53、阐述ArrayList、Vector、LinkedList的存储性能和特性。"><a href="#53、阐述ArrayList、Vector、LinkedList的存储性能和特性。" class="headerlink" title="53、阐述ArrayList、Vector、LinkedList的存储性能和特性。"></a>53、阐述ArrayList、Vector、LinkedList的存储性能和特性。</h3><p>答：ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。</p>
<p>补充：遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是Has-A关系而不是Is-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是Has-A关系（关联）或Use-A关系（依赖）。同理，Stack类继承Vector也是不正确的。Sun公司的工程师们也会犯这种低级错误，让人唏嘘不已。</p>
<h3 id="54、Collection和Collections的区别？"><a href="#54、Collection和Collections的区别？" class="headerlink" title="54、Collection和Collections的区别？"></a>54、Collection和Collections的区别？</h3><p>答：Collection是一个接口，它是Set、List等容器的父接口；Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。</p>
<h3 id="55、List、Map、Set三个接口存取元素时，各有什么特点？"><a href="#55、List、Map、Set三个接口存取元素时，各有什么特点？" class="headerlink" title="55、List、Map、Set三个接口存取元素时，各有什么特点？"></a>55、List、Map、Set三个接口存取元素时，各有什么特点？</h3><p>答：List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</p>
<h3 id="56、TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？"><a href="#56、TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？" class="headerlink" title="56、TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？"></a>56、TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</h3><p>答：TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持）。</p>
<h3 id="57、Thread类的-sleep-方法和对象的-wait-方法都可以让线程暂停执行，它们有什么区别？"><a href="#57、Thread类的-sleep-方法和对象的-wait-方法都可以让线程暂停执行，它们有什么区别？" class="headerlink" title="57、Thread类的 sleep() 方法和对象的 wait() 方法都可以让线程暂停执行，它们有什么区别？"></a>57、Thread类的 sleep() 方法和对象的 wait() 方法都可以让线程暂停执行，它们有什么区别？</h3><p>答：sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</p>
<p>补充：可能不少人对什么是进程，什么是线程还比较模糊，对于为什么需要多线程编程也不是特别理解。简单的说：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的CPU资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费CPU时间。时下很时髦的Node.js就采用了单线程异步I&#x2F;O的工作模式。</p>
<h3 id="58、线程的-sleep-方法和-yield-方法有什么区别？"><a href="#58、线程的-sleep-方法和-yield-方法有什么区别？" class="headerlink" title="58、线程的 sleep() 方法和 yield() 方法有什么区别？"></a>58、线程的 sleep() 方法和 yield() 方法有什么区别？</h3><p>答：1、sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；<br>2、 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；<br>3、sleep()方法声明抛出 InterruptedException，而 yield() 方法没有声明任何异常；<br>4、sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。</p>
<h3 id="59、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"><a href="#59、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？" class="headerlink" title="59、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"></a>59、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？</h3><p>答：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</p>
<h3 id="60、请说出与线程同步以及线程调度相关的方法。"><a href="#60、请说出与线程同步以及线程调度相关的方法。" class="headerlink" title="60、请说出与线程同步以及线程调度相关的方法。"></a>60、请说出与线程同步以及线程调度相关的方法。</h3><p>答：wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；<br>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常；<br>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；<br>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态。<br>提示：关于Java多线程和并发编程的问题，建议大家看我的另一篇文章《关于Java并发编程的总结和思考》。<br>补充：Java 5通过Lock接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了newCondition()方法来产生用于线程之间通信的Condition对象；此外，Java 5还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用Semaphore对象的acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用Semaphore对象的release()方法）。</p>
<h3 id="61、编写多线程程序有几种实现方式？"><a href="#61、编写多线程程序有几种实现方式？" class="headerlink" title="61、编写多线程程序有几种实现方式？"></a>61、编写多线程程序有几种实现方式？</h3><p>答：Java 5以前实现多线程有两种实现方法：一种是继承Thread类；另一种是实现Runnable接口。两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。</p>
<p>补充：Java 5以后创建线程还有第三种方式：实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值。</p>
<h3 id="62、synchronized-关键字的用法？"><a href="#62、synchronized-关键字的用法？" class="headerlink" title="62、synchronized 关键字的用法？"></a>62、synchronized 关键字的用法？</h3><p>答：synchronized关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用synchronized(对象) { … }定义同步代码块，或者在声明方法时将synchronized作为方法的修饰符。</p>
<h3 id="63、举例说明同步和异步。"><a href="#63、举例说明同步和异步。" class="headerlink" title="63、举例说明同步和异步。"></a>63、举例说明同步和异步。</h3><p>答：如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。</p>
<h3 id="64、启动一个线程是调用run-还是start-方法？"><a href="#64、启动一个线程是调用run-还是start-方法？" class="headerlink" title="64、启动一个线程是调用run()还是start()方法？"></a>64、启动一个线程是调用run()还是start()方法？</h3><p>答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。</p>
<h3 id="65、什么是线程池（thread-pool）？"><a href="#65、什么是线程池（thread-pool）？" class="headerlink" title="65、什么是线程池（thread pool）？"></a>65、什么是线程池（thread pool）？</h3><p>答：在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。</p>
<p>Java 5+中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是 ExecutorService 。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 里面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：</p>
<p>newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。<br>newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。<br>newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。<br>newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。<br>newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
<h3 id="66、线程的基本状态以及状态之间的关系？"><a href="#66、线程的基本状态以及状态之间的关系？" class="headerlink" title="66、线程的基本状态以及状态之间的关系？"></a>66、线程的基本状态以及状态之间的关系？</h3><p>答：说明：其中Running表示运行状态，Runnable表示就绪状态（万事俱备，只欠CPU），Blocked表示阻塞状态，阻塞状态又有多种情况，可能是因为调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I&#x2F;O中断。</p>
<h3 id="67、简述-synchronized-和-java-util-concurrent-locks-Lock-的异同？"><a href="#67、简述-synchronized-和-java-util-concurrent-locks-Lock-的异同？" class="headerlink" title="67、简述 synchronized 和 java.util.concurrent.locks.Lock 的异同？"></a>67、简述 synchronized 和 java.util.concurrent.locks.Lock 的异同？</h3><p>答：Lock是Java 5以后引入的新的API，和关键字synchronized相比主要相同点：Lock 能完成synchronized所实现的所有功能；主要不同点：Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且最好在finally 块中释放（这是释放外部资源的最好的地方）。</p>
<h3 id="68、Java-中如何实现序列化，有什么意义？"><a href="#68、Java-中如何实现序列化，有什么意义？" class="headerlink" title="68、Java 中如何实现序列化，有什么意义？"></a>68、Java 中如何实现序列化，有什么意义？</h3><p>答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。</p>
<p>要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆（可以参考第29题）。</p>
<h3 id="69、Java-中有几种类型的流？"><a href="#69、Java-中有几种类型的流？" class="headerlink" title="69、Java 中有几种类型的流？"></a>69、Java 中有几种类型的流？</h3><p>答：字节流和字符流。字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。关于Java的I&#x2F;O需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外Java中的流不同于C#的是它只有一个维度一个方向。</p>
<p>面试题：编程实现文件拷贝。（这个题目在笔试的时候经常出现，下面的代码给出了两种实现方案）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyUtil</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MyUtil</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fileCopy</span><span class="hljs-params">(String source, String target)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(source)) &#123;<br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(target)) &#123;<br>                <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">4096</span>];<br>                <span class="hljs-type">int</span> bytesToRead;<br>                <span class="hljs-keyword">while</span>((bytesToRead = in.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>                    out.write(buffer, <span class="hljs-number">0</span>, bytesToRead);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fileCopyNIO</span><span class="hljs-params">(String source, String target)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(source)) &#123;<br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(target)) &#123;<br>                <span class="hljs-type">FileChannel</span> <span class="hljs-variable">inChannel</span> <span class="hljs-operator">=</span> in.getChannel();<br>                <span class="hljs-type">FileChannel</span> <span class="hljs-variable">outChannel</span> <span class="hljs-operator">=</span> out.getChannel();<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4096</span>);<br>                <span class="hljs-keyword">while</span>(inChannel.read(buffer) != -<span class="hljs-number">1</span>) &#123;<br>                    buffer.flip();<br>                    outChannel.write(buffer);<br>                    buffer.clear();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>注意：上面用到Java 7的TWR，使用TWR后可以不用在finally中释放外部资源 ，从而让代码更加优雅。</p>
<h3 id="70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。"><a href="#70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。" class="headerlink" title="70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。"></a>70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。</h3><p>详解如下：</p>
<p>import java.io.BufferedReader;<br>import java.io.FileReader;</p>
<p>public final class MyUtil {</p>
<pre><code class="hljs">// 工具类中的方法都是静态方式访问的因此将构造器私有不允许创建对象(绝对好习惯)
private MyUtil() &#123;
    throw new AssertionError();
&#125;
 
/**
 * 统计给定文件中给定字符串的出现次数
 * 
 * @param filename  文件名
 * @param word 字符串
 * @return 字符串在文件中出现的次数
 */
public static int countWordInFile(String filename, String word) &#123;
    int counter = 0;
    try (FileReader fr = new FileReader(filename)) &#123;
        try (BufferedReader br = new BufferedReader(fr)) &#123;
            String line = null;
            while ((line = br.readLine()) != null) &#123;
                int index = -1;
                while (line.length() &gt;= word.length() &amp;&amp; (index = line.indexOf(word)) &gt;= 0) &#123;
                    counter++;
                    line = line.substring(index + word.length());
                &#125;
            &#125;
        &#125;
    &#125; catch (Exception ex) &#123;
        ex.printStackTrace();
    &#125;
    return counter;
&#125;
</code></pre>
<p>}</p>
<h3 id="71、如何用Java代码列出一个目录下所有的文件？"><a href="#71、如何用Java代码列出一个目录下所有的文件？" class="headerlink" title="71、如何用Java代码列出一个目录下所有的文件？"></a>71、如何用Java代码列出一个目录下所有的文件？</h3><p>详解如下：</p>
<p>如果只要求列出当前文件夹下的文件，代码如下所示：</p>
<p>import java.io.File;</p>
<p>class Test12 {</p>
<pre><code class="hljs">public static void main(String[] args) &#123;
    File f = new File(&quot;/Users/Hao/Downloads&quot;);
    for(File temp : f.listFiles()) &#123;
        if(temp.isFile()) &#123;
            System.out.println(temp.getName());
        &#125;
    &#125;
&#125;
</code></pre>
<p>}<br>如果需要对文件夹继续展开，代码如下所示：</p>
<p>import java.io.File;</p>
<p>class Test12 {</p>
<pre><code class="hljs">public static void main(String[] args) &#123;
    showDirectory(new File(&quot;/Users/Hao/Downloads&quot;));
&#125;
 
public static void showDirectory(File f) &#123;
    _walkDirectory(f, 0);
&#125;
 
private static void _walkDirectory(File f, int level) &#123;
    if(f.isDirectory()) &#123;
        for(File temp : f.listFiles()) &#123;
            _walkDirectory(temp, level + 1);
        &#125;
    &#125;
    else &#123;
        for(int i = 0; i &lt; level - 1; i++) &#123;
            System.out.print(&quot;\t&quot;);
        &#125;
        System.out.println(f.getName());
    &#125;
&#125;
</code></pre>
<p>}<br> 在Java 7中可以使用NIO.2的API来做同样的事情，代码如下所示：</p>
<p>class ShowFileTest {</p>
<pre><code class="hljs">public static void main(String[] args) throws IOException &#123;
    Path initPath = Paths.get(&quot;/Users/Hao/Downloads&quot;);
    Files.walkFileTree(initPath, new SimpleFileVisitor&lt;Path&gt;() &#123;
 
        @Override
        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) 
                throws IOException &#123;
            System.out.println(file.getFileName().toString());
            return FileVisitResult.CONTINUE;
        &#125;
 
    &#125;);
&#125;
</code></pre>
<p>}</p>
<h3 id="72、用Java的套接字编程实现一个多线程的回显（echo）服务器。"><a href="#72、用Java的套接字编程实现一个多线程的回显（echo）服务器。" class="headerlink" title="72、用Java的套接字编程实现一个多线程的回显（echo）服务器。"></a>72、用Java的套接字编程实现一个多线程的回显（echo）服务器。</h3><p>详解如下：</p>
<p>import java.io.BufferedReader;<br>import java.io.IOException;<br>import java.io.InputStreamReader;<br>import java.io.PrintWriter;<br>import java.net.ServerSocket;<br>import java.net.Socket;</p>
<p>public class EchoServer {</p>
<pre><code class="hljs">private static final int ECHO_SERVER_PORT = 6789;
 
public static void main(String[] args) &#123;        
    try(ServerSocket server = new ServerSocket(ECHO_SERVER_PORT)) &#123;
        System.out.println(&quot;服务器已经启动...&quot;);
        while(true) &#123;
            Socket client = server.accept();
            new Thread(new ClientHandler(client)).start();
        &#125;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125;
&#125;
 
private static class ClientHandler implements Runnable &#123;
    private Socket client;
 
    public ClientHandler(Socket client) &#123;
        this.client = client;
    &#125;
 
    @Override
    public void run() &#123;
        try(BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));
                PrintWriter pw = new PrintWriter(client.getOutputStream())) &#123;
            String msg = br.readLine();
            System.out.println(&quot;收到&quot; + client.getInetAddress() + &quot;发送的: &quot; + msg);
            pw.println(msg);
            pw.flush();
        &#125; catch(Exception ex) &#123;
            ex.printStackTrace();
        &#125; finally &#123;
            try &#123;
                client.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>}<br>注意：上面的代码使用了Java 7的TWR语法，由于很多外部资源类都间接的实现了AutoCloseable接口（单方法回调接口），因此可以利用TWR语法在try结束的时候通过回调的方式自动调用外部资源类的close()方法，避免书写冗长的finally代码块。此外，上面的代码用一个静态内部类实现线程的功能，使用多线程可以避免一个用户I&#x2F;O操作所产生的中断影响其他用户对服务器的访问，简单的说就是一个用户的输入操作不会造成其他用户的阻塞。当然，上面的代码使用线程池可以获得更好的性能，因为频繁的创建和销毁线程所造成的开销也是不可忽视的。</p>
<h3 id="73、XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？"><a href="#73、XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？" class="headerlink" title="73、XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？"></a>73、XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？</h3><p>答：XML文档定义分为DTD和Schema两种形式，二者都是对XML语法的约束，其本质区别在于Schema本身也是一个XML文件，可以被XML解析器解析，而且可以为XML承载的数据定义类型，约束能力较之DTD更强大。对XML的解析主要有DOM（文档对象模型，Document Object Model）、SAX（Simple API for XML）和StAX（Java 6中引入的新的解析XML的方式，Streaming API for XML），其中DOM处理大型文件时其性能下降的非常厉害，这个问题是由DOM树结构占用的内存较多造成的，而且DOM解析方式必须在解析文件之前把整个文档装入内存，适合对XML的随机访问（典型的用空间换取时间的策略）；SAX是事件驱动型的XML解析方式，它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过事件回调代码来处理XML文件，适合对XML的顺序访问；顾名思义，StAX把重点放在流上，实际上StAX与其他解析方式的本质区别就在于应用程序能够把XML作为一个事件流来处理。将XML作为一组事件来处理的想法并不新颖（SAX就是这样做的），但不同之处在于StAX允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。</p>
<h3 id="74、你在项目中哪些地方用到了XML？"><a href="#74、你在项目中哪些地方用到了XML？" class="headerlink" title="74、你在项目中哪些地方用到了XML？"></a>74、你在项目中哪些地方用到了XML？</h3><p>答：XML的主要作用有两个方面：数据交换和信息配置。在做数据交换时，XML将数据用标签组装成起来，然后压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再从XML文件中还原相关信息进行处理，XML曾经是异构系统间交换数据的事实标准，但此项功能几乎已经被JSON（JavaScript Object Notation）取而代之。当然，目前很多软件仍然使用XML来存储配置信息，我们在很多项目中通常也会将作为配置信息的硬代码写在XML文件中，Java的很多框架也是这么做的，而且这些框架都选择了dom4j作为处理XML的工具，因为Sun公司的官方API实在不怎么好用。</p>
<p>补充：现在有很多时髦的软件（如Sublime）已经开始将配置文件书写成JSON格式，我们已经强烈的感受到XML的另一项功能也将逐渐被业界抛弃。</p>
<h3 id="75、阐述JDBC操作数据库的步骤。"><a href="#75、阐述JDBC操作数据库的步骤。" class="headerlink" title="75、阐述JDBC操作数据库的步骤。"></a>75、阐述JDBC操作数据库的步骤。</h3><p>答：下面的代码以连接本机的Oracle数据库为例，演示JDBC操作数据库的步骤。<br>加载驱动。</p>
<pre><code class="hljs">Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);
</code></pre>
<p>创建连接。</p>
<pre><code class="hljs">Connection con = DriverManager.getConnection(&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;, &quot;scott&quot;, &quot;tiger&quot;);
</code></pre>
<p>创建语句。</p>
<pre><code class="hljs">PreparedStatement ps = con.prepareStatement(&quot;select * from emp where sal between ? and ?&quot;);
ps.setInt(1, 1000);
ps.setInt(2, 3000);
</code></pre>
<p>执行语句。</p>
<pre><code class="hljs">ResultSet rs = ps.executeQuery();
</code></pre>
<p>处理结果。</p>
<pre><code class="hljs">while(rs.next()) &#123;
    System.out.println(rs.getInt(&quot;empno&quot;) + &quot; --- &quot; + rs.getString(&quot;ename&quot;));
&#125;
</code></pre>
<p>关闭资源。</p>
<pre><code class="hljs">finally &#123;
    if(con != null) &#123;
        try &#123;
            con.close();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>提示：关闭外部资源的顺序应该和打开的顺序相反，也就是说先关闭ResultSet、再关闭Statement、再关闭Connection。上面的代码只关闭了Connection（连接），虽然通常情况下在关闭连接时，连接上创建的语句和打开的游标也会关闭，但不能保证总是如此，因此应该按照刚才说的顺序分别关闭。此外，第一步加载驱动在JDBC 4.0中是可以省略的（自动从类路径中加载驱动），但是我们建议保留。</p>
<h3 id="76、Statement和PreparedStatement有什么区别？哪个性能更好？"><a href="#76、Statement和PreparedStatement有什么区别？哪个性能更好？" class="headerlink" title="76、Statement和PreparedStatement有什么区别？哪个性能更好？"></a>76、Statement和PreparedStatement有什么区别？哪个性能更好？</h3><p>答：与Statement相比，1）PreparedStatement接口代表预编译的语句，它主要的优势在于可以减少SQL的编译错误并增加SQL的安全性（减少SQL注射攻击的可能性）；2）PreparedStatement中的SQL语句是可以带参数的，避免了用字符串连接拼接SQL语句的麻烦和不安全；3）当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。</p>
<p>补充：为了提供对存储过程的调用，JDBC API中还提供了CallableStatement接口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的SQL语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。</p>
<h3 id="77、使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？"><a href="#77、使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？" class="headerlink" title="77、使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？"></a>77、使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？</h3><p>答：要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的setFetchSize()方法指定每次抓取的记录数（典型的空间换时间策略）；要提升更新数据的性能可以使用PreparedStatement语句构建批处理，将若干SQL语句置于一个批处理中执行。</p>
<h3 id="78、在进行数据库编程时，连接池有什么作用？"><a href="#78、在进行数据库编程时，连接池有什么作用？" class="headerlink" title="78、在进行数据库编程时，连接池有什么作用？"></a>78、在进行数据库编程时，连接池有什么作用？</h3><p>答：由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，释放连接需要进行TCP四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在Java开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于Java的开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid等。</p>
<p>补充：在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对于这个问题的讨论已经超出了这里要阐述的范围。</p>
<h3 id="79、什么是DAO模式？"><a href="#79、什么是DAO模式？" class="headerlink" title="79、什么是DAO模式？"></a>79、什么是DAO模式？</h3><p>答：DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。</p>
<h3 id="80、事务的ACID是指什么？"><a href="#80、事务的ACID是指什么？" class="headerlink" title="80、事务的ACID是指什么？"></a>80、事务的ACID是指什么？</h3><p>答：</p>
<p>原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败；<br>一致性(Consistent)：事务结束后系统状态是一致的；<br>隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态；<br>持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。<br>补充：关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。首先需要知道的是，只有存在并发数据访问时才需要事务。当多个事务访问同一数据时，可能会存在5类问题，包括3类数据读取问题（脏读、不可重复读和幻读）和2类数据更新问题（第1类丢失更新和第2类丢失更新）。</p>
<p>脏读（Dirty Read）：A事务读取B事务尚未提交的数据并在此基础上操作，而B事务执行回滚，那么A读取到的数据就是脏数据。</p>
<p>不可重复读（Unrepeatable Read）：事务A重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务B修改过了。</p>
<p>幻读（Phantom Read）：事务A重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了被事务B提交的行。</p>
<p>第1类丢失更新：事务A撤销时，把已经提交的事务B的更新数据覆盖了。</p>
<p>第2类丢失更新：事务A覆盖事务B已经提交的数据，造成事务B所做的操作丢失。</p>
<p>数据并发访问所产生的问题，在有些场景下可能是允许的，但是有些场景下可能就是致命的，数据库通常会通过锁机制来解决数据并发访问问题，按锁定对象不同可以分为表级锁和行级锁；按并发事务锁定关系可以分为共享锁和独占锁，具体的内容大家可以自行查阅资料进行了解。</p>
<p>直接使用锁是非常麻烦的，为此数据库为用户提供了自动锁机制，只要用户指定会话的事务隔离级别，数据库就会通过分析SQL语句然后为事务访问的资源加上合适的锁，此外，数据库还会维护这些锁通过各种手段提高系统的性能，这些对用户来说都是透明的（就是说你不用理解，事实上我确实也不知道）。ANSI&#x2F;ISO SQL 92标准定义了4个等级的事务隔离级别，如下表所示：</p>
<p>需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。</p>
<h3 id="81、JDBC中如何进行事务处理？"><a href="#81、JDBC中如何进行事务处理？" class="headerlink" title="81、JDBC中如何进行事务处理？"></a>81、JDBC中如何进行事务处理？</h3><p>答：Connection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务；当事务完成后用commit()显式提交事务；如果在事务处理过程中发生异常则通过rollback()进行事务回滚。除此之外，从JDBC 3.0中还引入了Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。</p>
<h3 id="82、JDBC能否处理Blob和Clob？"><a href="#82、JDBC能否处理Blob和Clob？" class="headerlink" title="82、JDBC能否处理Blob和Clob？"></a>82、JDBC能否处理Blob和Clob？</h3><p>答： Blob是指二进制大对象（Binary Large Object），而Clob是指大字符对象（Character Large Objec），因此其中Blob是为存储大的二进制数据而设计的，而Clob是为存储大的文本数据而设计的。JDBC的PreparedStatement和ResultSet都提供了相应的方法来支持Blob和Clob操作。下面的代码展示了如何使用JDBC操作LOB：<br>下面以MySQL数据库为例，创建一个张有三个字段的用户表，包括编号（id）、姓名（name）和照片（photo），建表语句如下：</p>
<p>create table tb_user<br>(<br>    id int primary key auto_increment,<br>    name varchar(20) unique not null,<br>    photo longblob<br>);<br>下面的Java代码向数据库中插入一条记录：</p>
<p>import java.io.FileInputStream;<br>import java.io.IOException;<br>import java.io.InputStream;<br>import java.sql.Connection;<br>import java.sql.DriverManager;<br>import java.sql.PreparedStatement;<br>import java.sql.SQLException;</p>
<p>class JdbcLobTest {</p>
<pre><code class="hljs">public static void main(String[] args) &#123;
    Connection con = null;
    try &#123;
        // 1. 加载驱动（Java6以上版本可以省略）
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        // 2. 建立连接
        con = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;123456&quot;);
        // 3. 创建语句对象
        PreparedStatement ps = con.prepareStatement(&quot;insert into tb_user values (default, ?, ?)&quot;);
        ps.setString(1, &quot;骆昊&quot;);              // 将SQL语句中第一个占位符换成字符串
        try (InputStream in = new FileInputStream(&quot;test.jpg&quot;)) &#123;    // Java 7的TWR
            ps.setBinaryStream(2, in);      // 将SQL语句中第二个占位符换成二进制流
            // 4. 发出SQL语句获得受影响行数
            System.out.println(ps.executeUpdate() == 1 ? &quot;插入成功&quot; : &quot;插入失败&quot;);
        &#125; catch(IOException e) &#123;
            System.out.println(&quot;读取照片失败!&quot;);
        &#125;
    &#125; catch (ClassNotFoundException | SQLException e) &#123;     // Java 7的多异常捕获
        e.printStackTrace();
    &#125; finally &#123; // 释放外部资源的代码都应当放在finally中保证其能够得到执行
        try &#123;
            if(con != null &amp;&amp; !con.isClosed()) &#123;
                con.close();    // 5. 释放数据库连接 
                con = null;     // 指示垃圾回收器可以回收该对象
            &#125;
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>}<br>83、简述正则表达式及其用途。<br>答：在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p>
<p>说明：计算机诞生初期处理的信息几乎都是数值，但是时过境迁，今天我们使用计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支持。</p>
<h3 id="84、Java中是如何支持正则表达式操作的？"><a href="#84、Java中是如何支持正则表达式操作的？" class="headerlink" title="84、Java中是如何支持正则表达式操作的？"></a>84、Java中是如何支持正则表达式操作的？</h3><p>答：Java中的String类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，请参考下面面试题的代码。</p>
<p>面试题：如果要从字符串中截取第一个英文左括号之前的字符串，例如：北京市(朝阳区)(西城区)(海淀区)，截取结果为：北京市，那么正则表达式怎么写？</p>
<p>import java.util.regex.Matcher;<br>import java.util.regex.Pattern;</p>
<p>class RegExpTest {</p>
<pre><code class="hljs">public static void main(String[] args) &#123;
    String str = &quot;北京市(朝阳区)(西城区)(海淀区)&quot;;
    Pattern p = Pattern.compile(&quot;.*?(?=\\()&quot;);
    Matcher m = p.matcher(str);
    if(m.find()) &#123;
        System.out.println(m.group());
    &#125;
&#125;
</code></pre>
<p>}<br>说明：上面的正则表达式中使用了懒惰匹配和前瞻，如果不清楚这些内容，推荐读一下网上很有名的《正则表达式30分钟入门教程》。</p>
<h3 id="85、获得一个类的类对象有哪些方式？"><a href="#85、获得一个类的类对象有哪些方式？" class="headerlink" title="85、获得一个类的类对象有哪些方式？"></a>85、获得一个类的类对象有哪些方式？</h3><p>答：</p>
<p>方法1：类型.class，例如：String.class<br>方法2：对象.getClass()，例如：”hello”.getClass()<br>方法3：Class.forName()，例如：Class.forName(“java.lang.String”)</p>
<h3 id="86、如何通过反射创建对象？"><a href="#86、如何通过反射创建对象？" class="headerlink" title="86、如何通过反射创建对象？"></a>86、如何通过反射创建对象？</h3><p>答：</p>
<p>方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance()<br>方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”);</p>
<h3 id="87、如何通过反射获取和设置对象私有字段的值？"><a href="#87、如何通过反射获取和设置对象私有字段的值？" class="headerlink" title="87、如何通过反射获取和设置对象私有字段的值？"></a>87、如何通过反射获取和设置对象私有字段的值？</h3><p>答：可以通过类对象的getDeclaredField()方法字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过get&#x2F;set方法来获取&#x2F;设置字段的值了。下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如ReflectionUtil.get(dog, “owner.car.engine.id”);可以获得dog对象的主人的汽车的引擎的ID号。</p>
<p>import java.lang.reflect.Constructor;<br>import java.lang.reflect.Field;<br>import java.lang.reflect.Modifier;<br>import java.util.ArrayList;<br>import java.util.List;</p>
<p>&#x2F;**</p>
<ul>
<li><p>反射工具类</p>
</li>
<li><p>@author 骆昊</p>
</li>
<li><p>  *&#x2F;<br> public class ReflectionUtil {</p>
<p>  private ReflectionUtil() {<br>  throw new AssertionError();<br>  }</p>
<p>  &#x2F;**</p>
<ul>
<li><p>通过反射取对象指定字段(属性)的值</p>
</li>
<li><p>@param target 目标对象</p>
</li>
<li><p>@param fieldName 字段的名字</p>
</li>
<li><p>@throws 如果取不到对象指定字段的值则抛出异常</p>
</li>
<li><p>@return 字段的值<br>*&#x2F;<br>  public static Object getValue(Object target, String fieldName) {<br> Class&lt;?&gt; clazz &#x3D; target.getClass();<br> String[] fs &#x3D; fieldName.split(“\.”);</p>
<p> try {<br> for(int i &#x3D; 0; i &lt; fs.length - 1; i++) {<br>     Field f &#x3D; clazz.getDeclaredField(fs[i]);<br>     f.setAccessible(true);<br>     target &#x3D; f.get(target);<br>     clazz &#x3D; target.getClass();<br> }<br><br> Field f &#x3D; clazz.getDeclaredField(fs[fs.length - 1]);<br> f.setAccessible(true);<br> return f.get(target);<br> }<br> catch (Exception e) {<br> throw new RuntimeException(e);<br> }<br>  }</p>
</li>
</ul>
<p>  &#x2F;**</p>
<ul>
<li>通过反射给对象的指定字段赋值</li>
<li>@param target 目标对象</li>
<li>@param fieldName 字段的名称</li>
<li>@param value 值<br>*&#x2F;<br>public static void setValue(Object target, String fieldName, Object value) {<br> Class<?> clazz = target.getClass();
 String[] fs = fieldName.split("\\.");
 try {
 for(int i = 0; i < fs.length - 1; i++) {
     Field f = clazz.getDeclaredField(fs[i]);
     f.setAccessible(true);
     Object val = f.get(target);
     if(val == null) {
         Constructor<?> c &#x3D; f.getType().getDeclaredConstructor();<br>         c.setAccessible(true);<br>         val &#x3D; c.newInstance();<br>         f.set(target, val);<br>     }<br>     target &#x3D; val;<br>     clazz &#x3D; target.getClass();<br> }<br><br> Field f &#x3D; clazz.getDeclaredField(fs[fs.length - 1]);<br> f.setAccessible(true);<br> f.set(target, value);<br> }<br> catch (Exception e) {<br> throw new RuntimeException(e);<br> }<br>}<br>  }<br>  88、如何通过反射调用对象的方法？<br>  答：请看下面的代码：</li>
</ul>
</li>
</ul>
<p>import java.lang.reflect.Method;</p>
<p>class MethodInvokeTest {</p>
<pre><code class="hljs">public static void main(String[] args) throws Exception &#123;
    String str = &quot;hello&quot;;
    Method m = str.getClass().getMethod(&quot;toUpperCase&quot;);
    System.out.println(m.invoke(str));  // HELLO
&#125;
</code></pre>
<p>}</p>
<h3 id="89、简述一下面向对象的”六原则一法则”。"><a href="#89、简述一下面向对象的”六原则一法则”。" class="headerlink" title="89、简述一下面向对象的”六原则一法则”。"></a>89、简述一下面向对象的”六原则一法则”。</h3><p>答：</p>
<p>单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，就如同葵花宝典或辟邪剑谱的中心思想就八个字”欲练此功必先自宫”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫”因为专注，所以专业”，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）</p>
<p>开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：1）抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；2）封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）</p>
<p>依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）</p>
<p>里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）</p>
<p>接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）</p>
<p>合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）</p>
<p>迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。（迪米特法则简单的说就是如何做到”低耦合”，门面模式和调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来讲就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。）</p>
<h3 id="90、简述一下你了解的设计模式。"><a href="#90、简述一下你了解的设计模式。" class="headerlink" title="90、简述一下你了解的设计模式。"></a>90、简述一下你了解的设计模式。</h3><p>答：所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。<br>在GoF的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三类（创建型[对类的实例化过程的抽象化]、结构型[描述如何将类或对象结合在一起形成更大的结构]、行为型[对在不同的对象之间划分责任和算法的抽象化]）共23种设计模式，包括：Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibility（责任链模式）。</p>
<p>面试被问到关于设计模式的知识时，可以拣最常用的作答，例如：</p>
<p>工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。<br>代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache代理、防火墙代理、同步化代理、智能引用代理。<br>适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。<br>模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。<br>除此之外，还可以讲讲上面提到的门面模式、桥梁模式、单例模式、装潢模式（Collections工具类和I&#x2F;O系统中都使用装潢模式）等，反正基本原则就是拣自己最熟悉的、用得最多的作答，以免言多必失。</p>
<h3 id="91、用Java写一个单例类。"><a href="#91、用Java写一个单例类。" class="headerlink" title="91、用Java写一个单例类。"></a>91、用Java写一个单例类。</h3><p>答：</p>
<p>饿汉式单例<br>public class Student {</p>
<pre><code class="hljs">// 构造私有，外界就不能造对象了
private Student() &#123;
&#125;
 
// 在成员变量位置自己创建一个对象
// 静态方法只能访问静态成员变量，所以成员变量加静态修饰
// 为了不让外界直接访问修改这个成员变量的值，所以该成员变量加private修饰
private static Student s = new Student();
 
// 提供公共的访问方式，返回该对象。为了保证外界能够直接访问该方法，所以方法加静态修饰
public static Student getStudent() &#123;
    return s;
&#125;
</code></pre>
<p>}<br>懒汉式单例<br>public class Teacher {<br>    private Teacher() {<br>    }</p>
<pre><code class="hljs">private static Teacher t = null;
 
public static synchronized Teacher getTeacher() &#123;
    if (t == null) &#123;
        t = new Teacher();
    &#125;
    return t;
&#125;
</code></pre>
<p>}<br>注意：实现一个单例有两点注意事项，1）将构造器私有，不允许外界通过构造器创建对象；2）通过公开的静态方法向外界返回类的唯一实例。这里有一个问题可以思考：Spring的IoC容器可以为普通的类创建单例，它是怎么做到的呢？<br>1、Bean的简介<br>  在Spring中，那些组成应用程序的主体(backbone)及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由Spring容器初始化、装配及管理的对象，除此之外，bean就与应用程序中的其他对象没有什么区别了。而bean定义以及bean相互间的依赖关系将通过配置元数据来描述。<br>2、Bean的作用域<br>  创建一个bean定义，其实质是用该bean定义对应的类来创建真正实例的“配方(recipe)”。把bean定义看成一个配方很有意义，它与class很类似，只根据一张“处方”就可以创建多个实例。不仅可以控制注入到对象中的各种依赖和配置值，还可以控制该对象的作用域。这样可以灵活选择所建对象的作用域，而不必在Java Class级定义作用域。Spring Framework支持五种作用域（其中有三种只能用在基于web的Spring ApplicationContext）。<br>1）singleton<br>  当一个bean的作用域为singleton, 那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。<br>  注意：Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：<bean id="empServiceImpl" class="cn.csdn.service.EmpServiceImpl" scope="singleton"><br>2）prototype<br>  一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。<br>3）request<br>  在一次HTTP请求中，一个bean定义对应一个实例；即每次HTTP请求将会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：&lt;bean id&#x3D;”loginAction” class&#x3D;cn.csdn.LoginAction” scope&#x3D;”request”&#x2F;&gt;针对每次HTTP请求，Spring容器会根据loginAction的bean定义创建一个全新的LoginAction bean实例，且该loginAction的bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction的bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。 当处理请求结束，request作用域的bean实例将被销毁。</p>
<h3 id="92、什么是UML？"><a href="#92、什么是UML？" class="headerlink" title="92、什么是UML？"></a>92、什么是UML？</h3><p>答：UML是统一建模语言（Unified Modeling Language）的缩写，它发表于1997年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用UML可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为。</p>
<h3 id="93、UML中有哪些常用的图？"><a href="#93、UML中有哪些常用的图？" class="headerlink" title="93、UML中有哪些常用的图？"></a>93、UML中有哪些常用的图？</h3><p>答：UML定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等。在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。</p>
<p>用例图：</p>
<p>类图：</p>
<p>时序图：</p>
<h3 id="94、用Java写一个冒泡排序。"><a href="#94、用Java写一个冒泡排序。" class="headerlink" title="94、用Java写一个冒泡排序。"></a>94、用Java写一个冒泡排序。</h3><p>答：冒泡排序几乎是个程序员都写得出来，但是面试的时候如何写一个逼格高的冒泡排序却不是每个人都能做到，下面提供一个参考代码：xxx链接</p>
<h3 id="95、用Java写一个折半查找。"><a href="#95、用Java写一个折半查找。" class="headerlink" title="95、用Java写一个折半查找。"></a>95、用Java写一个折半查找。</h3><p>答：折半查找，也称二分查找、二分搜索，是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组已经为空，则表示找不到指定的元素。这种搜索算法每一次比较都使搜索范围缩小一半，其时间复杂度是O(logN)。<br>————————————————<br>版权声明：本文为CSDN博主「Java程序员-张凯」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41701956/article/details/86699263">https://blog.csdn.net/qq_41701956/article/details/86699263</a></p>
<h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><h2 id="一、Spring概述"><a href="#一、Spring概述" class="headerlink" title="一、Spring概述"></a>一、Spring概述</h2><h3 id="1-什么是-Spring-？"><a href="#1-什么是-Spring-？" class="headerlink" title="1. 什么是 Spring ？"></a>1. 什么是 Spring ？</h3><p>Spring 是一个轻量级 Java 开发框架，最早有 Rod Johnson 创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE&#x2F;JavaEE full-stack（一站式）轻量级开源框架，为开发 Java 应用程序提供全面的基础架构支持。Spring 负责基础架构，因此 Java 开发者可以专注于应用程序的开发。</p>
<p>Spring 最根本的使命是解决企业级应用开发的复杂性，即简化  Java 开发。</p>
<p>Spring 可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是依赖注入（dependency injection，DI）和面向切面编程（aspect-oriented programming，AOP）。</p>
<p>为了降低 Java 开发的复杂性，Spring 采取了以下4种关键策略</p>
<ul>
<li>基于POJO的轻量级和最小侵入性编程；</li>
<li>通过依赖注入和面向接口实现松耦合；</li>
<li>基于切面和惯例进行声明式编程；</li>
<li>通过切面和模板减少样板式代码。</li>
</ul>
<h3 id="2-Spring-框架的设计目标，设计理念和核心是什么？"><a href="#2-Spring-框架的设计目标，设计理念和核心是什么？" class="headerlink" title="2. Spring 框架的设计目标，设计理念和核心是什么？"></a>2. Spring 框架的设计目标，设计理念和核心是什么？</h3><p>Spring 设计目标：Spring 为开发者提供一个一站式轻量级应用开发平台；</p>
<p>Spring 设计理念：在 JavaEE 开发中，支持 POJO 和  JavaBean 开发方式，使应用面向接口开发，充分支持OO（面向对象）设计方法；Spring 通过 IoC 容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给 IoC 容器，实现解耦；</p>
<p>Spring 框架的核心：IoC 容器和 AOP 模块。通过 IoC 容器管理 POJO 对象以及他们之间的耦合关系；通过 AOP 以动态非侵入的方式增强服务。</p>
<p>IoC 让相互协作的组件保持松散的耦合，而 AOP 编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p>
<h3 id="3-Spring-的优缺点是什么？"><a href="#3-Spring-的优缺点是什么？" class="headerlink" title="3. Spring 的优缺点是什么？"></a>3. Spring 的优缺点是什么？</h3><p>优点<br>①. 方便解耦，简化开发</p>
<p>Spring 就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给 Spring 管理。</p>
<p>②. AOP编程的支持</p>
<p>Spring 提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</p>
<p>③. 声明式事务的支持</p>
<p>只需要通过配置就可以完成对事务的管理，而无需手动编程。</p>
<p>④. 方便程序的测试</p>
<p>Spring 对 JUnit4 支持，可以通过注解方便的测试 Spring 程序。</p>
<p>⑤. 方便集成各种优秀框架</p>
<p>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。</p>
<p>⑥. 降低 JavaEE API的使用难度</p>
<p>Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。</p>
<p>缺点<br>Spring 明明一个很轻量级的框架，却给人感觉大而全<br>Spring 依赖反射，反射影响性能<br>使用门槛升高，入门Spring需要较长时间</p>
<h3 id="4-Spring-有哪些应用场景"><a href="#4-Spring-有哪些应用场景" class="headerlink" title="4. Spring 有哪些应用场景"></a>4. Spring 有哪些应用场景</h3><p>应用场景：JavaEE企业应用开发，包括SSH、SSM等</p>
<p>Spring价值：</p>
<p>Spring是非侵入式的框架，目标是使应用程序代码对框架依赖最小化；<br>Spring提供一个一致的编程模型，使应用直接使用POJO开发，与运行环境隔离开来；<br>Spring推动应用设计风格向面向对象和面向接口开发转变，提高了代码的重用性和可测试性；</p>
<h3 id="5-Spring-由哪些模块组成？"><a href="#5-Spring-由哪些模块组成？" class="headerlink" title="5. Spring 由哪些模块组成？"></a>5. Spring 由哪些模块组成？</h3><p>Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在核心容器（Core Container） 、 AOP（Aspect Oriented Programming）和设备支持（Instrmentation） 、数据访问与集成（Data Access&#x2F;Integeration） 、 Web、 消息（Messaging） 、 Test等 6 个模块中。 以下是 Spring 5 的模块结构图：</p>
<p>spring core：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。<br>spring beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。<br>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。<br>spring jdbc：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析， 用于简化JDBC。<br>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。<br>spring web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。<br>spring test：主要为测试提供支持的，支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。</p>
<h3 id="6-Spring-框架中都用到了哪些设计模式？"><a href="#6-Spring-框架中都用到了哪些设计模式？" class="headerlink" title="6. Spring 框架中都用到了哪些设计模式？"></a>6. Spring 框架中都用到了哪些设计模式？</h3><ul>
<li>工厂模式：BeanFactory 就是简单工厂模式的体现，用来创建对象的实例；</li>
<li>单例模式：Bean 默认为单例模式。</li>
<li>代理模式：Spring 的 AOP 功能用到了 JDK 的动态代理和 CGLIB 字节码生成技术；</li>
<li>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li>
<li>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如 Spring 中 listener 的实现 – ApplicationListener。</li>
</ul>
<h3 id="7-详细讲解一下核心容器（spring-context应用上下文-模块"><a href="#7-详细讲解一下核心容器（spring-context应用上下文-模块" class="headerlink" title="7. 详细讲解一下核心容器（spring context应用上下文) 模块"></a>7. 详细讲解一下核心容器（spring context应用上下文) 模块</h3><p>这是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以Spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为一个容器。</p>
<p>Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从真正的应用代码中分离。最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件中的定义加载beans。该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。</p>
<h3 id="8-Spring-框架中有哪些不同类型的事件"><a href="#8-Spring-框架中有哪些不同类型的事件" class="headerlink" title="8. Spring 框架中有哪些不同类型的事件"></a>8. Spring 框架中有哪些不同类型的事件</h3><p>Spring 提供了以下5种标准的事件：</p>
<p>上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。<br>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的start()方法开始&#x2F;重新开始容器时触发该事件。<br>上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的stop()方法停止容器时触发该事件。<br>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。<br>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</p>
<h3 id="9-Spring-应用程序有哪些不同组件？"><a href="#9-Spring-应用程序有哪些不同组件？" class="headerlink" title="9.Spring 应用程序有哪些不同组件？"></a>9.Spring 应用程序有哪些不同组件？</h3><p>Spring 应用一般有以下组件：</p>
<p>接口 - 定义功能。<br>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。<br>Bean 配置文件 - 包含类的信息以及如何配置它们。<br>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。<br>用户程序 - 它使用接口。</p>
<h2 id="10-使用-Spring-有哪些方式？"><a href="#10-使用-Spring-有哪些方式？" class="headerlink" title="10.使用 Spring 有哪些方式？"></a>10.使用 Spring 有哪些方式？</h2><p>使用 Spring 有以下方式：</p>
<p>作为一个成熟的 Spring Web 应用程序。<br>作为第三方 Web 框架，使用 Spring Frameworks 中间层。<br>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。<br>用于远程使用。</p>
<p>二、Spring控制反转(IoC)</p>
<ol>
<li>什么是 Spring IoC 容器？<br>控制反转即 IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</li>
</ol>
<p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p>
<ol start="2">
<li>控制反转(IoC)有什么作用<br>管理对象的创建和依赖关系的维护。对象的创建并不是一件简单的事，在对象关系比较复杂时，如果依赖关系需要程序猿来维护的话，那是相当头疼的<br>解耦，由容器去维护具体的对象<br>托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的</li>
<li>IoC的优点是什么？<br>IoC 或 依赖注入把应用的代码量降到最低。<br>它使应用容易测试，单元测试不再需要单例和JNDI查找机制。<br>最小的代价和最小的侵入性使松散耦合得以实现。<br>IOC容器支持加载服务时的饿汉式初始化和懒加载。</li>
<li>Spring IoC 的实现机制<br>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</li>
</ol>
<p>示例：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fruit</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">eat</span>();<br> &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Apple&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Orange</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Orange&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">Fruit</span> <span class="hljs-title function_">getInstance</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> ClassName</span>) &#123;<br>        <span class="hljs-title class_">Fruit</span> f=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            f=(<span class="hljs-title class_">Fruit</span>)<span class="hljs-title class_">Class</span>.<span class="hljs-title function_">forName</span>(<span class="hljs-title class_">ClassName</span>).<span class="hljs-title function_">newInstance</span>();<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>            e.<span class="hljs-title function_">printStackTrace</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> f;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] a</span>) &#123;<br>        <span class="hljs-title class_">Fruit</span> f=<span class="hljs-title class_">Factory</span>.<span class="hljs-title function_">getInstance</span>(<span class="hljs-string">&quot;io.github.dunwu.spring.Apple&quot;</span>);<br>        <span class="hljs-keyword">if</span>(f!=<span class="hljs-literal">null</span>)&#123;<br>            f.<span class="hljs-title function_">eat</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>




<ol start="5">
<li>Spring 的 IoC支持哪些功能<br>Spring 的 IoC 设计支持以下功能：</li>
</ol>
<p>依赖注入<br>依赖检查<br>自动装配<br>支持集合<br>指定初始化方法和销毁方法<br>支持回调某些方法（但是需要实现 Spring 接口，略有侵入）<br>其中，最重要的就是依赖注入，从 XML 的配置上说，即 ref 标签。对应 Spring RuntimeBeanReference 对象。</p>
<p>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</p>
<ol start="6">
<li>BeanFactory 和 ApplicationContext有什么区别？<br>BeanFactory 和 ApplicationContext 是 Spring 的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</li>
</ol>
<p>依赖关系</p>
<p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p>
<p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p>
<p>继承MessageSource，因此支持国际化。<br>统一的资源文件访问方式。<br>提供在监听器中注册bean的事件。<br>同时加载多个配置文件。<br>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。<br>加载方式</p>
<p>BeanFactroy 采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p>
<p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>
<p>相对于基本的 BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
<p>创建方式</p>
<p>BeanFactory通常以编程的方式被创建，ApplicationContext 还能以声明的方式创建，如使用 ContextLoader。</p>
<p>注册方式</p>
<p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p>
<ol start="7">
<li>Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解<br>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。</li>
</ol>
<p>BeanFactory<br>ApplicationContext<br>BeanFactory 简单粗暴，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。</p>
<p>ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载&#x2F;刷新所有的 bean。</p>
<p>当然，除了这两个大接口，还有其他的辅助接口，这里就不介绍他们了。</p>
<p>BeanFactory和ApplicationContext的关系</p>
<p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，这里通过常用的 ClassPathXmlApplicationContext 类来展示整个容器的层级 UML 关系。</p>
<p>有点复杂？ 先不要慌，我来解释一下。</p>
<p>最上面的是 BeanFactory，下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p>
<p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p>
<p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p>
<p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置，生命周期事件回调等。</p>
<p>小结<br>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p>
<p>加载配置文件，解析成 BeanDefinition 放在 Map 里。</p>
<p>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</p>
<p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p>
<p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p>
<ol start="8">
<li>ApplicationContext通常的实现是什么？<br>FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</li>
</ol>
<p>ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</p>
<p>WebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</p>
<ol start="9">
<li>什么是Spring的依赖注入？</li>
</ol>
<p>  控制反转IoC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：依赖注入和依赖查找</p>
<p>依赖注入：相对于IoC而言，依赖注入(DI)更加准确地描述了IoC的设计理念。所谓依赖注入（Dependency Injection），即组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。</p>
<ol start="10">
<li><p>依赖注入的基本原则<br>依赖注入的基本原则是：应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由IoC容器负责，“查找资源”的逻辑应该从应用组件的代码中抽取出来，交给IoC容器负责。容器全权负责组件的装配，它会把符合依赖关系的对象通过属性（JavaBean中的setter）或者是构造器传递给需要的对象。</p>
</li>
<li><p>依赖注入有什么优势<br>依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露JavaBean的setter方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：</p>
</li>
</ol>
<p>查找定位操作与应用代码完全无关。<br>不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。<br>不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。<br>12. 有哪些不同类型的依赖注入实现方式？<br>依赖注入是时下最流行的IoC实现方式，依赖注入分为接口注入（Interface Injection），Setter方法注入（Setter Injection）和构造器注入（Constructor Injection）三种方式。其中接口注入由于在灵活性和易用性比较差，现在从Spring4开始已被废弃。</p>
<p>构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p>
<p>Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</p>
<ol start="13">
<li>构造器依赖注入和 Setter方法注入的区别<br>构造函数注入	setter 注入<br>没有部分注入	有部分注入<br>不会覆盖 setter 属性	会覆盖 setter 属性<br>任意修改都会创建一个新实例	任意修改不会创建一个新实例<br>适用于设置很多属性	适用于设置少量属性<br>两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</li>
</ol>
<p>三、Spring Beans</p>
<ol>
<li><p>什么是Spring beans？<br>Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中 的形式定义。</p>
</li>
<li><p>一个 Spring Bean 定义 包含什么？<br>一个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。</p>
</li>
<li><p>如何给Spring 容器提供配置元数据？Spring有几种配置方式<br>这里有三种重要的方法给Spring 容器提供配置元数据。</p>
</li>
</ol>
<p>XML配置文件。<br>基于注解的配置。<br>基于java的配置。<br>4. Spring配置文件包含了哪些信息<br>Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</p>
<ol start="5">
<li><p>Spring基于xml注入bean的几种方式<br>Set方法注入；<br>构造器注入：①通过index设置参数的位置；②通过type设置参数类型；<br>静态工厂注入；<br>实例工厂；</p>
</li>
<li><p>你怎样定义类的作用域？<br>当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。</p>
</li>
<li><p>解释Spring支持的几种bean的作用域<br>Spring框架支持以下五种bean的作用域：</p>
</li>
</ol>
<p>singleton : bean在每个Spring ioc 容器中只有一个实例。<br>prototype：一个bean的定义可以有多个实例。<br>request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。<br>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。<br>global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。<br>注意： 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p>
<ol start="8">
<li>Spring框架中的单例bean是线程安全的吗？<br>不是，Spring框架中的单例bean不是线程安全的。</li>
</ol>
<p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p>
<p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p>
<p>有状态就是有数据存储功能。<br>无状态就是不会保存数据。<br>9. Spring如何处理线程并发问题？<br>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</p>
<p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。</p>
<p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>
<ol start="10">
<li><p>解释 Spring 框架中 bean 的生命周期</p>
<p>在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean 的创建过程。下图展示了bean装载到Spring应用上下文中的一个典型的生命周期过程。</p>
</li>
</ol>
<p>bean在Spring容器中从创建到销毁经历了若干阶段，每一阶段都可以针对Spring如何管理bean进行个性化定制。</p>
<p>正如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。</p>
<p>我们对上图进行详细描述：</p>
<p>Spring对bean进行实例化；</p>
<p>Spring将值和bean的引用注入到bean对应的属性中；</p>
<p>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</p>
<p>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</p>
<p>如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</p>
<p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</p>
<p>如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；</p>
<p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</p>
<p>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</p>
<p>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</p>
<p>现在你已经了解了如何创建和加载一个Spring容器。但是一个空的容器并没有太大的价值，在你把东西放进去之前，它里面什么都没有。为了从Spring的DI(依赖注入)中受益，我们必须将应用对象装配进Spring容器中。</p>
<ol start="11">
<li>哪些是重要的bean生命周期方法？ 你能重载它们吗？<br>有两个重要的bean 生命周期方法，第一个是 setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。</li>
</ol>
<p>bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</p>
<ol start="12">
<li><p>什么是Spring的内部 bean ？什么是Spring inner beans？<br>在Spring框架中，当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现，内部bean通常是匿名的，它们的Scope一般是prototype。</p>
</li>
<li><p>在 Spring中如何注入一个java集合？<br>Spring提供以下几种集合的配置元素：</p>
</li>
</ol>
<p>类型用于注入一列值，允许有相同的值。</p>
<p>类型用于注入一组值，不允许有相同的值。</p>
<p>类型用于注入一组键值对，键和值都可以为任意类型。</p>
<p>类型用于注入一组键值对，键和值都只能为String类型。</p>
<ol start="14">
<li><p>什么是bean装配？<br>装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</p>
</li>
<li><p>什么是bean的自动装配？<br>在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean工厂自动处理bean之间的协作。这意味着 Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。</p>
</li>
<li><p>解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？<br>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</p>
</li>
</ol>
<p>在Spring框架xml配置中共有5种自动装配：</p>
<ul>
<li><p>no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配 bean。</p>
</li>
<li><p>byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。</p>
</li>
<li><p>byType：通过参数的数据类型进行自动装配。</p>
</li>
<li><p>constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</p>
</li>
<li><p>autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</p>
</li>
</ul>
<ol start="17">
<li>使用@Autowired注解自动装配的过程是怎样的？<br>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config &#x2F;&gt;。</li>
</ol>
<p>在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p>
<p>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；<br>如果查询的结果不止一个，那么@Autowired会根据名称来查找；<br>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required&#x3D;false。<br>18. 自动装配有哪些局限性？<br>自动装配的局限性是：</p>
<p>重写：你仍需用 和 配置来定义依赖，意味着总要重写自动装配。</p>
<p>基本数据类型：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。</p>
<p>模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</p>
<ol start="19">
<li>你可以在Spring中注入一个null 和一个空字符串吗？<br>可以。</li>
</ol>
<p>四、Spring注解</p>
<ol>
<li>什么是基于Java的Spring注解配置? 给一些注解的例子<br>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</li>
</ol>
<p>以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。</p>
<p>另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p>
<p>@Configuration<br>public class StudentConfig {<br>    @Bean<br>    public StudentBean myStudent() {<br>        return new StudentBean();<br>    }<br>}<br>2. 怎样开启注解装配？<br>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 <a href="context:annotation-config/">context:annotation-config/</a>元素。</p>
<ol start="3">
<li>@Component, @Controller, @Repository, @Service 有何区别？<br>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li>
</ol>
<p>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</p>
<p>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</p>
<p>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p>
<ol start="4">
<li>@Required 注解有什么作用<br>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。示例：</li>
</ol>
<p>public class Employee {<br>    private String name;<br>    @Required<br>    public void setName(String name){<br>        this.name&#x3D;name;<br>    }<br>    public string getName(){<br>        return name;<br>    }<br>}<br>5. @Autowired 注解有什么作用<br>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和&#x2F;或多个参数的PN方法。</p>
<p>public class Employee {<br>    private String name;<br>    @Autowired<br>    public void setName(String name) {<br>        this.name&#x3D;name;<br>    }<br>    public string getName(){<br>        return name;<br>    }<br>}<br>6. @Autowired和@Resource之间的区别<br>@Autowired可用于：构造函数、成员变量、Setter方法</p>
<p>@Autowired和@Resource之间的区别</p>
<p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。<br>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。<br>7. @Qualifier 注解有什么作用<br>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p>
<ol start="8">
<li>@RequestMapping 注解有什么用？<br>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类&#x2F;方法。此注释可应用于两个级别：</li>
</ol>
<p>类级别：映射请求的 URL<br>方法级别：映射 URL 以及 HTTP 请求方法</p>
<p>五、Spring数据访问</p>
<ol>
<li><p>解释对象&#x2F;关系映射集成模块<br>Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象&#x2F;关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate，JDO和 iBATIS，JPA，TopLink，JDO，OJB 。Spring的事务管理同样支持以上所有ORM框架及JDBC。</p>
</li>
<li><p>在Spring框架中如何更有效地使用JDBC？<br>使用Spring JDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate</p>
</li>
<li><p>解释JDBC抽象和DAO模块<br>通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。</p>
</li>
<li><p>spring DAO 有什么用？<br>Spring DAO（数据访问对象） 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p>
</li>
<li><p>spring JDBC API 中存在哪些类？<br>JdbcTemplate<br>SimpleJdbcTemplate<br>NamedParameterJdbcTemplate<br>SimpleJdbcInsert<br>SimpleJdbcCall</p>
</li>
<li><p>JdbcTemplate是什么<br>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p>
</li>
<li><p>使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？<br>在Spring中有两种方式访问Hibernate：</p>
</li>
</ol>
<p>使用 Hibernate 模板和回调进行控制反转<br>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点<br>8. 如何通过HibernateDaoSupport将Spring和Hibernate结合起来？<br>用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：</p>
<p>配置the Hibernate SessionFactory<br>继承HibernateDaoSupport实现一个DAO<br>在AOP支持的事务中装配<br>9. Spring支持的事务管理类型， spring 事务实现方式有哪些？<br>Spring支持两种类型的事务管理：</p>
<p>编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p>
<p>声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p>
<ol start="10">
<li><p>Spring事务的实现方式和实现原理<br>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</p>
</li>
<li><p>说一下Spring的事务传播行为<br>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p>
</li>
</ol>
<p>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p>
<p>② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p>
<p>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p>
<p>④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p>
<p>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>
<p>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p>
<p>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p>
<ol start="12">
<li>说一下 spring 的事务隔离？<br>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</li>
</ol>
<p>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；<br>ISOLATION_READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；<br>ISOLATION_READ_COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；<br>ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；<br>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。<br>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p>不可重复读 ：是指在一个事务内，多次读同一数据。</p>
<p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<ol start="13">
<li>Spring框架的事务管理有哪些优点？<br>为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。<br>为编程式事务管理提供了一套简单的API而不是一些复杂的事务API<br>支持声明式事务管理。<br>和Spring各种数据访问抽象层很好得集成。</li>
<li>你更倾向用那种事务管理类型？<br>大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</li>
</ol>
<p>六、Spring面向切面编程(AOP)</p>
<ol>
<li>什么是AOP<br>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</li>
</ol>
<p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。</p>
<ol start="2">
<li>Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？<br>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</li>
</ol>
<p>（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p>
<p>（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p>
<ol start="3">
<li>JDK动态代理和CGLIB动态代理的区别<br>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</li>
</ol>
<p>JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。<br>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。<br>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p>
<p>InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)：proxy是最终生成的代理实例; method 是被代理目标实例的某个具体方法; args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</p>
<ol start="4">
<li>如何理解 Spring 中的代理？<br>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。</li>
</ol>
<p>Advice + Target Object &#x3D; Proxy</p>
<ol start="5">
<li>解释一下Spring AOP里面的几个名词<br>（1）切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</li>
</ol>
<p>（2）连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。 应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p>
<p>（3）通知（Advice）：在AOP术语中，切面的工作被称为通知。</p>
<p>（4）切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p>
<p>（5）引入（Introduction）：引入允许我们向现有类添加新方法或属性。</p>
<p>（6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</p>
<p>（7）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多少个点可以进行织入：</p>
<p>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。<br>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。<br>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。<br>6. Spring在运行时通知对象<br>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。代理封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。</p>
<p>直到应用需要被代理的bean时，Spring才创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入SpringAOP的切面。</p>
<ol start="7">
<li><p>Spring只支持方法级别的连接点<br>因为Spring基于动态代理，所以Spring只支持方法连接点。Spring缺少对字段连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们可以利用Aspect来补充。</p>
</li>
<li><p>在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处<br>关注点（concern）是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。</p>
</li>
</ol>
<p>横切关注点（cross-cutting concern）是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p>
<ol start="9">
<li>Spring通知有哪些类型？<br>在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过SpringAOP框架触发的代码段。</li>
</ol>
<p>Spring切面可以应用5种类型的通知：</p>
<p>前置通知（Before）：在目标方法被调用之前调用通知功能；<br>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；<br>返回通知（After-returning ）：在目标方法成功执行之后调用通知；<br>异常通知（After-throwing）：在目标方法抛出异常后调用通知；<br>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。<br>同一个aspect，不同advice的执行顺序：</p>
<p>①没有异常情况下的执行顺序：</p>
<p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterReturning<br>②有异常情况下的执行顺序：</p>
<p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterThrowing:异常发生<br>java.lang.RuntimeException: 异常发生<br>10. 什么是切面 Aspect？<br>aspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.</p>
<p>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p>
<p>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上<br>如何在 advice 中编写切面代码.<br>可以简单地认为, 使用 @Aspect 注解的类就是切面。</p>
<ol start="11">
<li><p>解释基于XML Schema方式的切面实现<br>在这种情况下，切面由常规类以及基于XML的配置实现。</p>
</li>
<li><p>解释基于注解的切面实现<br>在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。</p>
</li>
<li><p>有几种不同类型的自动代理？<br>BeanNameAutoProxyCreator<br>DefaultAdvisorAutoProxyCreator<br>Metadata autoproxying<br>这就是我分享给大家的77道Spring面试题以及参考答案（2021年最新版）<br>————————————————<br>版权声明：本文为CSDN博主「Java程序员-张凯」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41701956/article/details/116354268">https://blog.csdn.net/qq_41701956/article/details/116354268</a></p>
</li>
</ol>
<h1 id="Spring-Boot-框架"><a href="#Spring-Boot-框架" class="headerlink" title="Spring Boot 框架"></a>Spring Boot 框架</h1><h3 id="什么是-Spring-Boot？"><a href="#什么是-Spring-Boot？" class="headerlink" title="什么是 Spring Boot？"></a>什么是 Spring Boot？</h3><ul>
<li>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，使开发者能快速上手。</li>
</ul>
<h3 id="为什么要用-SpringBoot"><a href="#为什么要用-SpringBoot" class="headerlink" title="为什么要用 SpringBoot"></a>为什么要用 SpringBoot</h3><ul>
<li>快速开发，快速整合，配置简化、内嵌服务容器</li>
</ul>
<h3 id="SpringBoot-与-SpringCloud-区别"><a href="#SpringBoot-与-SpringCloud-区别" class="headerlink" title="SpringBoot 与 SpringCloud 区别"></a>SpringBoot 与 SpringCloud 区别</h3><ul>
<li>SpringBoot 是快速开发的 Spring 框架，SpringCloud 是完整的微服务框架，SpringCloud 依赖于 SpringBoot。</li>
</ul>
<h3 id="Spring-Boot-有哪些优点？"><a href="#Spring-Boot-有哪些优点？" class="headerlink" title="Spring Boot 有哪些优点？"></a>Spring Boot 有哪些优点？</h3><ul>
<li>Spring Boot 主要有如下优点：<ol>
<li>容易上手，提升开发效率，为 Spring 开发提供一个更快、更简单的开发框架。</li>
<li>开箱即用，远离繁琐的配置。</li>
<li>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</li>
<li>SpringBoot总结就是使编码变简单、配置变简单、部署变简单、监控变简单等等</li>
</ol>
</li>
</ul>
<h3 id="Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h3><ul>
<li>启动类上面的注解是 @SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：<ul>
<li>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</li>
<li>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项， 例如：<code>Java 如关闭数据源自动配置功能： @SpringBootApplication(exclude = &#123; DataSourceAutoConfiguration.class &#125;)。</code></li>
<li>@ComponentScan：Spring 组件扫描。</li>
</ul>
</li>
</ul>
<h3 id="Spring-Boot-支持哪些日志框架？推荐和默认的日志框架是哪个？"><a href="#Spring-Boot-支持哪些日志框架？推荐和默认的日志框架是哪个？" class="headerlink" title="Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？"></a>Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？</h3><ul>
<li>Spring Boot 支持 Java Util Logging，Log4j2，Lockback 作为日志框架，如果你使用 Starters 启动器，Spring Boot 将使用 Logback 作为默认日志框架，但是不管是那种日志框架他都支持将配置文件输出到控制台或者文件中。</li>
</ul>
<h3 id="SpringBoot-Starter-的工作原理"><a href="#SpringBoot-Starter-的工作原理" class="headerlink" title="SpringBoot Starter 的工作原理"></a>SpringBoot Starter 的工作原理</h3><ul>
<li><code>我个人理解SpringBoot就是由各种Starter组合起来的，我们自己也可以开发Starter</code></li>
<li>在 SprinBoot 启动时由 @SpringBootApplication 注解会自动去 maven 中读取每个 starter 中的 spring.factories 文件，该文件里配置了所有需要被创建 spring容器中的 bean，并且进行自动配置把 bean 注入 SpringContext 中 &#x2F;&#x2F;（SpringContext是Spring的配置文件）</li>
</ul>
<h3 id="Spring-Boot-2-X-有什么新特性？与-1-X-有什么区别？"><a href="#Spring-Boot-2-X-有什么新特性？与-1-X-有什么区别？" class="headerlink" title="Spring Boot 2.X 有什么新特性？与 1.X 有什么区别？"></a>Spring Boot 2.X 有什么新特性？与 1.X 有什么区别？</h3><ul>
<li>配置变更</li>
<li>JDK 版本升级</li>
<li>第三方类库升级</li>
<li>响应式 Spring 编程支持</li>
<li>HTTP&#x2F;2 支持</li>
<li>配置属性绑定</li>
<li>更多改进与加强</li>
</ul>
<h3 id="SpringBoot-支持什么前端模板，"><a href="#SpringBoot-支持什么前端模板，" class="headerlink" title="SpringBoot 支持什么前端模板，"></a>SpringBoot 支持什么前端模板，</h3><ul>
<li>thymeleaf，freemarker，jsp，官方不推荐JSP会有限制</li>
</ul>
<h3 id="SpringBoot-的缺点"><a href="#SpringBoot-的缺点" class="headerlink" title="SpringBoot 的缺点"></a>SpringBoot 的缺点</h3><ul>
<li>我觉得是为难人，SpringBoot在目前我觉得没有什么缺点，非要找一个出来我觉得就是<ul>
<li>由于不用自己做的配置，报错时很难定位。</li>
</ul>
</li>
</ul>
<h3 id="运行-Spring-Boot-有哪几种方式？"><a href="#运行-Spring-Boot-有哪几种方式？" class="headerlink" title="运行 Spring Boot 有哪几种方式？"></a>运行 Spring Boot 有哪几种方式？</h3><ol>
<li>打包用命令或者放到容器中运行</li>
<li>用 Maven&#x2F; Gradle 插件运行</li>
<li>直接执行 main 方法运行</li>
</ol>
<h3 id="Spring-Boot-需要独立的容器运行吗？"><a href="#Spring-Boot-需要独立的容器运行吗？" class="headerlink" title="Spring Boot 需要独立的容器运行吗？"></a>Spring Boot 需要独立的容器运行吗？</h3><ul>
<li>可以不需要，内置了 Tomcat&#x2F; Jetty 等容器。</li>
</ul>
<h3 id="开启-Spring-Boot-特性有哪几种方式？"><a href="#开启-Spring-Boot-特性有哪几种方式？" class="headerlink" title="开启 Spring Boot 特性有哪几种方式？"></a>开启 Spring Boot 特性有哪几种方式？</h3><ol>
<li>继承spring-boot-starter-parent项目</li>
<li>导入spring-boot-dependencies项目依赖</li>
</ol>
<h3 id="SpringBoot-实现热部署有哪几种方式？"><a href="#SpringBoot-实现热部署有哪几种方式？" class="headerlink" title="SpringBoot 实现热部署有哪几种方式？"></a>SpringBoot 实现热部署有哪几种方式？</h3><ul>
<li>热部署就是可以不用重新运行SpringBoot项目可以实现操作后台代码自动更新到以运行的项目中</li>
<li>主要有两种方式：<ul>
<li>Spring Loaded</li>
<li>Spring-boot-devtools</li>
</ul>
</li>
</ul>
<h3 id="SpringBoot-事物的使用"><a href="#SpringBoot-事物的使用" class="headerlink" title="SpringBoot 事物的使用"></a>SpringBoot 事物的使用</h3><ul>
<li>SpringBoot的事物很简单，首先使用注解EnableTransactionManagement开启事物之后，然后在Service方法上添加注解Transactional便可。</li>
</ul>
<h3 id="Async-异步调用方法"><a href="#Async-异步调用方法" class="headerlink" title="Async 异步调用方法"></a>Async 异步调用方法</h3><ul>
<li>在SpringBoot中使用异步调用是很简单的，只需要在方法上使用@Async注解即可实现方法的异步调用。 注意：需要在启动类加入@EnableAsync使异步调用@Async注解生效。</li>
</ul>
<h3 id="如何在-Spring-Boot-启动的时候运行一些特定的代码？"><a href="#如何在-Spring-Boot-启动的时候运行一些特定的代码？" class="headerlink" title="如何在 Spring Boot 启动的时候运行一些特定的代码？"></a>如何在 Spring Boot 启动的时候运行一些特定的代码？</h3><ul>
<li>可以实现接口 ApplicationRunner 或者 CommandLineRunner，这两个接口实现方式一样，它们都只提供了一个 run 方法</li>
</ul>
<h3 id="Spring-Boot-有哪几种读取配置的方式？"><a href="#Spring-Boot-有哪几种读取配置的方式？" class="headerlink" title="Spring Boot 有哪几种读取配置的方式？"></a>Spring Boot 有哪几种读取配置的方式？</h3><ul>
<li>Spring Boot 可以通过 @PropertySource,@Value,@Environment, @ConfigurationPropertie注解来绑定变量</li>
</ul>
<h3 id="什么是-JavaConfig？"><a href="#什么是-JavaConfig？" class="headerlink" title="什么是  JavaConfig？"></a>什么是  JavaConfig？</h3><ul>
<li>Spring JavaConfig 是 Spring 社区的产品，Spring 3.0 引入了他，它提供了配置 Spring IOC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：<ul>
<li>面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。</li>
<li>减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。</li>
<li>类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。</li>
</ul>
</li>
<li>常用的Java config：<ul>
<li>@Configuration：在类上打上写下此注解，表示这个类是配置类</li>
<li>@ComponentScan：在配置类上添加 @ComponentScan 注解。该注解默认会扫描该类所在的包下所有的配置类，相当于之前的 &lt;context:component-scan &gt;。</li>
<li>@Bean：bean的注入：相当于以前的&lt; bean id&#x3D;”objectMapper” class&#x3D;”org.codehaus.jackson.map.ObjectMapper” &#x2F;&gt;</li>
<li>@EnableWebMvc：相当于xml的&lt;mvc:annotation-driven &gt;</li>
<li>@ImportResource： 相当于xml的 &lt; import resource&#x3D;”applicationContext-cache.xml”&gt;</li>
</ul>
</li>
</ul>
<h3 id="SpringBoot-的自动配置原理是什么"><a href="#SpringBoot-的自动配置原理是什么" class="headerlink" title="SpringBoot 的自动配置原理是什么"></a>SpringBoot 的自动配置原理是什么</h3><ul>
<li>主要是Spring Boot的启动类上的核心注解 SpringBootApplication 注解主配置类，有了这个主配置类启动时就会为SpringBoot开启一个@EnableAutoConfiguration注解自动配置功能。</li>
<li>有了这个EnableAutoConfiguration的话就会：<ol>
<li>从配置文件META_INF&#x2F;spring.factories加载可能用到的自动配置类</li>
<li>去重，并将exclude和excludeName属性携带的类排除</li>
<li>过滤，将满足条件（@Conditional）的自动配置类返回</li>
</ol>
</li>
</ul>
<h3 id="你如何理解-Spring-Boot-配置加载顺序？"><a href="#你如何理解-Spring-Boot-配置加载顺序？" class="headerlink" title="你如何理解 Spring Boot 配置加载顺序？"></a>你如何理解 Spring Boot 配置加载顺序？</h3><ul>
<li>在 Spring Boot 里面，可以使用以下几种方式来加载配置。<ul>
<li>1.properties文件；</li>
<li>2.YAML文件；</li>
<li>3.系统环境变量；</li>
<li>4.命令行参数；</li>
<li>等等……</li>
</ul>
</li>
</ul>
<h3 id="什么是-YAML？"><a href="#什么是-YAML？" class="headerlink" title="什么是 YAML？"></a>什么是 YAML？</h3><ul>
<li>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</li>
</ul>
<h3 id="YAML-配置的优势在哪里"><a href="#YAML-配置的优势在哪里" class="headerlink" title="YAML 配置的优势在哪里 ?"></a>YAML 配置的优势在哪里 ?</h3><ul>
<li>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？<ul>
<li>配置有序，在一些特殊的场景下，配置有序很关键</li>
<li>简洁明了，他还支持数组，数组中的元素可以是基本数据类型也可以是对象</li>
<li>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</li>
</ul>
</li>
</ul>
<h3 id="Spring-Boot-是否可以使用-XML-配置"><a href="#Spring-Boot-是否可以使用-XML-配置" class="headerlink" title="Spring Boot 是否可以使用 XML 配置 ?"></a>Spring Boot 是否可以使用 XML 配置 ?</h3><ul>
<li>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</li>
</ul>
<h3 id="spring-boot-核心配置文件是什么？bootstrap-properties-和-application-properties-有何区别"><a href="#spring-boot-核心配置文件是什么？bootstrap-properties-和-application-properties-有何区别" class="headerlink" title="spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?"></a>spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?</h3><ul>
<li>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</li>
<li>spring boot 核心的两个配置文件：<ul>
<li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud 配置就会使用这个文件。且 boostrap 里面的属性不能被覆盖；</li>
<li>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。</li>
</ul>
</li>
</ul>
<h3 id="什么是-Spring-Profiles？"><a href="#什么是-Spring-Profiles？" class="headerlink" title="什么是 Spring Profiles？"></a>什么是 Spring Profiles？</h3><ul>
<li>在项目的开发中，有些配置文件在开发、测试或者生产等不同环境中可能是不同的，例如数据库连接、redis 的配置等等。那我们如何在不同环境中自动实现配置的切换呢？Spring给我们提供了profiles机制给我们提供的就是来回切换配置文件的功能</li>
<li>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。</li>
</ul>
<h3 id="SpringBoot-多数据源拆分的思路"><a href="#SpringBoot-多数据源拆分的思路" class="headerlink" title="SpringBoot 多数据源拆分的思路"></a>SpringBoot 多数据源拆分的思路</h3><ul>
<li>先在properties配置文件中配置两个数据源，创建分包mapper，使用@ConfigurationProperties读取properties中的配置，使用@MapperScan注册到对应的mapper包中</li>
</ul>
<h3 id="SpringBoot-多数据源事务如何管理"><a href="#SpringBoot-多数据源事务如何管理" class="headerlink" title="SpringBoot 多数据源事务如何管理"></a>SpringBoot 多数据源事务如何管理</h3><ul>
<li>第一种方式是在service层的@TransactionManager中使用transactionManager指定DataSourceConfig中配置的事务</li>
<li>第二种是使用jta-atomikos实现分布式事务管理</li>
</ul>
<h3 id="保护-Spring-Boot-应用有哪些方法？"><a href="#保护-Spring-Boot-应用有哪些方法？" class="headerlink" title="保护 Spring Boot 应用有哪些方法？"></a>保护 Spring Boot 应用有哪些方法？</h3><ul>
<li>在生产中使用HTTPS</li>
<li>使用Snyk检查你的依赖关系</li>
<li>升级到最新版本</li>
<li>启用CSRF保护</li>
<li>使用内容安全策略防止XSS攻击</li>
</ul>
<h3 id="如何实现-Spring-Boot-应用程序的安全性？"><a href="#如何实现-Spring-Boot-应用程序的安全性？" class="headerlink" title="如何实现 Spring Boot 应用程序的安全性？"></a>如何实现 Spring Boot 应用程序的安全性？</h3><ul>
<li>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。</li>
</ul>
<h3 id="比较一下-Spring-Security-和-Shiro-各自的优缺点"><a href="#比较一下-Spring-Security-和-Shiro-各自的优缺点" class="headerlink" title="比较一下 Spring Security 和 Shiro 各自的优缺点 ?"></a>比较一下 Spring Security 和 Shiro 各自的优缺点 ?</h3><ul>
<li>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：<ul>
<li>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架</li>
<li>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单</li>
<li>Spring Security 功能强大；Shiro 功能简单</li>
</ul>
</li>
</ul>
<h3 id="Spring-Boot-中如何解决跨域问题"><a href="#Spring-Boot-中如何解决跨域问题" class="headerlink" title="Spring Boot 中如何解决跨域问题 ?"></a>Spring Boot 中如何解决跨域问题 ?</h3><ul>
<li>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</li>
</ul>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">@Configuration<br>public class CorsConfig implements WebMvcConfigurer &#123;<br><br>    @Override<br>    public void addCorsMappings(CorsRegistry registry) &#123;<br>        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>                .allowedOrigins(<span class="hljs-string">&quot;*&quot;</span>)<br>                .allowCredentials(true)<br>                .allowedMethods(<span class="hljs-string">&quot;<span class="hljs-keyword">GET</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-keyword">POST</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-keyword">PUT</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-keyword">DELETE</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-keyword">OPTIONS</span>&quot;</span>)<br>                .maxAge(<span class="hljs-number">3600</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Spring-Boot-中的监视器是什么？"><a href="#Spring-Boot-中的监视器是什么？" class="headerlink" title="Spring Boot 中的监视器是什么？"></a>Spring Boot 中的监视器是什么？</h3><ul>
<li>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。</li>
</ul>
<h3 id="如何使用-Spring-Boot-实现全局异常处理？"><a href="#如何使用-Spring-Boot-实现全局异常处理？" class="headerlink" title="如何使用 Spring Boot 实现全局异常处理？"></a>如何使用 Spring Boot 实现全局异常处理？</h3><ul>
<li>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</li>
</ul>
<h3 id="我们如何监视所有-Spring-Boot-微服务？"><a href="#我们如何监视所有-Spring-Boot-微服务？" class="headerlink" title="我们如何监视所有 Spring Boot 微服务？"></a>我们如何监视所有 Spring Boot 微服务？</h3><ul>
<li>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。</li>
</ul>
<h3 id="SpringBoot-性能如何优化"><a href="#SpringBoot-性能如何优化" class="headerlink" title="SpringBoot 性能如何优化"></a>SpringBoot 性能如何优化</h3><ul>
<li>如果项目比较大，类比较多，不使用@SpringBootApplication，采用@Compoment指定扫包范围</li>
<li>在项目启动时设置JVM初始内存和最大内存相同</li>
<li>将springboot内置服务器由tomcat设置为undertow</li>
</ul>
<h3 id="如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？"><a href="#如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？" class="headerlink" title="如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？"></a>如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</h3><ul>
<li>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供 H2 数据库控制台以更好地测试应用程序。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<h3 id="SpringBoot微服务中如何实现-session-共享"><a href="#SpringBoot微服务中如何实现-session-共享" class="headerlink" title="SpringBoot微服务中如何实现 session 共享 ?"></a>SpringBoot微服务中如何实现 session 共享 ?</h3><ul>
<li>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。</li>
</ul>
<h3 id="您使用了哪些-starter-maven-依赖项？"><a href="#您使用了哪些-starter-maven-依赖项？" class="headerlink" title="您使用了哪些 starter maven 依赖项？"></a>您使用了哪些 starter maven 依赖项？</h3><ul>
<li>使用了下面的一些依赖项<ul>
<li>spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持</li>
<li>spring-boot-starter-data-jpa 数据库支持</li>
<li>spring-boot-starter-data-redis redis数据库支持</li>
<li>spring-boot-starter-data-solr solr支持</li>
<li>mybatis-spring-boot-starter 第三方的mybatis集成starter</li>
<li>自定义的starter(如果自己开发过就可以说出来)</li>
</ul>
</li>
</ul>
<h3 id="Spring-Boot-中的-starter-到底是什么"><a href="#Spring-Boot-中的-starter-到底是什么" class="headerlink" title="Spring Boot 中的 starter 到底是什么 ?"></a>Spring Boot 中的 starter 到底是什么 ?</h3><ul>
<li>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 <code>XXXAutoConfiguration</code> ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性(spring.factories)注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter</li>
</ul>
<h3 id="Spring-Boot-中如何实现定时任务"><a href="#Spring-Boot-中如何实现定时任务" class="headerlink" title="Spring Boot 中如何实现定时任务 ?"></a>Spring Boot 中如何实现定时任务 ?</h3><ul>
<li>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一-个则是使用第三方框架 Quartz。</li>
<li>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</li>
</ul>
<h3 id="spring-boot-starter-parent-有什么用"><a href="#spring-boot-starter-parent-有什么用" class="headerlink" title="spring-boot-starter-parent 有什么用 ?"></a>spring-boot-starter-parent 有什么用 ?</h3><ul>
<li>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：<ol>
<li>定义了 Java 编译版本为 1.8 。</li>
<li>使用 UTF-8 格式编码。</li>
<li>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。</li>
<li>执行打包操作的配置。</li>
<li>自动化的资源过滤。</li>
<li>自动化的插件配置。</li>
<li>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</li>
</ol>
</li>
<li>总结就是打包用的</li>
</ul>
<h3 id="SpringBoot如何实现打包"><a href="#SpringBoot如何实现打包" class="headerlink" title="SpringBoot如何实现打包"></a>SpringBoot如何实现打包</h3><ul>
<li>进入项目目录在控制台输入mvn clean package，clean是清空已存在的项目包，package进行打包</li>
<li>或者点击左边选项栏中的Mavne，先点击clean在点击package</li>
</ul>
<h3 id="Spring-Boot-打成的-jar-和普通的-jar-有什么区别"><a href="#Spring-Boot-打成的-jar-和普通的-jar-有什么区别" class="headerlink" title="Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?"></a>Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</h3><ul>
<li>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 <code>java -jar xxx.jar</code> 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</li>
<li>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 <code>\BOOT-INF\classes</code> 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</li>
</ul>
<p>作者：小杰要吃蛋<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125709156359">https://juejin.cn/post/6844904125709156359</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h1 id="Spring-Cloud框架"><a href="#Spring-Cloud框架" class="headerlink" title="Spring Cloud框架"></a>Spring Cloud框架</h1><h2 id="什么是微服务架构"><a href="#什么是微服务架构" class="headerlink" title="什么是微服务架构"></a>什么是微服务架构</h2><ul>
<li>微服务架构就是将单体的应用程序分成多个应用程序，这多个应用程序就成为微服务，每个微服务运行在自己的进程中，并使用轻量级的机制通信。这些服务围绕业务能力来划分，并通过自动化部署机制来独立部署。这些服务可以使用不同的编程语言，不同数据库，以保证最低限度的集中式管理。</li>
</ul>
<h2 id="为什么需要学习-SpringCloud"><a href="#为什么需要学习-SpringCloud" class="headerlink" title="为什么需要学习 SpringCloud"></a>为什么需要学习 SpringCloud</h2><ul>
<li>首先SpringCloud基于SpingBoot的优雅简洁，可还记得我们被无数xml支配的恐惧？可还记得SpringMVC，mybatis错综复杂的配置，有了spingboot，这些东西都不需要了，spingboot好处不再赘诉，springcloud就基于SpringBoot把市场上优秀的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理</li>
<li>什么叫做开箱即用？即使是当年的黄金搭档dubbo+zookeeper下载配置起来也是颇费心神的！而springcloud完成这些只需要一个jar的依赖就可以了！</li>
<li>springcloud大多数子模块都是直击痛点，像zuul解决的跨域，fegin解决的负载均衡，hystrix的熔断机制等等等等</li>
</ul>
<h2 id="SpringCloud-是什么"><a href="#SpringCloud-是什么" class="headerlink" title="SpringCloud 是什么"></a>SpringCloud 是什么</h2><ul>
<li>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</li>
<li>Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</li>
</ul>
<h2 id="SpringCloud-的优缺点"><a href="#SpringCloud-的优缺点" class="headerlink" title="SpringCloud 的优缺点"></a>SpringCloud 的优缺点</h2><p>优点：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">1.耦合度比较低。不会影响其他模块的开发。<br>2.减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发。<br>3.配置比较简单，基本用注解就能实现，不用使用过多的配置文件。<br>4.微服务跨平台的，可以用任何一种语言开发。<br>5.每个微服务可以有自己的独立的数据库也有用公共的数据库。<br>6.直接写后端的代码，不用关注前端怎么开发，直接写自己的后端代码即可，然后暴露接口，通过组件进行服务通信。<br></code></pre></td></tr></table></figure>

<p>缺点：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1.部署比较麻烦，给运维工程师带来一定的麻烦。<br>2.针对数据的管理比麻烦，因为微服务可以每个微服务使用一个数据库。<br>3.系统集成测试比较麻烦<br>4.性能的监控比较麻烦。【最好开发一个大屏监控系统】<br></code></pre></td></tr></table></figure>

<ul>
<li>总的来说优点大过于缺点，目前看来Spring Cloud是一套非常完善的分布式框架，目前很多企业开始用微服务、Spring Cloud的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习Spring Cloud是一个不错的选择。</li>
</ul>
<h2 id="SpringBoot-和-SpringCloud-的区别？"><a href="#SpringBoot-和-SpringCloud-的区别？" class="headerlink" title="SpringBoot 和 SpringCloud 的区别？"></a>SpringBoot 和 SpringCloud 的区别？</h2><ul>
<li>SpringBoot 专注于快速方便的开发单个个体微服务。</li>
<li>SpringCloud 是关注全局的微服务协调整理治理框架，它将 SpringBoot 开发的一个个单体微服务整合并管理起来，</li>
<li>为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务</li>
<li>SpringBoot 可以离开 SpringCloud 独立使用开发项目， 但是 SpringCloud 离不开 SpringBoot  ，属于依赖的关系</li>
<li>SpringBoot 专注于快速、方便的开发单个微服务个体，SpringCloud 关注全局的服务治理框架。</li>
</ul>
<h2 id="Spring-Cloud和SpringBoot版本对应关系"><a href="#Spring-Cloud和SpringBoot版本对应关系" class="headerlink" title="Spring Cloud和SpringBoot版本对应关系"></a>Spring Cloud和SpringBoot版本对应关系</h2><blockquote>
<table>
<thead>
<tr>
<th>Spring Cloud Version</th>
<th>SpringBoot Version</th>
</tr>
</thead>
<tbody><tr>
<td>Hoxton</td>
<td>2.2.x</td>
</tr>
<tr>
<td>Greenwich</td>
<td>2.1.x</td>
</tr>
<tr>
<td>Finchley</td>
<td>2.0.x</td>
</tr>
<tr>
<td>Edgware</td>
<td>1.5.x</td>
</tr>
<tr>
<td>Dalston</td>
<td>1.5.x</td>
</tr>
</tbody></table>
</blockquote>
<h2 id="SpringCloud-由什么组成"><a href="#SpringCloud-由什么组成" class="headerlink" title="SpringCloud 由什么组成"></a>SpringCloud 由什么组成</h2><ul>
<li>其中最重要的有：<ul>
<li>Spring Cloud Eureka：服务注册与发现</li>
<li>Spring Cloud Zuul：服务网关</li>
<li>Spring Cloud Ribbon：客户端负载均衡</li>
<li>Spring Cloud Feign：声明性的Web服务客户端</li>
<li>Spring Cloud Hystrix：断路器</li>
<li>Spring Cloud Config：分布式统一配置管理</li>
<li>等20几个框架，开源一直在更新</li>
</ul>
</li>
</ul>
<h2 id="使用-Spring-Boot-开发分布式微服务时，我们面临什么问题"><a href="#使用-Spring-Boot-开发分布式微服务时，我们面临什么问题" class="headerlink" title="使用 Spring Boot 开发分布式微服务时，我们面临什么问题"></a>使用 Spring Boot 开发分布式微服务时，我们面临什么问题</h2><ul>
<li>（1）与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。</li>
<li>（2）服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。</li>
<li>（3）冗余-分布式系统中的冗余问题。</li>
<li>（4）负载平衡 –负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。</li>
<li>（5）性能-问题 由于各种运营开销导致的性能问题。</li>
</ul>
<h2 id="SpringCloud-和-dubbo-区别"><a href="#SpringCloud-和-dubbo-区别" class="headerlink" title="SpringCloud 和 dubbo 区别?"></a>SpringCloud 和 dubbo 区别?</h2><ul>
<li>（1）服务调用方式：dubbo是RPC springcloud Rest Api</li>
<li>（2）注册中心：dubbo 是zookeeper springcloud是eureka，也可以是zookeeper</li>
<li>（3）服务网关，dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。</li>
</ul>
<h1 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h1><h2 id="服务注册和发现是什么意思？Spring-Cloud-如何实现？"><a href="#服务注册和发现是什么意思？Spring-Cloud-如何实现？" class="headerlink" title="服务注册和发现是什么意思？Spring Cloud 如何实现？"></a>服务注册和发现是什么意思？Spring Cloud 如何实现？</h2><ul>
<li>当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka 服务注册和发现可以在这种情况下提供帮助。由于所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。</li>
</ul>
<h2 id="什么是-Eureka"><a href="#什么是-Eureka" class="headerlink" title="什么是 Eureka"></a>什么是 Eureka</h2><ul>
<li>Eureka 作为 SpringCloud 的服务注册功能服务器，他是服务注册中心，系统中的其他服务使用Eureka的客户端将其连接到Eureka Service中，并且保持心跳，这样工作人员可以通过 Eureka Service 来监控各个微服务是否运行正常。</li>
</ul>
<h2 id="Eureka-怎么实现高可用"><a href="#Eureka-怎么实现高可用" class="headerlink" title="Eureka 怎么实现高可用"></a>Eureka 怎么实现高可用</h2><ul>
<li>集群，注册多台 Eureka，然后把 SpringCloud 服务互相注册，客户端从 Eureka 获取信息时，按照 Eureka 的顺序来访问。</li>
</ul>
<h2 id="什么是-Eureka-的自我保护模式，"><a href="#什么是-Eureka-的自我保护模式，" class="headerlink" title="什么是 Eureka 的自我保护模式，"></a>什么是 Eureka 的自我保护模式，</h2><ul>
<li>默认情况下，如果 Eureka Service 在一定时间内没有接收到某个微服务的心跳，Eureka Service 会进入自我保护模式，在该模式下 Eureka Service 会保护服务注册表中的信息，不在删除注册表中的数据，当网络故障恢复后，Eureka Service 节点会自动退出自我保护模式</li>
</ul>
<h2 id="DiscoveryClient的作用"><a href="#DiscoveryClient的作用" class="headerlink" title="DiscoveryClient的作用"></a>DiscoveryClient的作用</h2><ul>
<li>可以从注册中心中根据服务别名获取注册的服务器信息。</li>
</ul>
<h2 id="Eureka和ZooKeeper都可以提供服务注册与发现的功能-请说说两个的区别"><a href="#Eureka和ZooKeeper都可以提供服务注册与发现的功能-请说说两个的区别" class="headerlink" title="Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别"></a>Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别</h2><ol>
<li><p>ZooKeeper中的节点服务挂了就要选举 在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的， 选举就是改微服务做了集群，必须有一台主其他的都是从</p>
</li>
<li><p>Eureka各个节点是平等关系,服务器挂了没关系，只要有一台Eureka就可以保证服务可用，数据都是最新的。 如果查询到的数据并不是最新的，就是因为Eureka的自我保护模式导致的</p>
</li>
<li><p>Eureka本质上是一个工程,而ZooKeeper只是一个进程</p>
</li>
<li><p>Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper 一样使得整个注册系统瘫痪</p>
</li>
<li><p>ZooKeeper保证的是CP，Eureka保证的是AP</p>
<p>CAP： C：一致性&gt;Consistency; 取舍：(强一致性、单调一致性、会话一致性、最终一致性、弱一致性) A：可用性&gt;Availability; P：分区容错性&gt;Partition tolerance;</p>
</li>
</ol>
<h1 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h1><h2 id="什么是网关"><a href="#什么是网关" class="headerlink" title="什么是网关?"></a>什么是网关?</h2><ul>
<li>网关相当于一个网络服务架构的入口，所有网络请求必须通过网关转发到具体的服务。</li>
</ul>
<h2 id="网关的作用是什么"><a href="#网关的作用是什么" class="headerlink" title="网关的作用是什么"></a>网关的作用是什么</h2><ul>
<li>统一管理微服务请求，权限控制、负载均衡、路由转发、监控、安全控制黑名单和白名单等</li>
</ul>
<h2 id="什么是Spring-Cloud-Zuul（服务网关）"><a href="#什么是Spring-Cloud-Zuul（服务网关）" class="headerlink" title="什么是Spring Cloud Zuul（服务网关）"></a>什么是Spring Cloud Zuul（服务网关）</h2><ul>
<li>Zuul是对SpringCloud提供的成熟对的路由方案，他会根据请求的路径不同，网关会定位到指定的微服务，并代理请求到不同的微服务接口，他对外隐蔽了微服务的真正接口地址。 三个重要概念：动态路由表，路由定位，反向代理：<ul>
<li>动态路由表：Zuul支持Eureka路由，手动配置路由，这俩种都支持自动更新</li>
<li>路由定位：根据请求路径，Zuul有自己的一套定位服务规则以及路由表达式匹配</li>
<li>反向代理：客户端请求到路由网关，网关受理之后，在对目标发送请求，拿到响应之后在 给客户端</li>
</ul>
</li>
<li>它可以和Eureka,Ribbon,Hystrix等组件配合使用，</li>
<li>Zuul的应用场景：<ul>
<li>对外暴露，权限校验，服务聚合，日志审计等</li>
</ul>
</li>
</ul>
<h2 id="网关与过滤器有什么区别"><a href="#网关与过滤器有什么区别" class="headerlink" title="网关与过滤器有什么区别"></a>网关与过滤器有什么区别</h2><ul>
<li>网关是对所有服务的请求进行分析过滤，过滤器是对单个服务而言。</li>
</ul>
<h2 id="常用网关框架有那些？"><a href="#常用网关框架有那些？" class="headerlink" title="常用网关框架有那些？"></a>常用网关框架有那些？</h2><ul>
<li>Nginx、Zuul、Gateway</li>
</ul>
<h2 id="Zuul与Nginx有什么区别？"><a href="#Zuul与Nginx有什么区别？" class="headerlink" title="Zuul与Nginx有什么区别？"></a>Zuul与Nginx有什么区别？</h2><ul>
<li>Zuul是java语言实现的，主要为java服务提供网关服务，尤其在微服务架构中可以更加灵活的对网关进行操作。Nginx是使用C语言实现，性能高于Zuul，但是实现自定义操作需要熟悉lua语言，对程序员要求较高，可以使用Nginx做Zuul集群。</li>
</ul>
<h2 id="既然Nginx可以实现网关？为什么还需要使用Zuul框架"><a href="#既然Nginx可以实现网关？为什么还需要使用Zuul框架" class="headerlink" title="既然Nginx可以实现网关？为什么还需要使用Zuul框架"></a>既然Nginx可以实现网关？为什么还需要使用Zuul框架</h2><ul>
<li>Zuul是SpringCloud集成的网关，使用Java语言编写，可以对SpringCloud架构提供更灵活的服务。</li>
</ul>
<h2 id="如何设计一套API接口"><a href="#如何设计一套API接口" class="headerlink" title="如何设计一套API接口"></a>如何设计一套API接口</h2><ul>
<li>考虑到API接口的分类可以将API接口分为开发API接口和内网API接口，内网API接口用于局域网，为内部服务器提供服务。开放API接口用于对外部合作单位提供接口调用，需要遵循Oauth2.0权限认证协议。同时还需要考虑安全性、幂等性等问题。</li>
</ul>
<h2 id="ZuulFilter常用有那些方法"><a href="#ZuulFilter常用有那些方法" class="headerlink" title="ZuulFilter常用有那些方法"></a>ZuulFilter常用有那些方法</h2><ul>
<li>Run()：过滤器的具体业务逻辑</li>
<li>shouldFilter()：判断过滤器是否有效</li>
<li>filterOrder()：过滤器执行顺序</li>
<li>filterType()：过滤器拦截位置</li>
</ul>
<h2 id="如何实现动态Zuul网关路由转发"><a href="#如何实现动态Zuul网关路由转发" class="headerlink" title="如何实现动态Zuul网关路由转发"></a>如何实现动态Zuul网关路由转发</h2><ul>
<li>通过path配置拦截请求，通过ServiceId到配置中心获取转发的服务列表，Zuul内部使用Ribbon实现本地负载均衡和转发。</li>
</ul>
<h2 id="Zuul网关如何搭建集群"><a href="#Zuul网关如何搭建集群" class="headerlink" title="Zuul网关如何搭建集群"></a>Zuul网关如何搭建集群</h2><ul>
<li>使用Nginx的upstream设置Zuul服务集群，通过location拦截请求并转发到upstream，默认使用轮询机制对Zuul集群发送请求。</li>
</ul>
<h1 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h1><h2 id="负载平衡的意义什么？"><a href="#负载平衡的意义什么？" class="headerlink" title="负载平衡的意义什么？"></a>负载平衡的意义什么？</h2><ul>
<li>简单来说： 先将集群，集群就是把一个的事情交给多个人去做，假如要做1000个产品给一个人做要10天，我叫10个人做就是一天，这就是集群，负载均衡的话就是用来控制集群，他把做的最多的人让他慢慢做休息会，把做的最少的人让他加量让他做多点。</li>
<li>在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。</li>
</ul>
<h2 id="Ribbon是什么？"><a href="#Ribbon是什么？" class="headerlink" title="Ribbon是什么？"></a>Ribbon是什么？</h2><ul>
<li>Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法</li>
<li>Ribbon客户端组件提供一系列完善的配置项，如连接超时，重试等。简单的说，就是在配置文件中列出后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随即连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。（有点类似Nginx）</li>
</ul>
<h2 id="Nginx与Ribbon的区别"><a href="#Nginx与Ribbon的区别" class="headerlink" title="Nginx与Ribbon的区别"></a>Nginx与Ribbon的区别</h2><ul>
<li>Nginx是反向代理同时可以实现负载均衡，nginx拦截客户端请求采用负载均衡策略根据upstream配置进行转发，相当于请求通过nginx服务器进行转发。Ribbon是客户端负载均衡，从注册中心读取目标服务器信息，然后客户端采用轮询策略对服务直接访问，全程在客户端操作。</li>
</ul>
<h2 id="Ribbon底层实现原理"><a href="#Ribbon底层实现原理" class="headerlink" title="Ribbon底层实现原理"></a>Ribbon底层实现原理</h2><ul>
<li>Ribbon使用discoveryClient从注册中心读取目标服务信息，对同一接口请求进行计数，使用%取余算法获取目标服务集群索引，返回获取到的目标服务信息。</li>
</ul>
<h2 id="LoadBalanced注解的作用"><a href="#LoadBalanced注解的作用" class="headerlink" title="@LoadBalanced注解的作用"></a>@LoadBalanced注解的作用</h2><p>​     开启客户端负载均衡。</p>
<h1 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h1><h2 id="什么是断路器"><a href="#什么是断路器" class="headerlink" title="什么是断路器"></a>什么是断路器</h2><ul>
<li>当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应）</li>
<li>断路器有三种状态<ul>
<li>打开状态：一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务</li>
<li>半开状态：短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭</li>
<li>关闭状态：当服务一直处于正常状态 能正常调用</li>
</ul>
</li>
</ul>
<h2 id="什么是-Hystrix？"><a href="#什么是-Hystrix？" class="headerlink" title="什么是 Hystrix？"></a>什么是 Hystrix？</h2><ul>
<li>在分布式系统，我们一定会依赖各种服务，那么这些个服务一定会出现失败的情况，就会导致雪崩，Hystrix就是这样的一个工具，防雪崩利器，它具有服务降级，服务熔断，服务隔离，监控等一些防止雪崩的技术。</li>
<li>Hystrix有四种防雪崩方式:<ul>
<li>服务降级：接口调用失败就调用本地的方法返回一个空</li>
<li>服务熔断：接口调用失败就会进入调用接口提前定义好的一个熔断的方法，返回错误信息</li>
<li>服务隔离：隔离服务之间相互影响</li>
<li>服务监控：在服务发生调用时,会将每秒请求数、成功请求数等运行指标记录下来。</li>
</ul>
</li>
</ul>
<h2 id="谈谈服务雪崩效应"><a href="#谈谈服务雪崩效应" class="headerlink" title="谈谈服务雪崩效应"></a>谈谈服务雪崩效应</h2><ul>
<li>雪崩效应是在大型互联网项目中，当某个服务发生宕机时，调用这个服务的其他服务也会发生宕机，大型项目的微服务之间的调用是互通的，这样就会将服务的不可用逐步扩大到各个其他服务中，从而使整个项目的服务宕机崩溃.发生雪崩效应的原因有以下几点</li>
<li>单个服务的代码存在bug. 2请求访问量激增导致服务发生崩溃(如大型商城的枪红包，秒杀功能). 3.服务器的硬件故障也会导致部分服务不可用.</li>
</ul>
<h2 id="在微服务中，如何保护服务"><a href="#在微服务中，如何保护服务" class="headerlink" title="在微服务中，如何保护服务?"></a>在微服务中，如何保护服务?</h2><ul>
<li>一般使用使用Hystrix框架，实现服务隔离来避免出现服务的雪崩效应，从而达到保护服务的效果。当微服务中，高并发的数据库访问量导致服务线程阻塞，使单个服务宕机，服务的不可用会蔓延到其他服务，引起整体服务灾难性后果，使用服务降级能有效为不同的服务分配资源,一旦服务不可用则返回友好提示，不占用其他服务资源，从而避免单个服务崩溃引发整体服务的不可用.</li>
</ul>
<h2 id="服务雪崩效应产生的原因"><a href="#服务雪崩效应产生的原因" class="headerlink" title="服务雪崩效应产生的原因"></a>服务雪崩效应产生的原因</h2><ul>
<li>因为Tomcat默认情况下只有一个线程池来维护客户端发送的所有的请求，这时候某一接口在某一时刻被大量访问就会占据tomcat线程池中的所有线程，其他请求处于等待状态，无法连接到服务接口。</li>
</ul>
<h2 id="谈谈服务降级、熔断、服务隔离"><a href="#谈谈服务降级、熔断、服务隔离" class="headerlink" title="谈谈服务降级、熔断、服务隔离"></a>谈谈服务降级、熔断、服务隔离</h2><ul>
<li>服务降级：当客户端请求服务器端的时候，防止客户端一直等待，不会处理业务逻辑代码，直接返回一个友好的提示给客户端。</li>
<li>服务熔断是在服务降级的基础上更直接的一种保护方式，当在一个统计时间范围内的请求失败数量达到设定值（requestVolumeThreshold）或当前的请求错误率达到设定的错误率阈值（errorThresholdPercentage）时开启断路，之后的请求直接走fallback方法，在设定时间（sleepWindowInMilliseconds）后尝试恢复。</li>
<li>服务隔离就是Hystrix为隔离的服务开启一个独立的线程池，这样在高并发的情况下不会影响其他服务。服务隔离有线程池和信号量两种实现方式，一般使用线程池方式。</li>
</ul>
<h2 id="服务降级底层是如何实现的？"><a href="#服务降级底层是如何实现的？" class="headerlink" title="服务降级底层是如何实现的？"></a>服务降级底层是如何实现的？</h2><ul>
<li>Hystrix实现服务降级的功能是通过重写HystrixCommand中的getFallback()方法，当Hystrix的run方法或construct执行发生错误时转而执行getFallback()方法。</li>
</ul>
<h1 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h1><h2 id="什么是Feign？"><a href="#什么是Feign？" class="headerlink" title="什么是Feign？"></a>什么是Feign？</h2><ul>
<li>Feign 是一个声明web服务客户端，这使得编写web服务客户端更容易</li>
<li>他将我们需要调用的服务方法定义成抽象方法保存在本地就可以了，不需要自己构建Http请求了，直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。</li>
</ul>
<h2 id="SpringCloud有几种调用接口方式"><a href="#SpringCloud有几种调用接口方式" class="headerlink" title="SpringCloud有几种调用接口方式"></a>SpringCloud有几种调用接口方式</h2><ul>
<li>Feign</li>
<li>RestTemplate</li>
</ul>
<h2 id="Ribbon和Feign调用服务的区别"><a href="#Ribbon和Feign调用服务的区别" class="headerlink" title="Ribbon和Feign调用服务的区别"></a>Ribbon和Feign调用服务的区别</h2><ul>
<li>调用方式同：Ribbon需要我们自己构建Http请求，模拟Http请求然后通过RestTemplate发给其他服务，步骤相当繁琐</li>
<li>而Feign则是在Ribbon的基础上进行了一次改进，采用接口的形式，将我们需要调用的服务方法定义成抽象方法保存在本地就可以了，不需要自己构建Http请求了，直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。</li>
</ul>
<h1 id="Bus"><a href="#Bus" class="headerlink" title="Bus"></a>Bus</h1><h2 id="什么是-Spring-Cloud-Bus？"><a href="#什么是-Spring-Cloud-Bus？" class="headerlink" title="什么是 Spring Cloud Bus？"></a>什么是 Spring Cloud Bus？</h2><ul>
<li>Spring Cloud Bus就像一个分布式执行器，用于扩展的Spring Boot应用程序的配置文件，但也可以用作应用程序之间的通信通道。</li>
<li>Spring Cloud Bus 不能单独完成通信，需要配合MQ支持</li>
<li>Spring Cloud Bus一般是配合Spring Cloud Config做配置中心的</li>
<li>Springcloud config实时刷新也必须采用SpringCloud Bus消息总线</li>
</ul>
<h1 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h1><h2 id="什么是Spring-Cloud-Config"><a href="#什么是Spring-Cloud-Config" class="headerlink" title="什么是Spring Cloud Config?"></a>什么是Spring Cloud Config?</h2><ul>
<li>Spring Cloud Config为分布式系统中的外部配置提供服务器和客户端支持，可以方便的对微服务各个环境下的配置进行集中式管理。Spring Cloud Config分为Config Server和Config Client两部分。Config Server负责读取配置文件，并且暴露Http API接口，Config Client通过调用Config Server的接口来读取配置文件。</li>
</ul>
<h2 id="分布式配置中心有那些框架？"><a href="#分布式配置中心有那些框架？" class="headerlink" title="分布式配置中心有那些框架？"></a>分布式配置中心有那些框架？</h2><ul>
<li>Apollo、zookeeper、springcloud config。</li>
</ul>
<h2 id="分布式配置中心的作用？"><a href="#分布式配置中心的作用？" class="headerlink" title="分布式配置中心的作用？"></a>分布式配置中心的作用？</h2><ul>
<li>动态变更项目配置信息而不必重新部署项目。</li>
</ul>
<h2 id="SpringCloud-Config-可以实现实时刷新吗？"><a href="#SpringCloud-Config-可以实现实时刷新吗？" class="headerlink" title="SpringCloud Config 可以实现实时刷新吗？"></a>SpringCloud Config 可以实现实时刷新吗？</h2><ul>
<li>springcloud config实时刷新采用SpringCloud Bus消息总线。</li>
</ul>
<h1 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h1><h2 id="什么是Spring-Cloud-Gateway"><a href="#什么是Spring-Cloud-Gateway" class="headerlink" title="什么是Spring Cloud Gateway?"></a>什么是Spring Cloud Gateway?</h2><ul>
<li>Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。</li>
<li>使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。</li>
</ul>
<h1 id="SpringCloud主要项目"><a href="#SpringCloud主要项目" class="headerlink" title="SpringCloud主要项目"></a>SpringCloud主要项目</h1><ul>
<li>Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架”Spring Boot化”的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色。</li>
</ul>
<h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><ul>
<li>Config能够管理所有微服务的配置文件</li>
<li>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。</li>
</ul>
<h3 id="Spring-Cloud-Netflix-重点，这些组件用的最多"><a href="#Spring-Cloud-Netflix-重点，这些组件用的最多" class="headerlink" title="Spring Cloud Netflix(重点，这些组件用的最多)"></a>Spring Cloud Netflix(重点，这些组件用的最多)</h3><ul>
<li>Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。<ul>
<li>Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；</li>
<li>Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；</li>
<li>Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；</li>
<li>Feign：基于Ribbon和Hystrix的声明式服务调用组件；</li>
<li>Zuul：API网关组件，对请求提供路由及过滤功能。</li>
</ul>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">我觉得SpringCloud的福音是Netflix，他把人家的组件都搬来进行封装了，使开发者能快速简单安全的使用<br></code></pre></td></tr></table></figure>

<h3 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h3><ul>
<li>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置信息。</li>
<li>简单来说就是修改了配置文件，发送一次请求，所有客户端便会重新读取配置文件。<ul>
<li>需要利用中间插件MQ</li>
</ul>
</li>
</ul>
<h3 id="Spring-Cloud-Consul"><a href="#Spring-Cloud-Consul" class="headerlink" title="Spring Cloud Consul"></a>Spring Cloud Consul</h3><ul>
<li>Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其它分布式服务注册与发现的方案，Consul 的方案更“一站式”，内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key&#x2F;Value 存储、多数据中心方案，不再需要依赖其它工具（比如 ZooKeeper 等）。使用起来也较为简单。Consul 使用 Go 语言编写，因此具有天然可移植性(支持Linux、windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署，与 Docker 等轻量级容器可无缝配合。</li>
</ul>
<h3 id="Spring-Cloud-Security"><a href="#Spring-Cloud-Security" class="headerlink" title="Spring Cloud Security"></a>Spring Cloud Security</h3><ul>
<li>安全工具包，他可以对<ul>
<li>对Zuul代理中的负载均衡从前端到后端服务中获取SSO令牌</li>
<li>资源服务器之间的中继令牌</li>
<li>使Feign客户端表现得像<code>OAuth2RestTemplate</code>（获取令牌等）的拦截器</li>
<li>在Zuul代理中配置下游身份验证</li>
</ul>
</li>
<li>Spring Cloud Security提供了一组原语，用于构建安全的应用程序和服务，而且操作简便。可以在外部（或集中）进行大量配置的声明性模型有助于实现大型协作的远程组件系统，通常具有中央身份管理服务。它也非常易于在Cloud Foundry等服务平台中使用。在Spring Boot和Spring Security OAuth2的基础上，可以快速创建实现常见模式的系统，如单点登录，令牌中继和令牌交换。</li>
</ul>
<h3 id="Spring-Cloud-Sleuth"><a href="#Spring-Cloud-Sleuth" class="headerlink" title="Spring Cloud Sleuth"></a>Spring Cloud Sleuth</h3><ul>
<li>在微服务中，通常根据业务模块分服务，项目中前端发起一个请求，后端可能跨几个服务调用才能完成这个请求（如下图）。如果系统越来越庞大，服务之间的调用与被调用关系就会变得很复杂，假如一个请求中需要跨几个服务调用，其中一个服务由于网络延迟等原因挂掉了，那么这时候我们需要分析具体哪一个服务出问题了就会显得很困难。Spring Cloud Sleuth服务链路跟踪功能就可以帮助我们快速的发现错误根源以及监控分析每条请求链路上的性能等等。 <img src="https://user-gold-cdn.xitu.io/2020/4/13/17172a98478b000a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" lazyload alt="20180927153655583"></li>
</ul>
<h3 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h3><ul>
<li>轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。</li>
</ul>
<h3 id="Spring-Cloud-Task"><a href="#Spring-Cloud-Task" class="headerlink" title="Spring Cloud Task"></a>Spring Cloud Task</h3><ul>
<li>Spring Cloud Task的目标是为Spring Boot应用程序提供创建短运行期微服务的功能。在Spring Cloud Task中，我们可以灵活地动态运行任何任务，按需分配资源并在任务完成后检索结果。Tasks是Spring Cloud Data Flow中的一个基础项目，允许用户将几乎任何Spring Boot应用程序作为一个短期任务执行。</li>
</ul>
<h3 id="Spring-Cloud-Zookeeper"><a href="#Spring-Cloud-Zookeeper" class="headerlink" title="Spring Cloud Zookeeper"></a>Spring Cloud Zookeeper</h3><ul>
<li>SpringCloud支持三种注册方式Eureka， Consul(go语言编写)，zookeeper</li>
<li>Spring Cloud Zookeeper是基于Apache Zookeeper的服务治理组件。</li>
</ul>
<h3 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h3><ul>
<li>Spring cloud gateway是spring官方基于Spring 5.0、Spring Boot2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供简单、有效和统一的API路由管理方式，Spring Cloud Gateway作为Spring Cloud生态系统中的网关，目标是替代Netflix Zuul，其不仅提供统一的路由方式，并且还基于Filer链的方式提供了网关基本的功能，例如：安全、监控&#x2F;埋点、限流等。</li>
</ul>
<h3 id="Spring-Cloud-OpenFeign"><a href="#Spring-Cloud-OpenFeign" class="headerlink" title="Spring Cloud OpenFeign"></a>Spring Cloud OpenFeign</h3><ul>
<li>Feign是一个声明性的Web服务客户端。它使编写Web服务客户端变得更容易。要使用Feign，我们可以将调用的服务方法定义成抽象方法保存在本地添加一点点注解就可以了，不需要自己构建Http请求了，直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。</li>
</ul>
<p>作者：小杰要吃蛋<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125717544973">https://juejin.cn/post/6844904125717544973</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h2><p>设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p>
<h2 id="为什么要学习设计模式"><a href="#为什么要学习设计模式" class="headerlink" title="为什么要学习设计模式"></a>为什么要学习设计模式</h2><p>看懂源代码：如果你不懂设计模式去看JDK、Spring、SpringMVC、IO等等的源码，你会很迷茫，你会寸步难行<br>看看前辈的代码：你去个公司难道都是新项目让你接手？很有可能是接盘的，前辈的开发难道不用设计模式？<br>编写自己的理想中的好代码：我个人反正是这样的，对于我自己开发的项目我会很认真，我对他比对我女朋友还好，把项目当成自己的儿子一样</p>
<h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<p><img src="/images%5C20200411190730722.jpg" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><p><img src="/images%5C20200411190736327.jpg" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h3 id="开放封闭原则（Open-Close-Principle）"><a href="#开放封闭原则（Open-Close-Principle）" class="headerlink" title="开放封闭原则（Open Close Principle）"></a>开放封闭原则（Open Close Principle）</h3><p>原则思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化<br>描述：一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。<br>优点：单一原则告诉我们，每个类都有自己负责的职责，里氏替换原则不能破坏继承关系的体系。</p>
<h3 id="里氏代换原则（Liskov-Substitution-Principle）"><a href="#里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏代换原则（Liskov Substitution Principle）"></a>里氏代换原则（Liskov Substitution Principle）</h3><p>原则思想：使用的基类可以在任何地方使用继承的子类，完美的替换基类。<br>大概意思是：子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法，子类中可以增加自己特有的方法。<br>优点：增加程序的健壮性，即使增加了子类，原有的子类还可以继续运行，互不影响。</p>
<h3 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h3><p>依赖倒置原则的核心思想是面向接口编程.</p>
<p>依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，</p>
<p>这个是开放封闭原则的基础，具体内容是：对接口编程，依赖于抽象而不依赖于具体。</p>
<h3 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h3><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。<br>例如：支付类的接口和订单类的接口，需要把这俩个类别的接口变成俩个隔离的接口</p>
<h3 id="迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="迪米特法则（最少知道原则）（Demeter Principle）"></a>迪米特法则（最少知道原则）（Demeter Principle）</h3><p>原则思想：一个对象应当对其他对象有尽可能少地了解，简称类间解耦<br>大概意思就是一个类尽量减少自己对其他对象的依赖，原则是低耦合，高内聚，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。<br>优点：低耦合，高内聚。</p>
<h3 id="单一职责原则（Principle-of-single-responsibility）"><a href="#单一职责原则（Principle-of-single-responsibility）" class="headerlink" title="单一职责原则（Principle of single responsibility）"></a>单一职责原则（Principle of single responsibility）</h3><p>原则思想：一个方法只负责一件事情。<br>描述：单一职责原则很简单，一个方法 一个类只负责一个职责，各个职责的程序改动，不影响其它程序。 这是常识，几乎所有程序员都会遵循这个原则。<br>优点：降低类和类的耦合，提高可读性，增加可维护性和可拓展性，降低可变性的风险。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="1-什么是单例"><a href="#1-什么是单例" class="headerlink" title="1. 什么是单例"></a>1. 什么是单例</h3><p>保证一个类只有一个实例，并且提供一个访问该全局访问点</p>
<h3 id="2-那些地方用到了单例模式"><a href="#2-那些地方用到了单例模式" class="headerlink" title="2. 那些地方用到了单例模式"></a>2. 那些地方用到了单例模式</h3><p>网站的计数器，一般也是采用单例模式实现，否则难以同步。<br>应用程序的日志应用，一般都是单例模式实现，只有一个实例去操作才好，否则内容不好追加显示。<br>多线程的线程池的设计一般也是采用单例模式，因为线程池要方便对池中的线程进行控制<br>Windows的（任务管理器）就是很典型的单例模式，他不能打开俩个<br>Windows的（回收站）也是典型的单例应用。在整个系统运行过程中，回收站只维护一个实例。</p>
<h3 id="3-单例优缺点"><a href="#3-单例优缺点" class="headerlink" title="3. 单例优缺点"></a>3. 单例优缺点</h3><ul>
<li>优点：</li>
</ul>
<p>在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就防止其它对象对自己的实例化，确保所有的对象都访问一个实例<br>单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。<br>提供了对唯一实例的受控访问。<br>由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。<br>允许可变数目的实例。<br>避免对共享资源的多重占用。</p>
<ul>
<li>缺点：</li>
</ul>
<p>不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。<br>由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。<br>单例类的职责过重，在一定程度上违背了“单一职责原则”。<br>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</p>
<h3 id="4-单例模式使用注意事项："><a href="#4-单例模式使用注意事项：" class="headerlink" title="4. 单例模式使用注意事项："></a>4. 单例模式使用注意事项：</h3><p>使用时不能用反射模式创建单例，否则会实例化一个新的对象<br>使用懒单例模式时注意线程安全问题<br>饿单例模式和懒单例模式构造方法都是私有的，因而是不能被继承的，有些单例模式可以被继承（如登记式模式）</p>
<h3 id="5-单例防止反射漏洞攻击"><a href="#5-单例防止反射漏洞攻击" class="headerlink" title="5. 单例防止反射漏洞攻击"></a>5. 单例防止反射漏洞攻击</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br><br>	<span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">false</span>) &#123;<br>		flag = !flag;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;单例模式被侵犯！&quot;</span>);<br>	&#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="6-如何选择单例创建方式"><a href="#6-如何选择单例创建方式" class="headerlink" title="6. 如何选择单例创建方式"></a>6. 如何选择单例创建方式</h3><p>如果不需要延迟加载单例，可以使用枚举或者饿汉式，相对来说枚举性好于饿汉式。<br>如果需要延迟加载，可以使用静态内部类或者懒汉式，相对来说静态内部类好于懒韩式。<br>最好使用饿汉式</p>
<h3 id="7-单例创建方式"><a href="#7-单例创建方式" class="headerlink" title="7. 单例创建方式"></a>7. 单例创建方式</h3><p>（主要使用懒汉和懒汉式）</p>
<p>饿汉式：类初始化时，会立即加载该对象，线程天生安全,调用效率高。<br>懒汉式：类初始化时，不会初始化该对象，真正需要使用的时候才会创建该对象,具备懒加载功能。<br>静态内部方式：结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。<br>枚举单例：使用枚举实现单例模式，优点：实现简单、调用效率高，枚举本身就是单例，由jvm从根本上提供保障！避免通过反射和反序列化的漏洞， 缺点没有延迟加载。<br>双重检测锁方式 (因为JVM本质重排序的原因，可能会初始化多次，不推荐使用)</p>
<h4 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1.饿汉式"></a>1.饿汉式</h4><p>饿汉式:类初始化时,会立即加载该对象，线程天生安全,调用效率高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-comment">//饿汉式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><br>    <span class="hljs-comment">// 类初始化时,会立即加载该对象，线程安全,调用效率高</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Demo1</span> <span class="hljs-variable">demo1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo1</span>();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Demo1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;私有Demo1构造参数初始化&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Demo1 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> demo1;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Demo1</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> Demo1.getInstance();<br>        <span class="hljs-type">Demo1</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> Demo1.getInstance();<br>        System.out.println(s1 == s2);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2.懒汉式"></a>2.懒汉式</h4><p>懒汉式: 类初始化时,不会初始化该对象,真正需要使用的时候才会创建该对象,具备懒加载功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-comment">//懒汉式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> &#123;<br><br>    <span class="hljs-comment">//类初始化时，不会初始化该对象，真正需要使用的时候才会创建该对象。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Demo2 demo2;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Demo2</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;私有Demo2构造参数初始化&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> Demo2 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (demo2 == <span class="hljs-literal">null</span>) &#123;<br>            demo2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo2</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> demo2;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Demo2</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> Demo2.getInstance();<br>        <span class="hljs-type">Demo2</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> Demo2.getInstance();<br>        System.out.println(s1 == s2);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="3-静态内部类"><a href="#3-静态内部类" class="headerlink" title="3.静态内部类"></a>3.静态内部类</h4><p>静态内部方式:结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-comment">// 静态内部类方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Demo3</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;私有Demo3构造参数初始化&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonClassInstance</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Demo3</span> <span class="hljs-variable">DEMO_3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo3</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 方法没有同步</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Demo3 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonClassInstance.DEMO_3;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Demo3</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> Demo3.getInstance();<br>        <span class="hljs-type">Demo3</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> Demo3.getInstance();<br>        System.out.println(s1 == s2);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="4-枚举单例式"><a href="#4-枚举单例式" class="headerlink" title="4.枚举单例式"></a>4.枚举单例式</h4><p>枚举单例: 使用枚举实现单例模式 优点:实现简单、调用效率高，枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞， 缺点没有延迟加载。<br>package com.lijie;</p>
<p>&#x2F;&#x2F;使用枚举实现单例模式 优点:实现简单、枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞 缺点没有延迟加载<br>public class Demo4 {</p>
<pre><code class="hljs">public static Demo4 getInstance() &#123;
    return Demo.INSTANCE.getInstance();
&#125;

public static void main(String[] args) &#123;
    Demo4 s1 = Demo4.getInstance();
    Demo4 s2 = Demo4.getInstance();
    System.out.println(s1 == s2);
&#125;

//定义枚举
private static enum Demo &#123;
    INSTANCE;
    // 枚举元素为单例
    private Demo4 demo4;

    private Demo() &#123;
        System.out.println(&quot;枚举Demo私有构造参数&quot;);
        demo4 = new Demo4();
    &#125;

    public Demo4 getInstance() &#123;
        return demo4;
    &#125;
&#125;
</code></pre>
<p>}</p>
<h4 id="5-双重检测锁方式"><a href="#5-双重检测锁方式" class="headerlink" title="5.双重检测锁方式"></a>5.双重检测锁方式</h4><p>双重检测锁方式 (因为JVM本质重排序的原因，可能会初始化多次，不推荐使用)<br>package com.lijie;</p>
<p>&#x2F;&#x2F;双重检测锁方式<br>public class Demo5 {</p>
<pre><code class="hljs">private static Demo5 demo5;

private Demo5() &#123;
    System.out.println(&quot;私有Demo4构造参数初始化&quot;);
&#125;

public static Demo5 getInstance() &#123;
    if (demo5 == null) &#123;
        synchronized (Demo5.class) &#123;
            if (demo5 == null) &#123;
                demo5 = new Demo5();
            &#125;
        &#125;
    &#125;
    return demo5;
&#125;

public static void main(String[] args) &#123;
    Demo5 s1 = Demo5.getInstance();
    Demo5 s2 = Demo5.getInstance();
    System.out.println(s1 == s2);
&#125;
</code></pre>
<p>}</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="1-什么是工厂模式"><a href="#1-什么是工厂模式" class="headerlink" title="1.什么是工厂模式"></a>1.什么是工厂模式</h3><p>它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。实现了创建者和调用者分离，工厂模式分为简单工厂、工厂方法、抽象工厂模式</p>
<h3 id="2-工厂模式好处"><a href="#2-工厂模式好处" class="headerlink" title="2.工厂模式好处"></a>2.工厂模式好处</h3><p>工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。<br>利用工厂模式可以降低程序的耦合性，为后期的维护修改提供了很大的便利。<br>将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。</p>
<h3 id="3-为什么要学习工厂设计模式"><a href="#3-为什么要学习工厂设计模式" class="headerlink" title="3.为什么要学习工厂设计模式"></a>3.为什么要学习工厂设计模式</h3><p>不知道你们面试题问到过源码没有，你知道Spring的源码吗，MyBatis的源码吗，等等等<br>如果你想学习很多框架的源码，或者你想自己开发自己的框架，就必须先掌握设计模式（工厂设计模式用的是非常非常广泛的）</p>
<h3 id="4-Spring开发中的工厂设计模式"><a href="#4-Spring开发中的工厂设计模式" class="headerlink" title="4.Spring开发中的工厂设计模式"></a>4.Spring开发中的工厂设计模式</h3><h4 id="1-Spring-IoC"><a href="#1-Spring-IoC" class="headerlink" title="1.Spring IoC"></a>1.Spring IoC</h4><p>看过Spring源码就知道，在Spring IoC容器创建bean的过程是使用了工厂设计模式</p>
<p>Spring中无论是通过xml配置还是通过配置类还是注解进行创建bean，大部分都是通过简单工厂来进行创建的。</p>
<p>当容器拿到了beanName和class类型后，动态的通过反射创建具体的某个对象，最后将创建的对象放到Map中。</p>
<h4 id="2-为什么Spring-IoC要使用工厂设计模式创建Bean呢"><a href="#2-为什么Spring-IoC要使用工厂设计模式创建Bean呢" class="headerlink" title="2.为什么Spring IoC要使用工厂设计模式创建Bean呢"></a>2.为什么Spring IoC要使用工厂设计模式创建Bean呢</h4><p>在实际开发中，如果我们A对象调用B，B调用C，C调用D的话我们程序的耦合性就会变高。（耦合大致分为类与类之间的依赖，方法与方法之间的依赖。）</p>
<p>在很久以前的三层架构编程时，都是控制层调用业务层，业务层调用数据访问层时，都是是直接new对象，耦合性大大提升，代码重复量很高，对象满天飞。为了避免这种情况，Spring使用工厂模式编程，写一个工厂，由工厂创建Bean，以后我们如果要对象就直接管工厂要就可以，剩下的事情不归我们管了。Spring IOC容器的工厂中有个静态的Map集合，是为了让工厂符合单例设计模式，即每个对象只生产一次，生产出对象后就存入到Map集合中，保证了实例不会重复影响程序效率。</p>
<h3 id="5-工厂模式分类"><a href="#5-工厂模式分类" class="headerlink" title="5.工厂模式分类"></a>5.工厂模式分类</h3><p>工厂模式分为简单工厂、工厂方法、抽象工厂模式</p>
<ul>
<li>简单工厂 ：用来生产同一等级结构中的任意产品。（不支持拓展增加产品）</li>
<li>工厂方法 ：用来生产同一等级结构中的固定产品。（支持拓展增加产品）   </li>
<li>抽象工厂 ：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）</li>
</ul>
<p>我下面来使用代码演示一下：</p>
<h4 id="5-1-简单工厂模式"><a href="#5-1-简单工厂模式" class="headerlink" title="5.1 简单工厂模式"></a>5.1 简单工厂模式</h4><p>什么是简单工厂模式</p>
<p>简单工厂模式相当于是一个工厂中有各种产品，创建在一个类中，客户无需知道具体产品的名称，只需要知道产品类所对应的参数即可。但是工厂的职责过重，而且当类型过多时不利于系统的扩展维护。<br>代码演示：</p>
<p>创建工厂<br>package com.lijie;</p>
<p>public interface Car {<br>    public void run();<br>}</p>
<p>创建工厂的产品（宝马）<br>package com.lijie;</p>
<p>public class Bmw implements Car {<br>    public void run() {<br>        System.out.println(“我是宝马汽车…”);<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>创建工另外一种产品（奥迪）<br>package com.lijie;</p>
<p>public class AoDi implements Car {<br>    public void run() {<br>        System.out.println(“我是奥迪汽车..”);<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>创建核心工厂类，由他决定具体调用哪产品<br>package com.lijie;</p>
<p>public class CarFactory {</p>
<pre><code class="hljs"> public static Car createCar(String name) &#123;
    if (&quot;&quot;.equals(name)) &#123;
         return null;
    &#125;
    if(name.equals(&quot;奥迪&quot;))&#123;
        return new AoDi();
    &#125;
    if(name.equals(&quot;宝马&quot;))&#123;
        return new Bmw();
    &#125;
    return null;
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>演示创建工厂的具体实例<br>package com.lijie;</p>
<p>public class Client01 {</p>
<pre><code class="hljs">public static void main(String[] args) &#123;
    Car aodi  =CarFactory.createCar(&quot;奥迪&quot;);
    Car bmw  =CarFactory.createCar(&quot;宝马&quot;);
    aodi.run();
    bmw.run();
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>单工厂的优点&#x2F;缺点</p>
<p>优点：简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。明确区分了各自的职责和权力，有利于整个软件体系结构的优化。<br>缺点：很明显工厂类集中了所有实例的创建逻辑，容易违反GRASPR的高内聚的责任分配原则</p>
<h4 id="5-2-工厂方法模式"><a href="#5-2-工厂方法模式" class="headerlink" title="5.2 工厂方法模式"></a>5.2 工厂方法模式</h4><p>什么是工厂方法模式</p>
<p>工厂方法模式Factory Method，又称多态性工厂模式。在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节<br>代码演示：</p>
<p>创建工厂<br>package com.lijie;</p>
<p>public interface Car {<br>    public void run();<br>}<br>1<br>2<br>3<br>4<br>5<br>创建工厂方法调用接口（所有的产品需要new出来必须继承他来实现方法）<br>package com.lijie;</p>
<p>public interface CarFactory {</p>
<pre><code class="hljs">Car createCar();
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>创建工厂的产品（奥迪）<br>package com.lijie;</p>
<p>public class AoDi implements Car {<br>    public void run() {<br>        System.out.println(“我是奥迪汽车..”);<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>创建工厂另外一种产品（宝马）<br>package com.lijie;</p>
<p>public class Bmw implements Car {<br>    public void run() {<br>        System.out.println(“我是宝马汽车…”);<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>创建工厂方法调用接口的实例（奥迪）<br>package com.lijie;</p>
<p>public class AoDiFactory implements CarFactory {</p>
<pre><code class="hljs">public Car createCar() &#123;

    return new AoDi();
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>创建工厂方法调用接口的实例（宝马）<br>package com.lijie;</p>
<p>public class BmwFactory implements CarFactory {</p>
<pre><code class="hljs">public Car createCar() &#123;

    return new Bmw();
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>演示创建工厂的具体实例<br>package com.lijie;</p>
<p>public class Client {</p>
<pre><code class="hljs">public static void main(String[] args) &#123;
    Car aodi = new AoDiFactory().createCar();
    Car jili = new BmwFactory().createCar();
    aodi.run();
    jili.run();
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11</p>
<h4 id="5-3-抽象工厂模式"><a href="#5-3-抽象工厂模式" class="headerlink" title="5.3 抽象工厂模式"></a>5.3 抽象工厂模式</h4><p>什么是抽象工厂模式</p>
<p>抽象工厂简单地说是工厂的工厂，抽象工厂可以创建具体工厂，由具体工厂来产生具体产品。</p>
<p>代码演示：<br>创建第一个子工厂，及实现类<br>package com.lijie;</p>
<p>&#x2F;&#x2F;汽车<br>public interface Car {<br>       void run();<br>}</p>
<p> class CarA implements Car{</p>
<pre><code class="hljs">public void run() &#123;
    System.out.println(&quot;宝马&quot;);
&#125;
</code></pre>
<p>}<br> class CarB implements Car{</p>
<pre><code class="hljs">public void run() &#123;
    System.out.println(&quot;摩拜&quot;);
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>创建第二个子工厂，及实现类<br>package com.lijie;</p>
<p>&#x2F;&#x2F;发动机<br>public interface Engine {</p>
<pre><code class="hljs">void run();
</code></pre>
<p>}</p>
<p>class EngineA implements Engine {</p>
<pre><code class="hljs">public void run() &#123;
    System.out.println(&quot;转的快!&quot;);
&#125;
</code></pre>
<p>}</p>
<p>class EngineB implements Engine {</p>
<pre><code class="hljs">public void run() &#123;
    System.out.println(&quot;转的慢!&quot;);
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>创建一个总工厂，及实现类（由总工厂的实现类决定调用那个工厂的那个实例）<br>package com.lijie;</p>
<p>public interface TotalFactory {<br>    &#x2F;&#x2F; 创建汽车<br>    Car createChair();<br>    &#x2F;&#x2F; 创建发动机<br>    Engine createEngine();<br>}</p>
<p>&#x2F;&#x2F;总工厂实现类，由他决定调用哪个工厂的那个实例<br>class TotalFactoryReally implements TotalFactory {</p>
<pre><code class="hljs">public Engine createEngine() &#123;

    return new EngineA();
&#125;

public Car createChair() &#123;

    return new CarA();
&#125;
</code></pre>
<p>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>运行测试<br>package com.lijie;</p>
<p>public class Test {</p>
<pre><code class="hljs">public static void main(String[] args) &#123;
    TotalFactory totalFactory2 = new TotalFactoryReally();
    Car car = totalFactory2.createChair();
    car.run();

    TotalFactory totalFactory = new TotalFactoryReally();
    Engine engine = totalFactory.createEngine();
    engine.run();
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="1-什么是代理模式"><a href="#1-什么是代理模式" class="headerlink" title="1.什么是代理模式"></a>1.什么是代理模式</h3><p>通过代理控制对象的访问，可以在这个对象调用方法之前、调用方法之后去处理&#x2F;添加新的功能。(也就是AO的P微实现)</p>
<p>代理在原有代码乃至原业务流程都不修改的情况下，直接在业务流程中切入新代码，增加新功能，这也和 Spring 的（面向切面编程）很相似</p>
<h3 id="2-代理模式应用场景"><a href="#2-代理模式应用场景" class="headerlink" title="2.代理模式应用场景"></a>2.代理模式应用场景</h3><p>Spring AOP、日志打印、异常处理、事务控制、权限控制等</p>
<h3 id="3-代理的分类"><a href="#3-代理的分类" class="headerlink" title="3.代理的分类"></a>3.代理的分类</h3><p>静态代理(静态定义代理类)<br>动态代理(动态生成代理类，也称为Jdk自带动态代理)<br>Cglib 、javaassist（字节码操作库）</p>
<h3 id="4-三种代理的区别"><a href="#4-三种代理的区别" class="headerlink" title="4.三种代理的区别"></a>4.三种代理的区别</h3><p>静态代理：简单代理模式，是动态代理的理论基础。常见使用在代理模式<br>jdk动态代理：使用反射完成代理。需要有顶层接口才能使用，常见是mybatis的mapper文件是代理。<br>cglib动态代理：也是使用反射完成代理，可以直接代理类（jdk动态代理不行），使用字节码技术，不能对 final类进行继承。（需要导入jar包）</p>
<h3 id="5-用代码演示三种代理"><a href="#5-用代码演示三种代理" class="headerlink" title="5.用代码演示三种代理"></a>5.用代码演示三种代理</h3><h4 id="5-1-静态代理"><a href="#5-1-静态代理" class="headerlink" title="5.1.静态代理"></a>5.1.静态代理</h4><p>什么是静态代理</p>
<p>由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。<br>代码演示：</p>
<p>我有一段这样的代码：（如何能在不修改UserDao接口类的情况下开事务和关闭事务呢）<br>package com.lijie;</p>
<p>&#x2F;&#x2F;接口类<br>public class UserDao{<br>    public void save() {<br>        System.out.println(“保存数据方法”);<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>package com.lijie;</p>
<p>&#x2F;&#x2F;运行测试类<br>public  class Test{<br>    public static void main(String[] args) {<br>        UserDao userDao &#x3D; new UserDao();<br>        userDao.save();<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>修改代码，添加代理类</p>
<p>package com.lijie;</p>
<p>&#x2F;&#x2F;代理类<br>public class UserDaoProxy extends UserDao {<br>    private UserDao userDao;</p>
<pre><code class="hljs">public UserDaoProxy(UserDao userDao) &#123;
    this.userDao = userDao;
&#125;

public void save() &#123;
    System.out.println(&quot;开启事物...&quot;);
    userDao.save();
    System.out.println(&quot;关闭事物...&quot;);
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>&#x2F;&#x2F;添加完静态代理的测试类<br>public class Test{<br>    public static void main(String[] args) {<br>        UserDao userDao &#x3D; new UserDao();<br>        UserDaoProxy userDaoProxy &#x3D; new UserDaoProxy(userDao);<br>        userDaoProxy.save();<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>缺点：每个需要代理的对象都需要自己重复编写代理，很不舒服，<br>优点：但是可以面相实际对象或者是接口的方式实现代理</p>
<h4 id="2-2-动态代理"><a href="#2-2-动态代理" class="headerlink" title="2.2.动态代理"></a>2.2.动态代理</h4><p>什么是动态代理</p>
<p>动态代理也叫做，JDK代理、接口代理。</p>
<p>动态代理的对象，是利用JDK的API，动态的在内存中构建代理对象（是根据被代理的接口来动态生成代理类的class文件，并加载运行的过程），这就叫动态代理</p>
<p>package com.lijie;</p>
<p>&#x2F;&#x2F;接口<br>public interface UserDao {<br>    void save();<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>package com.lijie;</p>
<p>&#x2F;&#x2F;接口实现类<br>public class UserDaoImpl implements UserDao {<br>    public void save() {<br>        System.out.println(“保存数据方法”);<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>&#x2F;&#x2F;下面是代理类，可重复使用，不像静态代理那样要自己重复编写代理<br>package com.lijie;</p>
<p>import java.lang.reflect.InvocationHandler;<br>import java.lang.reflect.Method;</p>
<p>&#x2F;&#x2F; 每次生成动态代理类对象时,实现了InvocationHandler接口的调用处理器对象<br>public class InvocationHandlerImpl implements InvocationHandler {</p>
<pre><code class="hljs">// 这其实业务实现类对象，用来调用具体的业务方法
private Object target;

// 通过构造函数传入目标对象
public InvocationHandlerImpl(Object target) &#123;
    this.target = target;
&#125;

//动态代理实际运行的代理方法
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
    System.out.println(&quot;调用开始处理&quot;);
    //下面invoke()方法是以反射的方式来创建对象，第一个参数是要创建的对象，第二个是构成方法的参数，由第二个参数来决定创建对象使用哪个构造方法
    Object result = method.invoke(target, args);
    System.out.println(&quot;调用结束处理&quot;);
    return result;
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>&#x2F;&#x2F;利用动态代理使用代理方法<br>package com.lijie;</p>
<p>import java.lang.reflect.Proxy;</p>
<p>public class Test {<br>    public static void main(String[] args) {<br>        &#x2F;&#x2F; 被代理对象<br>        UserDao userDaoImpl &#x3D; new UserDaoImpl();<br>        InvocationHandlerImpl invocationHandlerImpl &#x3D; new InvocationHandlerImpl(userDaoImpl);</p>
<pre><code class="hljs">    //类加载器
    ClassLoader loader = userDaoImpl.getClass().getClassLoader();
    Class&lt;?&gt;[] interfaces = userDaoImpl.getClass().getInterfaces();

    // 主要装载器、一组接口及调用处理动态代理实例
    UserDao newProxyInstance = (UserDao) Proxy.newProxyInstance(loader, interfaces, invocationHandlerImpl);
    newProxyInstance.save();
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>缺点：必须是面向接口，目标业务类必须实现接口<br>优点：不用关心代理类，只需要在运行阶段才指定代理哪一个对象</p>
<h4 id="5-3-CGLIB动态代理"><a href="#5-3-CGLIB动态代理" class="headerlink" title="5.3.CGLIB动态代理"></a>5.3.CGLIB动态代理</h4><p>CGLIB动态代理原理：</p>
<p>利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。<br>什么是CGLIB动态代理</p>
<p>CGLIB动态代理和jdk代理一样，使用反射完成代理，不同的是他可以直接代理类（jdk动态代理不行，他必须目标业务类必须实现接口），CGLIB动态代理底层使用字节码技术，CGLIB动态代理不能对 final类进行继承。（CGLIB动态代理需要导入jar包）<br>代码演示：</p>
<p>package com.lijie;</p>
<p>&#x2F;&#x2F;接口<br>public interface UserDao {<br>    void save();<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>package com.lijie;</p>
<p>&#x2F;&#x2F;接口实现类<br>public class UserDaoImpl implements UserDao {<br>    public void save() {<br>        System.out.println(“保存数据方法”);<br>    }<br>}</p>
<p>package com.lijie;</p>
<p>import org.springframework.cglib.proxy.Enhancer;<br>import org.springframework.cglib.proxy.MethodInterceptor;<br>import org.springframework.cglib.proxy.MethodProxy;<br>import java.lang.reflect.Method;</p>
<p>&#x2F;&#x2F;代理主要类<br>public class CglibProxy implements MethodInterceptor {<br>    private Object targetObject;<br>    &#x2F;&#x2F; 这里的目标类型为Object，则可以接受任意一种参数作为被代理类，实现了动态代理<br>    public Object getInstance(Object target) {<br>        &#x2F;&#x2F; 设置需要创建子类的类<br>        this.targetObject &#x3D; target;<br>        Enhancer enhancer &#x3D; new Enhancer();<br>        enhancer.setSuperclass(target.getClass());<br>        enhancer.setCallback(this);<br>        return enhancer.create();<br>    }</p>
<pre><code class="hljs">//代理实际方法
public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;
    System.out.println(&quot;开启事物&quot;);
    Object result = proxy.invoke(targetObject, args);
    System.out.println(&quot;关闭事物&quot;);
    // 返回代理对象
    return result;
&#125;
</code></pre>
<p>}</p>
<p>package com.lijie;</p>
<p>&#x2F;&#x2F;测试CGLIB动态代理<br>public class Test {<br>    public static void main(String[] args) {<br>        CglibProxy cglibProxy &#x3D; new CglibProxy();<br>        UserDao userDao &#x3D; (UserDao) cglibProxy.getInstance(new UserDaoImpl());<br>        userDao.save();<br>    }<br>}</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="1-什么是建造者模式"><a href="#1-什么是建造者模式" class="headerlink" title="1.什么是建造者模式"></a>1.什么是建造者模式</h3><p>建造者模式：是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的方式进行创建。</p>
<p>工厂类模式是提供的是创建单个类的产品</p>
<p>而建造者模式则是将各种产品集中起来进行管理，用来具有不同的属性的产品</p>
<p>建造者模式通常包括下面几个角色：</p>
<p>uilder：给出一个抽象接口，以规范产品对象的各个组成成分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br>ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。 在建造过程完成后，提供产品的实例。<br>Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br>Product：要创建的复杂对象。</p>
<h3 id="2-建造者模式的使用场景"><a href="#2-建造者模式的使用场景" class="headerlink" title="2.建造者模式的使用场景"></a>2.建造者模式的使用场景</h3><p>使用场景：</p>
<p>需要生成的对象具有复杂的内部结构。<br>需要生成的对象内部属性本身相互依赖。<br>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p>
<p>Java 中的 StringBuilder就是建造者模式创建的，他把一个单个字符的char数组组合起来</p>
<p>Spring不是建造者模式，它提供的操作应该是对于字符串本身的一些操作，而不是创建或改变一个字符串。</p>
<h3 id="3-代码案例"><a href="#3-代码案例" class="headerlink" title="3.代码案例"></a>3.代码案例</h3><p>建立一个装备对象Arms</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-comment">//装备类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Arms</span> &#123;<br>	<span class="hljs-comment">//头盔</span><br>	<span class="hljs-keyword">private</span> String helmet;<br>	<span class="hljs-comment">//铠甲</span><br>	<span class="hljs-keyword">private</span> String armor;<br>	<span class="hljs-comment">//武器</span><br>	<span class="hljs-keyword">private</span> String weapon;<br>	<br><br>	<span class="hljs-comment">//省略Git和Set方法...........</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建Builder接口（给出一个抽象接口，以规范产品对象的各个组成成分的建造，这个接口只是规范）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonBuilder</span> &#123;<br><br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">builderHelmetMurder</span><span class="hljs-params">()</span>;<br>	<br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">builderArmorMurder</span><span class="hljs-params">()</span>;<br>	<br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">builderWeaponMurder</span><span class="hljs-params">()</span>;<br>	<br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">builderHelmetYanLong</span><span class="hljs-params">()</span>;<br>	<br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">builderArmorYanLong</span><span class="hljs-params">()</span>;<br>	<br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">builderWeaponYanLong</span><span class="hljs-params">()</span>;<br>	<br>	Arms <span class="hljs-title function_">BuilderArms</span><span class="hljs-params">()</span>; <span class="hljs-comment">//组装</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建Builder实现类（这个类主要实现复杂对象创建的哪些部分需要什么属性）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArmsBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PersonBuilder</span> &#123;<br>    <span class="hljs-keyword">private</span> Arms arms;<br><br>    <span class="hljs-comment">//创建一个Arms实例,用于调用set方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArmsBuilder</span><span class="hljs-params">()</span> &#123;<br>        arms = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Arms</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">builderHelmetMurder</span><span class="hljs-params">()</span> &#123;<br>        arms.setHelmet(<span class="hljs-string">&quot;夺命头盔&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">builderArmorMurder</span><span class="hljs-params">()</span> &#123;<br>        arms.setArmor(<span class="hljs-string">&quot;夺命铠甲&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">builderWeaponMurder</span><span class="hljs-params">()</span> &#123;<br>        arms.setWeapon(<span class="hljs-string">&quot;夺命宝刀&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">builderHelmetYanLong</span><span class="hljs-params">()</span> &#123;<br>        arms.setHelmet(<span class="hljs-string">&quot;炎龙头盔&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">builderArmorYanLong</span><span class="hljs-params">()</span> &#123;<br>        arms.setArmor(<span class="hljs-string">&quot;炎龙铠甲&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">builderWeaponYanLong</span><span class="hljs-params">()</span> &#123;<br>        arms.setWeapon(<span class="hljs-string">&quot;炎龙宝刀&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> Arms <span class="hljs-title function_">BuilderArms</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> arms;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Director（调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonDirector</span> &#123;<br>	<br><br>	<span class="hljs-comment">//组装</span><br>	<span class="hljs-keyword">public</span> Arms <span class="hljs-title function_">constructPerson</span><span class="hljs-params">(PersonBuilder pb)</span> &#123;<br>		pb.builderHelmetYanLong();<br>		pb.builderArmorMurder();<br>		pb.builderWeaponMurder();<br>		<span class="hljs-keyword">return</span> pb.BuilderArms();<br>	&#125;<br>	<br>	<span class="hljs-comment">//这里进行测试</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-type">PersonDirector</span> <span class="hljs-variable">pb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonDirector</span>();<br>		<span class="hljs-type">Arms</span> <span class="hljs-variable">arms</span> <span class="hljs-operator">=</span> pb.constructPerson(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArmsBuilder</span>());<br>		System.out.println(arms.getHelmet());<br>		System.out.println(arms.getArmor());<br>		System.out.println(arms.getWeapon());<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><h3 id="1-什么是模板方法"><a href="#1-什么是模板方法" class="headerlink" title="1.什么是模板方法"></a>1.什么是模板方法</h3><p>模板方法模式：定义一个操作中的算法骨架（父类），而将一些步骤延迟到子类中。<br>模板方法使得子类可以不改变一个算法的结构来重定义该算法的</p>
<h3 id="2-什么时候使用模板方法"><a href="#2-什么时候使用模板方法" class="headerlink" title="2.什么时候使用模板方法"></a>2.什么时候使用模板方法</h3><p>实现一些操作时，整体步骤很固定，但是呢。就是其中一小部分需要改变，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</p>
<h3 id="3-实际开发中应用场景哪里用到了模板方法"><a href="#3-实际开发中应用场景哪里用到了模板方法" class="headerlink" title="3.实际开发中应用场景哪里用到了模板方法"></a>3.实际开发中应用场景哪里用到了模板方法</h3><p>其实很多框架中都有用到了模板方法模式<br>例如：数据库访问的封装、Junit单元测试、servlet中关于doGet&#x2F;doPost方法的调用等等<br>4.现实生活中的模板方法<br>例如：</p>
<p>去餐厅吃饭，餐厅给我们提供了一个模板就是：看菜单，点菜，吃饭，付款，走人<br>（这里 “点菜和付款” 是不确定的由子类来完成的，其他的则是一个模板。）<br>5.代码实现模板方法模式<br>先定义一个模板。把模板中的点菜和付款，让子类来实现。<br>package com.lijie;</p>
<p>&#x2F;&#x2F;模板方法<br>public abstract class RestaurantTemplate {</p>
<pre><code class="hljs">// 1.看菜单
public void menu() &#123;
    System.out.println(&quot;看菜单&quot;);
&#125;

// 2.点菜业务
abstract void spotMenu();

// 3.吃饭业务
public void havingDinner()&#123; System.out.println(&quot;吃饭&quot;); &#125;

// 3.付款业务
abstract void payment();

// 3.走人
public void GoR() &#123; System.out.println(&quot;走人&quot;); &#125;

//模板通用结构
public void process()&#123;
    menu();
    spotMenu();
    havingDinner();
    payment();
    GoR();
&#125;
</code></pre>
<p>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>具体的模板方法子类 1<br>package com.lijie;</p>
<p>public class RestaurantGinsengImpl extends RestaurantTemplate {</p>
<pre><code class="hljs">void spotMenu() &#123;
    System.out.println(&quot;人参&quot;);
&#125;

void payment() &#123;
    System.out.println(&quot;5快&quot;);
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>具体的模板方法子类 2<br>package com.lijie;</p>
<p>public class RestaurantLobsterImpl  extends RestaurantTemplate  {</p>
<pre><code class="hljs">void spotMenu() &#123;
    System.out.println(&quot;龙虾&quot;);
&#125;

void payment() &#123;
    System.out.println(&quot;50块&quot;);
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>客户端测试<br>package com.lijie;</p>
<p>public class Client {</p>
<pre><code class="hljs">public static void main(String[] args) &#123;
    //调用第一个模板实例
    RestaurantTemplate restaurantTemplate = new RestaurantGinsengImpl();
    restaurantTemplate.process();
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="1-什么是外观模式"><a href="#1-什么是外观模式" class="headerlink" title="1.什么是外观模式"></a>1.什么是外观模式</h3><p>外观模式：也叫门面模式，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。</p>
<p>它向现有的系统添加一个接口，用这一个接口来隐藏实际的系统的复杂性。</p>
<p>使用外观模式，他外部看起来就是一个接口，其实他的内部有很多复杂的接口已经被实现</p>
<h3 id="2-外观模式例子"><a href="#2-外观模式例子" class="headerlink" title="2.外观模式例子"></a>2.外观模式例子</h3><p>用户注册完之后，需要调用阿里短信接口、邮件接口、微信推送接口。<br>创建阿里短信接口<br>package com.lijie;</p>
<p>&#x2F;&#x2F;阿里短信消息<br>public interface AliSmsService {<br>    void sendSms();<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>package com.lijie;</p>
<p>public class AliSmsServiceImpl implements AliSmsService {</p>
<pre><code class="hljs">public void sendSms() &#123;
    System.out.println(&quot;阿里短信消息&quot;);
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>创建邮件接口<br>package com.lijie;</p>
<p>&#x2F;&#x2F;发送邮件消息<br>public interface EamilSmsService {<br>    void sendSms();<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>package com.lijie;</p>
<p>public class EamilSmsServiceImpl implements   EamilSmsService{<br>    public void sendSms() {<br>        System.out.println(“发送邮件消息”);<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>创建微信推送接口<br>package com.lijie;</p>
<p>&#x2F;&#x2F;微信消息推送<br>public interface WeiXinSmsService {<br>   void sendSms();<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>package com.lijie;</p>
<p>public class WeiXinSmsServiceImpl implements  WeiXinSmsService {<br>    public void sendSms() {<br>        System.out.println(“发送微信消息推送”);<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>创建门面（门面看起来很简单使用，复杂的东西以及被门面给封装好了）<br>package com.lijie;</p>
<p>public class Computer {<br>    AliSmsService aliSmsService;<br>    EamilSmsService eamilSmsService;<br>    WeiXinSmsService weiXinSmsService;</p>
<pre><code class="hljs">public Computer() &#123;
    aliSmsService = new AliSmsServiceImpl();
    eamilSmsService = new EamilSmsServiceImpl();
    weiXinSmsService = new WeiXinSmsServiceImpl();
&#125;

//只需要调用它
public void sendMsg() &#123;
    aliSmsService.sendSms();
    eamilSmsService.sendSms();
    weiXinSmsService.sendSms();
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>启动测试<br>package com.lijie;</p>
<p>public class Client {</p>
<pre><code class="hljs">public static void main(String[] args) &#123;
    //普通模式需要这样
    AliSmsService aliSmsService = new AliSmsServiceImpl();
    EamilSmsService eamilSmsService = new EamilSmsServiceImpl();
    WeiXinSmsService weiXinSmsService = new WeiXinSmsServiceImpl();
    aliSmsService.sendSms();
    eamilSmsService.sendSms();
    weiXinSmsService.sendSms();

    //利用外观模式简化方法
    new Computer().sendMsg();
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="1-什么是原型模式"><a href="#1-什么是原型模式" class="headerlink" title="1.什么是原型模式"></a>1.什么是原型模式</h3><p>原型设计模式简单来说就是克隆</p>
<p>原型表明了有一个样板实例，这个原型是可定制的。原型模式多用于创建复杂的或者构造耗时的实例，因为这种情况下，复制一个已经存在的实例可使程序运行更高效。</p>
<h3 id="2-原型模式的应用场景"><a href="#2-原型模式的应用场景" class="headerlink" title="2.原型模式的应用场景"></a>2.原型模式的应用场景</h3><p>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。这时我们就可以通过原型拷贝避免这些消耗。<br>通过new产生的一个对象需要非常繁琐的数据准备或者权限，这时可以使用原型模式。<br>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。<br>我们Spring框架中的多例就是使用原型。</p>
<h3 id="3-原型模式的使用方式"><a href="#3-原型模式的使用方式" class="headerlink" title="3.原型模式的使用方式"></a>3.原型模式的使用方式</h3><p>实现Cloneable接口。在java语言有一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。</p>
<p>重写Object类中的clone方法。Java中，所有类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因此Prototype类需要将clone方法的作用域修改为public类型。</p>
<h4 id="3-1原型模式分为浅复制和深复制"><a href="#3-1原型模式分为浅复制和深复制" class="headerlink" title="3.1原型模式分为浅复制和深复制"></a>3.1原型模式分为浅复制和深复制</h4><p>（浅复制）只是拷贝了基本类型的数据，而引用类型数据，只是拷贝了一份引用地址。</p>
<p>（深复制）在计算机中开辟了一块新的内存地址用于存放复制的对象。</p>
<h3 id="4-代码演示"><a href="#4-代码演示" class="headerlink" title="4.代码演示"></a>4.代码演示</h3><p>创建User类<br>package com.lijie;</p>
<p>import java.util.ArrayList;</p>
<p>public class User implements Cloneable {<br>    private String name;<br>    private String password;<br>    private ArrayList<String> phones;</p>
<pre><code class="hljs">protected User clone() &#123;
    try &#123;
        User user = (User) super.clone();
        //重点，如果要连带引用类型一起复制，需要添加底下一条代码，如果不加就对于是复制了引用地址
        user.phones = (ArrayList&lt;String&gt;) this.phones.clone();//设置深复制
        return user;
    &#125; catch (CloneNotSupportedException e) &#123;
        e.printStackTrace();
    &#125;
    return null;
&#125;

//省略所有属性Git Set方法......
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>测试复制<br>package com.lijie;</p>
<p>import java.util.ArrayList;</p>
<p>public class Client {<br>    public static void main(String[] args) {<br>        &#x2F;&#x2F;创建User原型对象<br>        User user &#x3D; new User();<br>        user.setName(“李三”);<br>        user.setPassword(“123456”);<br>        ArrayList<String> phones &#x3D; new ArrayList&lt;&gt;();<br>        phones.add(“17674553302”);<br>        user.setPhones(phones);</p>
<pre><code class="hljs">    //copy一个user对象,并且对象的属性
    User user2 = user.clone();
    user2.setPassword(&quot;654321&quot;);

    //查看俩个对象是否是一个
    System.out.println(user == user2);

    //查看属性内容
    System.out.println(user.getName() + &quot; | &quot; + user2.getName());
    System.out.println(user.getPassword() + &quot; | &quot; + user2.getPassword());
    //查看对于引用类型拷贝
    System.out.println(user.getPhones() == user2.getPhones());
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>如果不需要深复制，需要删除User 中的<br>&#x2F;&#x2F;默认引用类型为浅复制，这是设置了深复制<br>user.phones &#x3D; (ArrayList<String>) this.phones.clone();<br>1<br>2</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="1-什么是策略模式"><a href="#1-什么是策略模式" class="headerlink" title="1.什么是策略模式"></a>1.什么是策略模式</h3><p>定义了一系列的算法 或 逻辑 或 相同意义的操作，并将每一个算法、逻辑、操作封装起来，而且使它们还可以相互替换。（其实策略模式Java中用的非常非常广泛）</p>
<p>我觉得主要是为了 简化 if…else 所带来的复杂和难以维护。</p>
<h3 id="2-策略模式应用场景"><a href="#2-策略模式应用场景" class="headerlink" title="2.策略模式应用场景"></a>2.策略模式应用场景</h3><p>策略模式的用意是针对一组算法或逻辑，将每一个算法或逻辑封装到具有共同接口的独立的类中，从而使得它们之间可以相互替换。<br>例如：我要做一个不同会员打折力度不同的三种策略，初级会员，中级会员，高级会员（三种不同的计算）。</p>
<p>例如：我要一个支付模块，我要有微信支付、支付宝支付、银联支付等</p>
<h3 id="3-策略模式的优点和缺点"><a href="#3-策略模式的优点和缺点" class="headerlink" title="3.策略模式的优点和缺点"></a>3.策略模式的优点和缺点</h3><p>优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性非常良好。</p>
<p>缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。</p>
<h3 id="4-代码演示-1"><a href="#4-代码演示-1" class="headerlink" title="4.代码演示"></a>4.代码演示</h3><p>模拟支付模块有微信支付、支付宝支付、银联支付<br>定义抽象的公共方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-comment">//策略模式 定义抽象方法 所有支持公共接口</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PayStrategy</span> &#123;<br><br>	<span class="hljs-comment">// 支付逻辑方法</span><br>	<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithmInterface</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>




<p>定义实现微信支付</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.lijie;·<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayStrategyA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PayStrategy</span> </span>&#123;<br><br>	void algorithmInterface() &#123;<br>		<span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;微信支付&quot;</span>);<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>




<p>定义实现支付宝支付</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayStrategyB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PayStrategy</span> </span>&#123;<br><br>	void algorithmInterface() &#123;<br>		<span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;支付宝支付&quot;</span>);<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>






<p>定义实现银联支付</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayStrategyC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PayStrategy</span> </span>&#123;<br><br>	void algorithmInterface() &#123;<br>		<span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;银联支付&quot;</span>);<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>




<p>定义下文维护算法策略</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> com.lijie;<span class="hljs-comment">// 使用上下文维护算法策略</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<br><br>	PayStrategy strategy;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Context</span><span class="hljs-params">(PayStrategy strategy)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.strategy = strategy;<br>	&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">algorithmInterface</span><span class="hljs-params">()</span> </span>&#123;<br>		strategy.algorithmInterface();<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>





<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>运行测试<br>package com.lijie;</p>
<p>class ClientTestStrategy {<br>    public static void main(String[] args) {<br>        Context context;<br>        &#x2F;&#x2F;使用支付逻辑A<br>        context &#x3D; new Context(new PayStrategyA());<br>        context.algorithmInterface();<br>        &#x2F;&#x2F;使用支付逻辑B<br>        context &#x3D; new Context(new PayStrategyB());<br>        context.algorithmInterface();<br>        &#x2F;&#x2F;使用支付逻辑C<br>        context &#x3D; new Context(new PayStrategyC());<br>        context.algorithmInterface();<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="1-什么是观察者模式"><a href="#1-什么是观察者模式" class="headerlink" title="1.什么是观察者模式"></a>1.什么是观察者模式</h3><p>先讲什么是行为性模型，行为型模式关注的是系统中对象之间的相互交互，解决系统在运行时对象之间的相互通信和协作，进一步明确对象的职责。</p>
<p>观察者模式，是一种行为性模型，又叫发布-订阅模式，他定义对象之间一种一对多的依赖关系，使得当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。</p>
<h3 id="2-模式的职责"><a href="#2-模式的职责" class="headerlink" title="2.模式的职责"></a>2.模式的职责</h3><p>观察者模式主要用于1对N的通知。当一个对象的状态变化时，他需要及时告知一系列对象，令他们做出相应。<br>实现有两种方式：</p>
<p>推：每次都会把通知以广播的方式发送给所有观察者，所有的观察者只能被动接收。<br>拉：观察者只要知道有情况即可，至于什么时候获取内容，获取什么内容，都可以自主决定。</p>
<h3 id="3-观察者模式应用场景"><a href="#3-观察者模式应用场景" class="headerlink" title="3.观察者模式应用场景"></a>3.观察者模式应用场景</h3><p>关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。事件多级触发场景。<br>跨系统的消息交换场景，如消息队列、事件总线的处理机制。</p>
<h3 id="4-代码实现观察者模式"><a href="#4-代码实现观察者模式" class="headerlink" title="4.代码实现观察者模式"></a>4.代码实现观察者模式</h3><p>定义抽象观察者，每一个实现该接口的实现类都是具体观察者。<br>package com.lijie;</p>
<p>&#x2F;&#x2F;观察者的接口，用来存放观察者共有方法<br>public interface Observer {<br>    &#x2F;&#x2F; 观察者方法<br>    void update(int state);<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>定义具体观察者<br>package com.lijie;</p>
<p>&#x2F;&#x2F; 具体观察者<br>public class ObserverImpl implements Observer {</p>
<pre><code class="hljs">// 具体观察者的属性
private int myState;

public void update(int state) &#123;
    myState=state;
    System.out.println(&quot;收到消息,myState值改为：&quot;+state);
&#125;

public int getMyState() &#123;
    return myState;
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>定义主题。主题定义观察者数组，并实现增、删及通知操作。<br>package com.lijie;</p>
<p>import java.util.Vector;</p>
<p>&#x2F;&#x2F;定义主题，以及定义观察者数组，并实现增、删及通知操作。<br>public class Subjecct {<br>    &#x2F;&#x2F;观察者的存储集合，不推荐ArrayList，线程不安全，<br>    private Vector<Observer> list &#x3D; new Vector&lt;&gt;();</p>
<pre><code class="hljs">// 注册观察者方法
public void registerObserver(Observer obs) &#123;
    list.add(obs);
&#125;
// 删除观察者方法
public void removeObserver(Observer obs) &#123;
    list.remove(obs);
&#125;

// 通知所有的观察者更新
public void notifyAllObserver(int state) &#123;
    for (Observer observer : list) &#123;
        observer.update(state);
    &#125;
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>定义具体的，他继承继承Subject类，在这里实现具体业务，在具体项目中，该类会有很多。<br>package com.lijie;</p>
<p>&#x2F;&#x2F;具体主题<br>public class RealObserver extends Subjecct {<br>    &#x2F;&#x2F;被观察对象的属性<br>     private int state;<br>     public int getState(){<br>         return state;<br>     }<br>     public void  setState(int state){<br>         this.state&#x3D;state;<br>         &#x2F;&#x2F;主题对象(目标对象)值发生改变<br>         this.notifyAllObserver(state);<br>     }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>运行测试<br>package com.lijie;</p>
<p>public class Client {</p>
<pre><code class="hljs">public static void main(String[] args) &#123;
    // 目标对象
    RealObserver subject = new RealObserver();
    // 创建多个观察者
    ObserverImpl obs1 = new ObserverImpl();
    ObserverImpl obs2 = new ObserverImpl();
    ObserverImpl obs3 = new ObserverImpl();
    // 注册到观察队列中
    subject.registerObserver(obs1);
    subject.registerObserver(obs2);
    subject.registerObserver(obs3);
    // 改变State状态
    subject.setState(300);
    System.out.println(&quot;obs1观察者的MyState状态值为：&quot;+obs1.getMyState());
    System.out.println(&quot;obs2观察者的MyState状态值为：&quot;+obs2.getMyState());
    System.out.println(&quot;obs3观察者的MyState状态值为：&quot;+obs3.getMyState());
    // 改变State状态
    subject.setState(400);
    System.out.println(&quot;obs1观察者的MyState状态值为：&quot;+obs1.getMyState());
    System.out.println(&quot;obs2观察者的MyState状态值为：&quot;+obs2.getMyState());
    System.out.println(&quot;obs3观察者的MyState状态值为：&quot;+obs3.getMyState());
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>文章就到这了，没错，没了<br>察者方法<br>public void removeObserver(Observer obs) {<br>list.remove(obs);<br>}</p>
<p>&#x2F;&#x2F; 通知所有的观察者更新<br>public void notifyAllObserver(int state) {<br>    for (Observer observer : list) {<br>        observer.update(state);<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>}</p>
<ol start="4">
<li>定义具体的，他继承继承Subject类，在这里实现具体业务，在具体项目中，该类会有很多。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-comment">//具体主题</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealObserver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subjecct</span> &#123;<br>    <span class="hljs-comment">//被观察对象的属性</span><br>	 <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> state;<br>	 <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getState</span><span class="hljs-params">()</span>&#123;<br>		 <span class="hljs-keyword">return</span> state;<br>	 &#125;<br>	 <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span>&#123;<br>		 <span class="hljs-built_in">this</span>.state=state;<br>		 <span class="hljs-comment">//主题对象(目标对象)值发生改变</span><br>		 <span class="hljs-built_in">this</span>.notifyAllObserver(state);<br>	 &#125;<br>&#125;<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">6</span><br><span class="hljs-number">7</span><br><span class="hljs-number">8</span><br><span class="hljs-number">9</span><br><span class="hljs-number">10</span><br><span class="hljs-number">11</span><br><span class="hljs-number">12</span><br><span class="hljs-number">13</span><br><span class="hljs-number">14</span><br><span class="hljs-number">15</span><br><span class="hljs-number">16</span><br><span class="hljs-number">17</span><br>运行测试<br><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-comment">// 目标对象</span><br>		<span class="hljs-type">RealObserver</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealObserver</span>();<br>		<span class="hljs-comment">// 创建多个观察者</span><br>		<span class="hljs-type">ObserverImpl</span> <span class="hljs-variable">obs1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObserverImpl</span>();<br>		<span class="hljs-type">ObserverImpl</span> <span class="hljs-variable">obs2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObserverImpl</span>();<br>		<span class="hljs-type">ObserverImpl</span> <span class="hljs-variable">obs3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObserverImpl</span>();<br>		<span class="hljs-comment">// 注册到观察队列中</span><br>		subject.registerObserver(obs1);<br>		subject.registerObserver(obs2);<br>		subject.registerObserver(obs3);<br>		<span class="hljs-comment">// 改变State状态</span><br>		subject.setState(<span class="hljs-number">300</span>);<br>		System.out.println(<span class="hljs-string">&quot;obs1观察者的MyState状态值为：&quot;</span>+obs1.getMyState());<br>		System.out.println(<span class="hljs-string">&quot;obs2观察者的MyState状态值为：&quot;</span>+obs2.getMyState());<br>		System.out.println(<span class="hljs-string">&quot;obs3观察者的MyState状态值为：&quot;</span>+obs3.getMyState());<br>		<span class="hljs-comment">// 改变State状态</span><br>		subject.setState(<span class="hljs-number">400</span>);<br>		System.out.println(<span class="hljs-string">&quot;obs1观察者的MyState状态值为：&quot;</span>+obs1.getMyState());<br>		System.out.println(<span class="hljs-string">&quot;obs2观察者的MyState状态值为：&quot;</span>+obs2.getMyState());<br>		System.out.println(<span class="hljs-string">&quot;obs3观察者的MyState状态值为：&quot;</span>+obs3.getMyState());<br>	&#125;<br>&#125;<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">6</span><br><span class="hljs-number">7</span><br><span class="hljs-number">8</span><br><span class="hljs-number">9</span><br><span class="hljs-number">10</span><br><span class="hljs-number">11</span><br><span class="hljs-number">12</span><br><span class="hljs-number">13</span><br><span class="hljs-number">14</span><br><span class="hljs-number">15</span><br><span class="hljs-number">16</span><br><span class="hljs-number">17</span><br><span class="hljs-number">18</span><br><span class="hljs-number">19</span><br><span class="hljs-number">20</span><br><span class="hljs-number">21</span><br><span class="hljs-number">22</span><br><span class="hljs-number">23</span><br><span class="hljs-number">24</span><br><span class="hljs-number">25</span><br><span class="hljs-number">26</span><br><span class="hljs-number">27</span><br>文章就到这了，没错，没了<br>如果不是必要，准备上面那九个设计模式就好了，全部记住有点难<br>————————————————<br>版权声明：本文为CSDN博主「小杰要吃蛋」的原创文章，遵循CC <span class="hljs-number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：https:<span class="hljs-comment">//blog.csdn.net/weixin_43122090/article/details/105462226</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="为什么用自增列作为主键"><a href="#为什么用自增列作为主键" class="headerlink" title="为什么用自增列作为主键"></a>为什么用自增列作为主键</h3><ol>
<li>如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。</li>
<li>数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15&#x2F;16），则开辟一个新的页（节点）</li>
<li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</li>
<li>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</li>
</ol>
<h3 id="为什么使用数据索引能提高效率"><a href="#为什么使用数据索引能提高效率" class="headerlink" title="为什么使用数据索引能提高效率"></a>为什么使用数据索引能提高效率</h3><ol>
<li>数据索引的存储是有序的</li>
<li>在有序的情况下，通过索引查询一个数据是无需遍历索引记录的</li>
<li>极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)</li>
</ol>
<h3 id="B-树索引和哈希索引的区别"><a href="#B-树索引和哈希索引的区别" class="headerlink" title="B+树索引和哈希索引的区别"></a>B+树索引和哈希索引的区别</h3><p>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的</p>
<p><img src="/images%5CBplusTree.jpg" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的</p>
<p><img src="/images%5CHashTree.jpg" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p>哈希索引的优势：</p>
<p>**<br>**</p>
<ol>
<li>等值查询。哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）</li>
</ol>
<p>**<br>**</p>
<p>哈希索引不适用的场景：</p>
<p>**<br>**</p>
<ol>
<li>不支持范围查询</li>
<li>不支持索引完成排序</li>
<li>不支持联合索引的最左前缀匹配规则</li>
</ol>
<p>通常，B+树索引结构适用于绝大多数场景，像下面这种场景用哈希索引才更有优势：</p>
<p>在HEAP表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主，没有范围查询、没有排序的时候，特别适合采用哈希索引，例如这种SQL：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> id,<span class="hljs-type">name</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span>=<span class="hljs-string">&#x27;李明&#x27;</span>; — 仅等值查询<br></code></pre></td></tr></table></figure>



<p>而常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引），通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。</p>
<p>注意：在某些工作负载下，通过哈希索引查找带来的性能提升远大于额外的监控索引搜索情况和保持这个哈希表结构所带来的开销。但某些时候，在负载高的情况下，自适应哈希索引中添加的read&#x2F;write锁也会带来竞争，比如高并发的join操作。like操作和%的通配符操作也不适用于自适应哈希索引，可能要关闭自适应哈希索引。</p>
<h2 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a><strong>B树和B+树的区别</strong></h2><ol>
<li><p>B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/QCu849YTaIOqRD2H1iceraQdQroRXcW1YPNQD2iaD2ia5JniapuyYCvyAmfLwv9mjSDqM5yr0D8jo7MKnPxuH5yMsg/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="/img/loading.gif" lazyload alt="图片"></p>
</li>
<li><p>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)</p>
</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz/QCu849YTaIOqRD2H1iceraQdQroRXcW1YAfMEG02fjvBN4BYXlicxVrSwfjxMb49yrtVlQf2ZXiaHcxkXjibo2Vd2w/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="/img/loading.gif" lazyload alt="图片"></p>
<h2 id="为什么说-B-比-B-树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#为什么说-B-比-B-树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="为什么说 B+ 比 B 树更适合实际应用中操作系统的文件索引和数据库索引？"></a><strong>为什么说 B+ 比 B 树更适合实际应用中操作系统的文件索引和数据库索引？</strong></h2><ol>
<li>B+的磁盘读写代价更低 B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</li>
<li>B+-tree的查询效率更加稳定 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
</ol>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="MySQL联合索引"><a href="#MySQL联合索引" class="headerlink" title="MySQL联合索引"></a><strong>MySQL联合索引</strong></h2><ol>
<li>联合索引是两个或更多个列上的索引。对于联合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持a  、   a,b  、  a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。</li>
<li>利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知 道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。</li>
</ol>
<h2 id="什么情况下应不建或少建索引"><a href="#什么情况下应不建或少建索引" class="headerlink" title="什么情况下应不建或少建索引"></a><strong>什么情况下应不建或少建索引</strong></h2><ol>
<li>表记录太少</li>
<li>经常插入、删除、修改的表</li>
<li>数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</li>
<li>经常和主字段一块查询但主字段索引值比较多的表字段</li>
</ol>
<h2 id="MySQL分区"><a href="#MySQL分区" class="headerlink" title="MySQL分区"></a><strong>MySQL分区</strong></h2><h3 id="一-什么是表分区？"><a href="#一-什么是表分区？" class="headerlink" title="一. 什么是表分区？"></a>一. 什么是表分区？</h3><p>表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。</p>
<h3 id="二-表分区与分表的区别"><a href="#二-表分区与分表的区别" class="headerlink" title="二. 表分区与分表的区别"></a>二. 表分区与分表的区别</h3><p>分表：指的是通过一定规则，将一张表分解成多张不同的表。比如将用户订单记录根据时间成多个表。</p>
<p>分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。</p>
<h3 id="三-表分区有什么好处？"><a href="#三-表分区有什么好处？" class="headerlink" title="三. 表分区有什么好处？"></a>三. 表分区有什么好处？</h3><ol>
<li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。 2. 和单个磁盘或者文件系统相比，可以存储更多数据</li>
<li>优化查询。在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率；涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。</li>
<li>分区表更容易维护。例如：想批量删除大量数据可以清除整个分区。</li>
<li>可以使用分区表来避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问，ext3问价你系统的inode锁竞争等。</li>
</ol>
<h3 id="四-分区表的限制因素"><a href="#四-分区表的限制因素" class="headerlink" title="四. 分区表的限制因素"></a>四. 分区表的限制因素</h3><ol>
<li>一个表最多只能有1024个分区</li>
<li>MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式。在MySQL5.5中提供了非整数表达式分区的支持。</li>
<li>如果分区字段中有主键或者唯一索引的列，那么多有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。</li>
<li>分区表中无法使用外键约束</li>
<li>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。</li>
</ol>
<h3 id="五-如何判断当前MySQL是否支持分区？"><a href="#五-如何判断当前MySQL是否支持分区？" class="headerlink" title="五. 如何判断当前MySQL是否支持分区？"></a>五. 如何判断当前MySQL是否支持分区？</h3><p>命令：show variables like ‘%partition%’ 运行结果:</p>
<p>mysql&gt; show variables like ‘%partition%’; +——————-+——-+ | Variable_name   | Value | +——————-+——-+ | have_partitioning | YES  | +——————-+——-+ 1 row in set (0.00 sec) have_partintioning 的值为YES，表示支持分区。</p>
<h3 id="六-MySQL支持的分区类型有哪些？"><a href="#六-MySQL支持的分区类型有哪些？" class="headerlink" title="六. MySQL支持的分区类型有哪些？"></a>六. MySQL支持的分区类型有哪些？</h3><ol>
<li>RANGE分区： 这种模式允许将数据划分不同范围。例如可以将一个表通过年份划分成若干个分区</li>
<li>LIST分区： 这种模式允许系统通过预定义的列表的值来对数据进行分割。按照List中的值分区，与RANGE的区别是，range分区的区间范围值是连续的。</li>
<li>HASH分区 ：这中模式允许通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表。</li>
<li>KEY分区 ：上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的。</li>
</ol>
<h2 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a><strong>四种隔离级别</strong></h2><ol>
<li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</li>
<li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li>
<li>Read committed (读已提交)：可避免脏读的发生。</li>
<li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li>
</ol>
<h2 id="关于MVVC"><a href="#关于MVVC" class="headerlink" title="关于MVVC"></a><strong>关于MVVC</strong></h2><p>MySQL InnoDB 存储引擎，实现的是基于多版本的并发控制协议—— MVCC (Multi-Version Concurrency Control)  (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。MVCC最大的好处：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，现阶段几乎所有的RDBMS，都支持了 MVCC。</p>
<ol>
<li>LBCC：Lock-Based Concurrency Control，基于锁的并发控制。</li>
<li>MVCC：Multi-Version Concurrency Control，基于多版本的并发控制协议。纯粹基于锁的并发机制并发量低，MVCC是在基于锁的并发控制上的改进，主要是在读操作上提高了并发量。</li>
</ol>
<p>在MVCC并发控制中，读操作可以分成两类：</p>
<ol>
<li>快照读 (snapshot read)：读取的是记录的可见版本 (有可能是历史版本)，不用加锁（共享读锁s锁也不加，所以不会阻塞其他事务的写）。</li>
<li>当前读 (current read)：读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</li>
</ol>
<h2 id="行级锁定的优点："><a href="#行级锁定的优点：" class="headerlink" title="行级锁定的优点："></a><strong>行级锁定的优点：</strong></h2><ol>
<li>当在许多线程中访问不同的行时只存在少量锁定冲突。</li>
<li>回滚时只有少量的更改</li>
<li>可以长时间锁定单一的行。</li>
</ol>
<h2 id="行级锁定的缺点："><a href="#行级锁定的缺点：" class="headerlink" title="行级锁定的缺点："></a><strong>行级锁定的缺点：</strong></h2><ol>
<li>比页级或表级锁定占用更多的内存。</li>
<li>当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。</li>
<li>如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。</li>
<li>用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。</li>
</ol>
<h2 id="MySQL触发器简单实例"><a href="#MySQL触发器简单实例" class="headerlink" title="MySQL触发器简单实例"></a><strong>MySQL触发器简单实例</strong></h2><ol>
<li>CREATE TRIGGER &lt;触发器名称&gt;  –触发器必须有名字，最多64个字符，可能后面会附有分隔符.它和MySQL中其他对象的命名方式基本相象.</li>
<li>{ BEFORE | AFTER }  –触发器有执行的时间设置：可以设置为事件发生前或后。</li>
<li>{ INSERT | UPDATE | DELETE }  –同样也能设定触发的事件：它们可以在执行insert、update或delete的过程中触发。</li>
<li>ON &lt;表名称&gt;  –触发器是属于某一个表的:当在这个表上执行插入、 更新或删除操作的时候就导致触发器的激活. 我们不能给同一张表的同一个事件安排两个触发器。</li>
<li>FOR EACH ROW  –触发器的执行间隔：FOR EACH ROW子句通知触发器 每隔一行执行一次动作，而不是对整个表执行一次。</li>
<li>&lt;触发器SQL语句&gt;  –触发器包含所要触发的SQL语句：这里的语句可以是任何合法的语句， 包括复合语句，但是这里的语句受的限制和函数的一样。</li>
</ol>
<h2 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程"></a><strong>什么是存储过程</strong></h2><p>简单的说，就是一组SQL语句集，功能强大，可以实现一些比较复杂的逻辑功能，类似于JAVA语言中的方法；</p>
<p>ps:存储过程跟触发器有点类似，都是一组SQL集，但是存储过程是主动调用的，且功能比触发器更加强大，触发器是某件事触发后自动调用；</p>
<p>有哪些特性</p>
<ol>
<li>有输入输出参数，可以声明变量，有if&#x2F;else, case,while等控制语句，通过编写存储过程，可以实现复杂的逻辑功能；</li>
<li>函数的普遍特性：模块化，封装，代码复用；</li>
<li>速度快，只有首次执行需经过编译和优化步骤，后续被调用可以直接执行，省去以上步骤；</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> IF <span class="hljs-keyword">EXISTS</span> `proc_adder`;<br>DELIMITER ;;<br><span class="hljs-keyword">CREATE</span> DEFINER<span class="hljs-operator">=</span>`root`@`localhost` <span class="hljs-keyword">PROCEDURE</span> `proc_adder`(<span class="hljs-keyword">IN</span> a <span class="hljs-type">int</span>, <span class="hljs-keyword">IN</span> b <span class="hljs-type">int</span>, <span class="hljs-keyword">OUT</span> sum <span class="hljs-type">int</span>)<br><span class="hljs-keyword">BEGIN</span><br>   #Routine body goes here...<br><br>   <span class="hljs-keyword">DECLARE</span> c <span class="hljs-type">int</span>;<br>   if a <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">set</span> a <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">end</span> if;<br> <br>   if b <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">set</span> b <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">end</span> if;<br><br>   <span class="hljs-keyword">set</span> sum  <span class="hljs-operator">=</span> a <span class="hljs-operator">+</span> b;<br><span class="hljs-keyword">END</span><br>;;<br>DELIMITER ;<br><br><span class="hljs-keyword">set</span> <span class="hljs-variable">@b</span><span class="hljs-operator">=</span><span class="hljs-number">5</span>;<br><span class="hljs-keyword">call</span> proc_adder(<span class="hljs-number">0</span>,<span class="hljs-variable">@b</span>,<span class="hljs-variable">@s</span>);<br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@s</span> <span class="hljs-keyword">as</span> sum;<br><br><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tab2(<br>  tab2_id <span class="hljs-type">varchar</span>(<span class="hljs-number">11</span>)<br>);<br><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> if <span class="hljs-keyword">EXISTS</span> t_ai_on_tab1;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">TRAILING</span> t_ai_on_tab1<br>AFTER <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> tab1<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span><br><span class="hljs-keyword">BEGIN</span><br>  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tab2(tab2_id) <span class="hljs-keyword">values</span>(new.tab1_id);<br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tab1(tab1_id) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;0001&#x27;</span>);<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tab2;<br></code></pre></td></tr></table></figure>



<h2 id="MySQL优化"><a href="#MySQL优化" class="headerlink" title="MySQL优化"></a><strong>MySQL优化</strong></h2><ol>
<li>开启查询缓存，优化查询</li>
<li>explain你的select查询，这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的</li>
<li>当只要一行数据时使用limit 1，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据</li>
<li>为搜索字段建索引</li>
<li>使用 ENUM 而不是 VARCHAR，如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是VARCHAR。</li>
<li>Prepared Statements Prepared Statements很像存储过程，是一种运行在后台的SQL语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击</li>
<li>垂直分表</li>
<li>选择正确的存储引擎</li>
</ol>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="key和index的区别"><a href="#key和index的区别" class="headerlink" title="key和index的区别"></a><strong>key和index的区别</strong></h2><ol>
<li>key 是数据库的物理结构，它包含两层意义和作用，一是约束（偏重于约束和规范数据库的结构完整性），二是索引（辅助查询用的）。包括primary key, unique key, foreign key 等</li>
<li>index是数据库的物理结构，它只是辅助查询的，它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储。索引要分类的话，分为前缀索引、全文本索引等；</li>
</ol>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="Mysql-中-MyISAM-和-InnoDB-的区别有哪些？"><a href="#Mysql-中-MyISAM-和-InnoDB-的区别有哪些？" class="headerlink" title="Mysql 中 MyISAM 和 InnoDB 的区别有哪些？"></a><strong>Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</strong></h2><p>区别：</p>
<ol>
<li>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li>
<li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li>
<li>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>
<li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</li>
</ol>
<p>如何选择：</p>
<ol>
<li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li>
<li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB。</li>
<li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li>
<li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</li>
</ol>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><h2 id="数据库表创建注意事项"><a href="#数据库表创建注意事项" class="headerlink" title="数据库表创建注意事项"></a><strong>数据库表创建注意事项</strong></h2><h3 id="一、字段名及字段配制合理性"><a href="#一、字段名及字段配制合理性" class="headerlink" title="一、字段名及字段配制合理性"></a>一、字段名及字段配制合理性</h3><ol>
<li>剔除关系不密切的字段</li>
<li>字段命名要有规则及相对应的含义（不要一部分英文，一部分拼音，还有类似a.b.c这样不明含义的字段）</li>
<li>字段命名尽量不要使用缩写（大多数缩写都不能明确字段含义）</li>
<li>字段不要大小写混用（想要具有可读性，多个英文单词可使用下划线形式连接）</li>
<li>字段名不要使用保留字或者关键字</li>
<li>保持字段名和类型的一致性</li>
<li>慎重选择数字类型</li>
<li>给文本字段留足余量</li>
</ol>
<h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="二、系统特殊字段处理及建成后建议"><a href="#二、系统特殊字段处理及建成后建议" class="headerlink" title="二、系统特殊字段处理及建成后建议"></a>二、系统特殊字段处理及建成后建议</h3><ol>
<li>添加删除标记（例如操作人、删除时间）</li>
<li>建立版本机制</li>
</ol>
<h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><h3 id="三、表结构合理性配置"><a href="#三、表结构合理性配置" class="headerlink" title="三、表结构合理性配置"></a>三、表结构合理性配置</h3><ol>
<li>多型字段的处理，就是表中是否存在字段能够分解成更小独立的几部分（例如：人可以分为男人和女人）</li>
<li>多值字段的处理，可以将表分为三张表，这样使得检索和排序更加有调理，且保证数据的完整性！</li>
</ol>
<h3 id="-6"><a href="#-6" class="headerlink" title=""></a></h3><h3 id="四、其它建议"><a href="#四、其它建议" class="headerlink" title="四、其它建议"></a>四、其它建议</h3><ol>
<li>对于大数据字段，独立表进行存储，以便影响性能（例如：简介字段）</li>
<li>使用varchar类型代替char，因为varchar会动态分配长度，char指定长度是固定的。</li>
<li>给表创建主键，对于没有主键的表，在查询和索引定义上有一定的影响。</li>
<li>避免表字段运行为null，建议设置默认值（例如：int类型设置默认值为0）在索引查询上，效率立显！</li>
<li>建立索引，最好建立在唯一和非空的字段上，建立太多的索引对后期插入、更新都存在一定的影响（考虑实际情况来创建）。</li>
</ol>
<h2 id="-7"><a href="#-7" class="headerlink" title=""></a></h2><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h2><h2 id="Redis单线程问题"><a href="#Redis单线程问题" class="headerlink" title="Redis单线程问题"></a><strong>Redis单线程问题</strong></h2><p>单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。</p>
<h2 id="为什么说Redis能够快速执行"><a href="#为什么说Redis能够快速执行" class="headerlink" title="为什么说Redis能够快速执行"></a><strong>为什么说Redis能够快速执行</strong></h2><ol>
<li>绝大部分请求是纯粹的内存操作（非常快速）</li>
<li>采用单线程,避免了不必要的上下文切换和竞争条件</li>
<li>非阻塞IO - IO多路复用</li>
</ol>
<h2 id="Redis的内部实现"><a href="#Redis的内部实现" class="headerlink" title="Redis的内部实现"></a><strong>Redis的内部实现</strong></h2><p>内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，不在io上浪费一点时间 这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能很差。redis为特殊的场景选择了合适的技术方案。</p>
<h2 id="-8"><a href="#-8" class="headerlink" title=""></a></h2><h2 id="Redis关于线程安全问题"><a href="#Redis关于线程安全问题" class="headerlink" title="Redis关于线程安全问题"></a><strong>Redis关于线程安全问题</strong></h2><p>redis实际上是采用了线程封闭的观念，把任务封闭在一个线程，自然避免了线程安全问题，不过对于需要依赖多个redis操作的复合操作来说，依然需要锁，而且有可能是分布式锁。</p>
<h2 id="使用Redis有哪些好处？"><a href="#使用Redis有哪些好处？" class="headerlink" title="使用Redis有哪些好处？"></a><strong>使用Redis有哪些好处？</strong></h2><ol>
<li>速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</li>
<li>支持丰富数据类型，支持string，list，set，sorted set，hash</li>
<li>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li>
<li>丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</li>
</ol>
<h2 id="redis相比memcached有哪些优势？"><a href="#redis相比memcached有哪些优势？" class="headerlink" title="redis相比memcached有哪些优势？"></a><strong>redis相比memcached有哪些优势？</strong></h2><ol>
<li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</li>
<li>redis的速度比memcached快很多</li>
<li>redis可以持久化其数据</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
<li>使用底层模型不同，它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li>
<li>value大小：redis最大可以达到1GB，而memcache只有1MB</li>
</ol>
<h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a><strong>Redis主从复制</strong></h2><p>过程原理：</p>
<ol>
<li>当从库和主库建立MS关系后,会向主数据库发送SYNC命令</li>
<li>主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程),并将期间接收到的写命令缓存起来</li>
<li>当快照完成后,主Redis会将快照文件和所有缓存的写命令发送给从Redis</li>
<li>从Redis接收到后,会载入快照文件并且执行收到的缓存的命令</li>
<li>之后,主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致</li>
</ol>
<p>缺点：所有的slave节点数据的复制和同步都由master节点来处理,会照成master节点压力太大,使用主从从结构来解决</p>
<h2 id="Redis两种持久化方式的优缺点"><a href="#Redis两种持久化方式的优缺点" class="headerlink" title="Redis两种持久化方式的优缺点"></a><strong>Redis两种持久化方式的优缺点</strong></h2><ol>
<li>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）</li>
<li>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。</li>
<li>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。当redis重启时,它会有限使用AOF文件来还原数据集,因为AOF文件保存的数据集通常比RDB文件所保存的数据集更加完整</li>
</ol>
<p>**<br>**</p>
<p><strong>RDB的优点：</strong></p>
<p>**<br>**</p>
<ol>
<li>RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。</li>
<li>RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。</li>
<li>RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I&#x2F;O 操作。</li>
<li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快</li>
</ol>
<h2 id="-9"><a href="#-9" class="headerlink" title=""></a></h2><h2 id="Redis常见的性能问题都有哪些？如何解决？"><a href="#Redis常见的性能问题都有哪些？如何解决？" class="headerlink" title="Redis常见的性能问题都有哪些？如何解决？"></a><strong>Redis常见的性能问题都有哪些？如何解决？</strong></h2><ol>
<li>Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。</li>
<li>Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</li>
<li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</li>
<li>Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内</li>
</ol>
<h2 id="-10"><a href="#-10" class="headerlink" title=""></a></h2><h2 id="Redis提供6种数据淘汰策略"><a href="#Redis提供6种数据淘汰策略" class="headerlink" title="Redis提供6种数据淘汰策略"></a><strong>Redis提供6种数据淘汰策略</strong></h2><ol>
<li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li>no-enviction（驱逐）：禁止驱逐数据</li>
</ol>
<h1 id="史上最全的数据库面试题，不看绝对后悔"><a href="#史上最全的数据库面试题，不看绝对后悔" class="headerlink" title="史上最全的数据库面试题，不看绝对后悔"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wenxiaofei/p/9853682.html">史上最全的数据库面试题，不看绝对后悔</a></h1><h1 id="数据库面试知识点汇总"><a href="#数据库面试知识点汇总" class="headerlink" title="数据库面试知识点汇总"></a>数据库面试知识点汇总</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h4 id="1-主键、外键、超键、候选键"><a href="#1-主键、外键、超键、候选键" class="headerlink" title="1.主键、外键、超键、候选键"></a><strong>1.主键、外键、超键、候选键</strong></h4><blockquote>
<p><strong>超键</strong>：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p>
<p><strong>候选键</strong>：是最小超键，即没有冗余元素的超键。</p>
<p><strong>主键</strong>：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</p>
<p><strong>外键</strong>：在一个表中存在的另一个表的主键称此表的外键。</p>
</blockquote>
<h4 id="2-为什么用自增列作为主键"><a href="#2-为什么用自增列作为主键" class="headerlink" title="2.为什么用自增列作为主键"></a><strong>2.为什么用自增列作为主键</strong></h4><blockquote>
<p>如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、</p>
<p>如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、</p>
<p>如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。</p>
<p>数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15&#x2F;16），则开辟一个新的页（节点）</p>
<p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</p>
<p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p>
</blockquote>
<h4 id="3-触发器的作用？"><a href="#3-触发器的作用？" class="headerlink" title="3.触发器的作用？"></a><strong>3.触发器的作用？</strong></h4><blockquote>
<p>触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p>
</blockquote>
<h4 id="4-什么是存储过程？用什么来调用？"><a href="#4-什么是存储过程？用什么来调用？" class="headerlink" title="4.什么是存储过程？用什么来调用？"></a><strong>4.什么是存储过程？用什么来调用？</strong></h4><blockquote>
<p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p>
<p><strong>调用：</strong></p>
<p>1）可以用一个命令对象来调用存储过程。</p>
<p>2）可以供外部程序调用，比如：java程序。</p>
</blockquote>
<h4 id="5-存储过程的优缺点？"><a href="#5-存储过程的优缺点？" class="headerlink" title="5.存储过程的优缺点？"></a><strong>5.存储过程的优缺点？</strong></h4><blockquote>
<p><strong>优点：</strong></p>
<p>1）存储过程是预编译过的，执行效率高。</p>
<p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p>
<p>3）安全性高，执行存储过程需要有一定权限的用户。</p>
<p>4）存储过程可以重复使用，可减少数据库开发人员的工作量。</p>
<p><strong>缺点：</strong>移植性差</p>
</blockquote>
<h4 id="6-存储过程与函数的区别"><a href="#6-存储过程与函数的区别" class="headerlink" title="6.存储过程与函数的区别"></a><strong>6.存储过程与函数的区别</strong></h4><p><img src="https://i.imgur.com/ymE9HPJ.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="7-什么叫视图？游标是什么？"><a href="#7-什么叫视图？游标是什么？" class="headerlink" title="7.什么叫视图？游标是什么？"></a><strong>7.什么叫视图？游标是什么？</strong></h4><blockquote>
<p><strong>视图：</strong></p>
<p>是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。</p>
<p><strong>游标：</strong></p>
<p>是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p>
</blockquote>
<h4 id="8-视图的优缺点"><a href="#8-视图的优缺点" class="headerlink" title="8.视图的优缺点"></a><strong>8.视图的优缺点</strong></h4><blockquote>
<p><strong>优点：</strong></p>
<p>1对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。</p>
<p>2)用户通过简单的查询可以从复杂查询中得到结果。</p>
<p>3)维护数据的独立性，试图可从多个表检索数据。</p>
<p>4)对于相同的数据可产生不同的视图。</p>
<p><strong>缺点：</strong></p>
<p>性能：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，那么就无法更改数据</p>
</blockquote>
<h4 id="9-drop、truncate、-delete区别"><a href="#9-drop、truncate、-delete区别" class="headerlink" title="9.drop、truncate、 delete区别"></a><strong>9.drop、truncate、 delete区别</strong></h4><blockquote>
<p><strong>最基本：</strong></p>
<ul>
<li>drop直接删掉表。</li>
<li>truncate删除表中数据，再插入时自增长id又从1开始。</li>
<li>delete删除表中数据，可以加where字句。</li>
</ul>
<p>（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p>
<p>（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。</p>
<p>（3） 一般而言，drop &gt; truncate &gt; delete</p>
<p>（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view</p>
<p>（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。</p>
<p>（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程&#x2F;函数将被保留，但其状态会变为：invalid。</p>
<p>（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。</p>
<p>（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚。</p>
<p>（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。</p>
<p>（10） Truncate table 表名 速度快,而且效率高,因为:?truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</p>
<p>（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。</p>
<p>（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p>
</blockquote>
<h4 id="10-什么是临时表，临时表什么时候删除"><a href="#10-什么是临时表，临时表什么时候删除" class="headerlink" title="10.什么是临时表，临时表什么时候删除?"></a><strong>10.什么是临时表，临时表什么时候删除?</strong></h4><blockquote>
<p><strong>临时表可以手动删除：</strong><br>DROP TEMPORARY TABLE IF EXISTS temp_tb;</p>
<p><strong>临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。<br>创建临时表的语法与创建表语法类似，不同之处是增加关键字TEMPORARY，</strong></p>
<p>如：</p>
<p>CREATE TEMPORARY TABLE tmp_table (</p>
<p>NAME VARCHAR (10) NOT NULL,</p>
<p>time date NOT NULL<br>);</p>
<p>select * from tmp_table;</p>
</blockquote>
<h4 id="11-非关系型数据库和关系型数据库区别，优势比较"><a href="#11-非关系型数据库和关系型数据库区别，优势比较" class="headerlink" title="11.非关系型数据库和关系型数据库区别，优势比较?"></a><strong>11.非关系型数据库和关系型数据库区别，优势比较?</strong></h4><blockquote>
<p><strong>非关系型数据库的优势：</strong></p>
<ul>
<li><strong>性能：</strong>NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li>
<li><strong>可扩展性：</strong>同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li>
</ul>
<p><strong>关系型数据库的优势：</strong></p>
<ul>
<li><strong>复杂查询：</strong>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li>
<li><strong>事务支持：</strong>使得对于安全性能很高的数据访问要求得以实现。</li>
</ul>
<p><strong>其他：</strong></p>
<p>**1.**对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</p>
<p>**2.**NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，比如MongoDB。</p>
<p>**3.**对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如Redis set nx。</p>
</blockquote>
<h4 id="12-数据库范式，根据某个场景设计数据表"><a href="#12-数据库范式，根据某个场景设计数据表" class="headerlink" title="12.数据库范式，根据某个场景设计数据表?"></a><strong>12.数据库范式，根据某个场景设计数据表?</strong></h4><blockquote>
<p><strong>第一范式:</strong>(确保每列保持原子性)所有字段值都是不可分解的原子值。</p>
<p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。<br>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。<br>上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。</p>
<p><strong>第二范式:</strong>(确保表中的每列都和主键相关)在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p>
<p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。<br>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键。</p>
<p><strong>第三范式:</strong>(确保每列都和主键列直接相关,而不是间接相关) 数据表中的每一列数据都和主键直接相关，而不能间接相关。</p>
<p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。<br>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。</p>
<p>**BCNF:**符合3NF，并且，主属性不依赖于主属性。</p>
<p>若关系模式属于第二范式，且每个属性都不传递依赖于键码，则R属于BC范式。<br>通常BC范式的条件有多种等价的表述：每个非平凡依赖的左边必须包含键码；每个决定因素必须包含键码。<br>BC范式既检查非主属性，又检查主属性。当只检查非主属性时，就成了第三范式。满足BC范式的关系都必然满足第三范式。<br>还可以这么说：若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到BC范式。<br>一般，一个数据库设计符合3NF或BCNF就可以了。</p>
<p>**第四范式:**要求把同一表内的多对多关系删除。</p>
<p>**第五范式:**从最终结构重新建立原始结构。</p>
</blockquote>
<h4 id="13-什么是-内连接、外连接、交叉连接、笛卡尔积等"><a href="#13-什么是-内连接、外连接、交叉连接、笛卡尔积等" class="headerlink" title="13.什么是 内连接、外连接、交叉连接、笛卡尔积等?"></a><strong>13.什么是 内连接、外连接、交叉连接、笛卡尔积等?</strong></h4><blockquote>
<p><strong>内连接:</strong> 只连接匹配的行</p>
<p><strong>左外连接:</strong> 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行</p>
<p><strong>右外连接:</strong> 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行</p>
<p>例如1：<br>SELECT a.<em>,b.</em> FROM luntan LEFT JOIN usertable as b ON a.username&#x3D;b.username</p>
<p>例如2：<br>SELECT a.<em>,b.</em> FROM city as a FULL OUTER JOIN user as b ON a.username&#x3D;b.username</p>
<p><strong>全外连接:</strong> 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。</p>
<p><strong>交叉连接:</strong> 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配</p>
<p>例如：<br>SELECT type,pub_name FROM titles CROSS JOIN publishers ORDER BY type</p>
<p><strong>注意：</strong></p>
<p>很多公司都只是考察是否知道其概念，但是也有很多公司需要不仅仅知道概念，还需要动手写sql,一般都是简单的连接查询，具体关于连接查询的sql练习，参见以下链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/ta/sql">牛客网数据库SQL实战</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problemset/database/">leetcode中文网站数据库练习</a></p>
<p><a target="_blank" rel="noopener" href="http://www.baidu.com/">我的另一篇文章，常用sql练习50题</a></p>
</blockquote>
<h4 id="14-varchar和char的使用场景"><a href="#14-varchar和char的使用场景" class="headerlink" title="14.varchar和char的使用场景?"></a><strong>14.varchar和char的使用场景?</strong></h4><blockquote>
<p>**1.**char的长度是不可变的，而varchar的长度是可变的。</p>
</blockquote>
<blockquote>
<p>定义一个char[10]和varchar[10]。<br>如果存进去的是‘csdn’,那么char所占的长度依然为10，除了字符‘csdn’外，后面跟六个空格，varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。</p>
<p>**2.**char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找。<br>char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。<br>varchar是以空间效率为首位。</p>
<p>**3.**char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。<br>varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。</p>
<p>**4.**两者的存储数据都非unicode的字符数据。</p>
</blockquote>
<h4 id="15-SQL语言分类"><a href="#15-SQL语言分类" class="headerlink" title="15.SQL语言分类"></a><strong>15.SQL语言分类</strong></h4><blockquote>
<p><strong>SQL语言共分为四大类：</strong></p>
<ul>
<li>数据查询语言DQL</li>
<li>数据操纵语言DML</li>
<li>数据定义语言DDL</li>
<li>数据控制语言DCL。</li>
</ul>
<p><strong>1. 数据查询语言DQL</strong></p>
<p>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：</p>
<p>SELECT<br>FROM<br>WHERE</p>
<p><strong>2 .数据操纵语言DML</strong></p>
<p>数据操纵语言DML主要有三种形式：</p>
<ol>
<li>插入：INSERT</li>
<li>更新：UPDATE</li>
<li>删除：DELETE</li>
</ol>
<p><strong>3. 数据定义语言DDL</strong></p>
<p>数据定义语言DDL用来创建数据库中的各种对象—–表、视图、索引、同义词、聚簇等如：<br>CREATE TABLE&#x2F;VIEW&#x2F;INDEX&#x2F;SYN&#x2F;CLUSTER</p>
<p>表 视图 索引 同义词 簇</p>
<p>DDL操作是隐性提交的！不能rollback</p>
<p><strong>4. 数据控制语言DCL</strong></p>
<p>数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。如：</p>
<ol>
<li>GRANT：授权。</li>
<li>ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。回滚—ROLLBACK；回滚命令使数据库状态回到上次最后提交的状态。其格式为：<br>SQL&gt;ROLLBACK;</li>
<li>COMMIT [WORK]：提交。</li>
</ol>
<p>在数据库的插入、删除和修改操作时，只有当事务在提交到数据<br>库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看<br>到所做的事情，别人只有在最后提交完成后才可以看到。<br>提交数据有三种类型：显式提交、隐式提交及自动提交。下面分<br>别说明这三种类型。</p>
<p>(1) 显式提交<br>用COMMIT命令直接完成的提交为显式提交。其格式为：<br>SQL&gt;COMMIT；</p>
<p>(2) 隐式提交<br>用SQL命令间接完成的提交为隐式提交。这些命令是：<br>ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，<br>EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。</p>
<p>(3) 自动提交<br>若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，<br>系统将自动进行提交，这就是自动提交。其格式为：<br>SQL&gt;SET AUTOCOMMIT ON；</p>
<p>参考文章：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/study-s/p/5287529.html">https://www.cnblogs.com/study-s/p/5287529.html</a></p>
</blockquote>
<h4 id="16-like-和-的区别"><a href="#16-like-和-的区别" class="headerlink" title="16.like %和-的区别"></a><strong>16.like %和-的区别</strong></h4><blockquote>
<p><strong>通配符的分类:</strong></p>
<p>**%百分号通配符:**表示任何字符出现任意次数(可以是0次).</p>
<p>**_下划线通配符:**表示只能匹配单个字符,不能多也不能少,就是一个字符.</p>
<p><strong>like操作符:</strong> LIKE作用是指示mysql后面的搜索模式是利用通配符而不是直接相等匹配进行比较.</p>
<p><strong>注意:</strong> 如果在使用like操作符时,后面的没有使用通用匹配符效果是和&#x3D;一致的,SELECT * FROM products WHERE products.prod_name like ‘1000’;<br>只能匹配的结果为1000,而不能匹配像JetPack 1000这样的结果.</p>
<ul>
<li>%通配符使用: 匹配以”yves”开头的记录:(包括记录”yves”) SELECT <em>FROM products WHERE products.prod_name like ‘yves%’;<br>匹配包含”yves”的记录(包括记录”yves”) SELECT</em> FROM products WHERE products.prod_name like ‘%yves%’;<br>匹配以”yves”结尾的记录(包括记录”yves”,不包括记录”yves “,也就是yves后面有空格的记录,这里需要注意) SELECT * FROM products WHERE products.prod_name like ‘%yves’;</li>
<li><em>通配符使用: SELECT *FROM products WHERE products.prod_name like ‘_yves’; 匹配结果为: 像”yyves”这样记录.<br>SELECT* FROM products WHERE products.prod*name like ‘yves</em>*’; 匹配结果为: 像”yvesHe”这样的记录.(一个下划线只能匹配一个字符,不能多也不能少)</li>
</ul>
<p><strong>注意事项:</strong></p>
<ul>
<li>注意大小写,在使用模糊匹配时,也就是匹配文本时,mysql是可能区分大小的,也可能是不区分大小写的,这个结果是取决于用户对MySQL的配置方式.如果是区分大小写,那么像YvesHe这样记录是不能被”yves__”这样的匹配条件匹配的.</li>
<li>注意尾部空格,”%yves”是不能匹配”heyves “这样的记录的.</li>
<li>注意NULL,%通配符可以匹配任意字符,但是不能匹配NULL,也就是说SELECT * FROM products WHERE products.prod_name like ‘%;是匹配不到products.prod_name为NULL的的记录.</li>
</ul>
<p><strong>技巧与建议:</strong></p>
<p>正如所见， MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一些使用通配符要记住的技巧。</p>
<ul>
<li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该 使用其他操作符。</li>
<li>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用 在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起 来是最慢的。</li>
<li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数.</li>
</ul>
</blockquote>
<p>参考博文：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011479200/article/details/78513632">https://blog.csdn.net/u011479200/article/details/78513632</a></p>
<h4 id="17-count-、count-1-、count-column-的区别"><a href="#17-count-、count-1-、count-column-的区别" class="headerlink" title="17.count(*)、count(1)、count(column)的区别"></a><strong>17.count(*)、count(1)、count(column)的区别</strong></h4><blockquote>
<ul>
<li>count(*)对行的数目进行计算,包含NULL</li>
<li>count(column)对特定的列的值具有的行数进行计算,不包含NULL值。</li>
<li>count()还有一种使用方式,count(1)这个用法和count(*)的结果是一样的。</li>
</ul>
<p><strong>性能问题:</strong></p>
<p>1.任何情况下SELECT COUNT(*) FROM tablename是最优选择;</p>
<p>2.尽量减少SELECT COUNT(*) FROM tablename WHERE COL &#x3D; ‘value’ 这种查询;</p>
<p>3.杜绝SELECT COUNT(COL) FROM tablename WHERE COL2 &#x3D; ‘value’ 的出现。</p>
<ul>
<li>如果表没有主键,那么count(1)比count(*)快。</li>
<li>如果有主键,那么count(主键,联合主键)比count(*)快。</li>
<li>如果表只有一个字段,count(*)最快。</li>
</ul>
<p>count(1)跟count(主键)一样,只扫描主键。count(*)跟count(非主键)一样,扫描整个表。明显前者更快一些。</p>
</blockquote>
<h4 id="18-最左前缀原则"><a href="#18-最左前缀原则" class="headerlink" title="18.最左前缀原则"></a><strong>18.最左前缀原则</strong></h4><blockquote>
<p><strong>多列索引：</strong></p>
<p>ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age);</p>
<p>为了提高搜索效率，我们需要考虑运用多列索引,由于索引文件以B－Tree格式保存，所以我们不用扫描任何记录，即可得到最终结果。</p>
<p>注：在mysql中执行查询时，只能使用一个索引，如果我们在lname,fname,age上分别建索引,执行查询时，只能使用一个索引，mysql会选择一个最严格(获得结果集记录数最少)的索引。</p>
<p><strong>最左前缀原则：</strong>顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。</p>
</blockquote>
<h2 id="二、索引"><a href="#二、索引" class="headerlink" title="二、索引"></a>二、索引</h2><h4 id="1-什么是索引？"><a href="#1-什么是索引？" class="headerlink" title="1.什么是索引？"></a><strong>1.什么是索引？</strong></h4><blockquote>
<p><strong>何为索引：</strong></p>
<p>数据库索引，是数据库管理系统中一个排序的数据结构，索引的实现通常使用B树及其变种B+树。</p>
<p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
</blockquote>
<h4 id="2-索引的作用？它的优点缺点是什么？"><a href="#2-索引的作用？它的优点缺点是什么？" class="headerlink" title="2.索引的作用？它的优点缺点是什么？"></a><strong>2.索引的作用？它的优点缺点是什么？</strong></h4><blockquote>
<p><strong>索引作用：</strong></p>
<p>协助快速查询、更新数据库表中数据。</p>
<p>为表设置索引要付出代价的：</p>
<ul>
<li>一是增加了数据库的存储空间</li>
<li>二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</li>
</ul>
</blockquote>
<h4 id="3-索引的优缺点？"><a href="#3-索引的优缺点？" class="headerlink" title="3.索引的优缺点？"></a>3.索引的优缺点？</h4><p><strong>创建索引可以大大提高系统的性能（优点）：</strong></p>
<p>1.通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p>
<p>2.可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p>
<p>3.可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p>
<p>4.在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p>
<p>5.通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p>
<p><strong>增加索引也有许多不利的方面(缺点)：</strong></p>
<p>1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p>
<p>2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p>
<p>3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p>
<h4 id="4-哪些列适合建立索引、哪些不适合建索引？"><a href="#4-哪些列适合建立索引、哪些不适合建索引？" class="headerlink" title="4.哪些列适合建立索引、哪些不适合建索引？"></a><strong>4.哪些列适合建立索引、哪些不适合建索引？</strong></h4><blockquote>
<p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。</p>
<p><strong>一般来说，应该在这些列上创建索引：</strong></p>
<p>（1）在经常需要搜索的列上，可以加快搜索的速度；</p>
<p>（2）在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</p>
<p>（3）在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</p>
<p>（4）在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</p>
<p>（5）在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p>
<p>（6）在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p>
<p><strong>对于有些列不应该创建索引：</strong></p>
<p>（1）对于那些在查询中很少使用或者参考的列不应该创建索引。</p>
<p>这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p>
<p>（2）对于那些只有很少数据值的列也不应该增加索引。</p>
<p>这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p>
<p>（3）对于那些定义为 text, image 和 bit 数据类型的列不应该增加索引。</p>
<p>这是因为，这些列的数据量要么相当大，要么取值很少。</p>
<p>(4)当修改性能远远大于检索性能时，不应该创建索引。</p>
<p>这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p>
</blockquote>
<h4 id="5-什么样的字段适合建索引"><a href="#5-什么样的字段适合建索引" class="headerlink" title="5.什么样的字段适合建索引"></a><strong>5.什么样的字段适合建索引</strong></h4><blockquote>
<p>唯一、不为空、经常被查询的字段</p>
<h4 id="6-MySQL-B-Tree索引和Hash索引的区别"><a href="#6-MySQL-B-Tree索引和Hash索引的区别" class="headerlink" title="6.MySQL B+Tree索引和Hash索引的区别?"></a>6.MySQL B+Tree索引和Hash索引的区别?</h4><p><strong>Hash索引和B+树索引的特点：</strong></p>
<ul>
<li>Hash索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位;</li>
<li>B+树索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问;</li>
</ul>
<p><strong>为什么不都用Hash索引而使用B+树索引？</strong></p>
<ol>
<li>Hash索引仅仅能满足”&#x3D;”,”IN”和””查询，不能使用范围查询,因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样；</li>
<li>Hash索引无法被用来避免数据的排序操作，因为Hash值的大小关系并不一定和Hash运算前的键值完全一样；</li>
<li>Hash索引不能利用部分索引键查询，对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用；</li>
<li>Hash索引在任何时候都不能避免表扫描，由于不同索引键存在相同Hash值，所以即使取满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要回表查询数据；</li>
<li>Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B+树索引高。</li>
</ol>
<p><strong>补充：</strong></p>
<p>1.MySQL中，只有HEAP&#x2F;MEMORY引擎才显示支持Hash索引。</p>
<p>2.常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引），通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。<br>B+树索引和哈希索引的明显区别是：</p>
<p>3.如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；</p>
<p>4.如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；<br>同理，哈希索引没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；</p>
<p>5.哈希索引也不支持多列联合索引的最左匹配规则；</p>
<p>6.B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。</p>
<p>7.在大多数场景下，都会有范围查询、排序、分组等查询特征，用B+树索引就可以了。</p>
</blockquote>
<h4 id="7-B树和B-树的区别"><a href="#7-B树和B-树的区别" class="headerlink" title="7.B树和B+树的区别"></a><strong>7.B树和B+树的区别</strong></h4><blockquote>
<ol>
<li>B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。<br><img src="https://i.imgur.com/RbzI0R8.jpg" srcset="/img/loading.gif" lazyload alt="img"></li>
<li>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)<br><img src="https://i.imgur.com/9VbnDME.jpg" srcset="/img/loading.gif" lazyload alt="img"></li>
</ol>
</blockquote>
<h4 id="8-为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#8-为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="8.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？"></a><strong>8.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</strong></h4><blockquote>
<p><strong>1.B+的磁盘读写代价更低</strong></p>
<p>B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p>
<p><strong>2.B+tree的查询效率更加稳定</strong></p>
<p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</blockquote>
<h4 id="9-聚集索引和非聚集索引区别"><a href="#9-聚集索引和非聚集索引区别" class="headerlink" title="9.聚集索引和非聚集索引区别?"></a><strong>9.聚集索引和非聚集索引区别?</strong></h4><blockquote>
<p><strong>聚合索引(clustered index):</strong></p>
<p>聚集索引<strong>表记录的排列顺序和索引的排列顺序一致，所以查询效率快，</strong>只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。<br>聚集索引类似于新华字典中用拼音去查找汉字，拼音检索表于书记顺序都是按照a~z排列的，就像相同的逻辑顺序于物理顺序一样，当你需要查找a,ai两个读音的字，或是想一次寻找多个傻(sha)的同音字时，也许向后翻几页，或紧接着下一行就得到结果了。</p>
<p><strong>非聚合索引(nonclustered index):</strong></p>
<p>非聚集索引<strong>指定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，</strong>两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。<br>非聚集索引类似在新华字典上通过偏旁部首来查询汉字，检索表也许是按照横、竖、撇来排列的，但是由于正文中是a~z的拼音顺序，所以就类似于逻辑地址于物理地址的不对应。同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。</p>
<p><strong>根本区别：</strong></p>
<p>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</p>
</blockquote>
<h2 id="三、事务"><a href="#三、事务" class="headerlink" title="三、事务"></a>三、事务</h2><h4 id="1-什么是事务？"><a href="#1-什么是事务？" class="headerlink" title="1.什么是事务？"></a><strong>1.什么是事务？</strong></h4><blockquote>
<p>事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。</p>
</blockquote>
<h4 id="2-事务四大特性（ACID）原子性、一致性、隔离性、持久性"><a href="#2-事务四大特性（ACID）原子性、一致性、隔离性、持久性" class="headerlink" title="2. 事务四大特性（ACID）原子性、一致性、隔离性、持久性?"></a><strong>2. 事务四大特性（ACID）原子性、一致性、隔离性、持久性?</strong></h4><blockquote>
<p><strong>原子性（Atomicity）:</strong><br>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
<p><strong>一致性（Consistency）:</strong><br>事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。</p>
<p><strong>隔离性（Isolation）:</strong><br>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>
<p><strong>持久性（Durability）:</strong><br>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
</blockquote>
<h4 id="3-事务的并发-事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别"><a href="#3-事务的并发-事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别" class="headerlink" title="3. 事务的并发? 事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别?"></a><strong>3. 事务的并发? 事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别?</strong></h4><blockquote>
<p>从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题，然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行， 在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行， 事务的隔离级别可以通过隔离事务属性指定。<br><strong>事务的并发问题：</strong></p>
<p><strong>1、脏读：</strong>事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p>
<p><strong>2、不可重复读：</strong>事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</p>
<p><strong>3、幻读：</strong>幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。</p>
<p>例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。 而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。<br><strong>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</strong></p>
<p><strong>事务的隔离级别</strong></p>
<p><img src="https://i.imgur.com/xAeWTSp.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>读未提交：</strong>另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读</p>
<p><strong>不可重复读：</strong>事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</p>
<p><strong>可重复读：</strong>在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象</p>
<p><strong>串行化：</strong>最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样</p>
</blockquote>
<p><strong>特别注意：</strong></p>
<blockquote>
<p>MySQL默认的事务隔离级别为repeatable-read</p>
<p>MySQL 支持 4 中事务隔离级别.</p>
<p>事务的隔离级别要得到底层数据库引擎的支持, 而不是应用程序或者框架的支持.</p>
<p>Oracle 支持的 2 种事务隔离级别：READ_COMMITED , SERIALIZABLE</p>
<p>SQL规范所规定的标准，不同的数据库具体的实现可能会有些差异</p>
<p><strong>MySQL中默认事务隔离级别是“可重复读”时并不会锁住读取到的行</strong></p>
<p><strong>事务隔离级别：</strong>未提交读时，写数据只会锁住相应的行。</p>
<p><strong>事务隔离级别为：</strong>可重复读时，写数据会锁住整张表。</p>
<p><strong>事务隔离级别为：</strong>串行化时，读写数据都会锁住整张表。</p>
<p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</p>
</blockquote>
<h4 id="4-事务传播行为"><a href="#4-事务传播行为" class="headerlink" title="4.事务传播行为"></a><strong>4.事务传播行为</strong></h4><blockquote>
<p><strong>1.PROPAGATION_REQUIRED：</strong>如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p>
<p><strong>2.PROPAGATION_SUPPORTS：</strong>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p>
<p><strong>3.PROPAGATION_MANDATORY：</strong>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p>
<p><strong>4.PROPAGATION_REQUIRES_NEW：</strong>创建新事务，无论当前存不存在事务，都创建新事务。</p>
<p><strong>5.PROPAGATION_NOT_SUPPORTED：</strong>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>
<p><strong>6.PROPAGATION_NEVER：</strong>以非事务方式执行，如果当前存在事务，则抛出异常。</p>
<p><strong>7.PROPAGATION_NESTED：</strong>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p>
</blockquote>
<h4 id="5-嵌套事务"><a href="#5-嵌套事务" class="headerlink" title="5.嵌套事务"></a><strong>5.嵌套事务</strong></h4><blockquote>
<p><strong>什么是嵌套事务？</strong></p>
<p>嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。看几个问题就明了了：</p>
<p><strong>如果子事务回滚，会发生什么？</strong></p>
<p>父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。</p>
<p><strong>如果父事务回滚，会发生什么？</strong></p>
<p>父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么：</p>
<p><strong>事务的提交，是什么情况？</strong></p>
<p>是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。</p>
</blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liangxw1/article/details/51197560">https://blog.csdn.net/liangxw1/article/details/51197560</a></p>
<h2 id="四、存储引擎"><a href="#四、存储引擎" class="headerlink" title="四、存储引擎"></a>四、存储引擎</h2><h4 id="1-MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别"><a href="#1-MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别" class="headerlink" title="1.MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别?"></a><strong>1.MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别?</strong></h4><blockquote>
<p><strong>两种存储引擎的大致区别表现在：</strong></p>
<p>1.<strong>InnoDB支持事务，MyISAM不支持，</strong> <strong>这一点是非常之重要。</strong>事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。</p>
<p>2.MyISAM适合查询以及插入为主的应用。</p>
<p>3.InnoDB适合频繁修改以及涉及到安全性较高的应用。</p>
<p>4.InnoDB支持外键，MyISAM不支持。</p>
<p>5.从MySQL5.5.5以后，InnoDB是默认引擎。</p>
<p>6.InnoDB不支持FULLTEXT类型的索引。</p>
<p>7.InnoDB中不保存表的行数，如select count(<em>) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含where条件时MyISAM也需要扫描整个表。</p>
<p>8.对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。</p>
<p>9.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的 删除，效率非常慢。MyISAM则会重建表。</p>
<p>10.InnoDB支持行锁（某些情况下还是锁整表，如 update table set a&#x3D;1 where user like ‘%lee%’。</p>
</blockquote>
<h4 id="2-MySQL存储引擎MyISAM与InnoDB如何选择"><a href="#2-MySQL存储引擎MyISAM与InnoDB如何选择" class="headerlink" title="2.MySQL存储引擎MyISAM与InnoDB如何选择"></a><strong>2.MySQL存储引擎MyISAM与InnoDB如何选择</strong></h4><blockquote>
<p>MySQL有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用：MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE。</p>
<p>虽然MySQL里的存储引擎不只是MyISAM与InnoDB这两个，但常用的就是两个。<br>关于MySQL数据库提供的两种存储引擎，MyISAM与InnoDB选择使用：</p>
</blockquote>
<ul>
<li>1.INNODB会支持一些关系数据库的高级功能，如事务功能和行级锁，MyISAM不支持。</li>
<li>2.MyISAM的性能更优，占用的存储空间少，所以，选择何种存储引擎，视具体应用而定。</li>
</ul>
<blockquote>
<p>如果你的应用程序一定要使用事务，毫无疑问你要选择INNODB引擎。但要注意，INNODB的行级锁是有条件的。在where条件没有使用主键时，照样会锁全表。比如DELETE FROM mytable这样的删除语句。</p>
<p>如果你的应用程序对查询性能要求较高，就要使用MyISAM了。MyISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于INNODB。压缩后的索引也能节约一些磁盘空间。MyISAM拥有全文索引的功能，这可以极大地优化LIKE查询的效率。</p>
<p>有人说MyISAM只能用于小型应用，其实这只是一种偏见。如果数据量比较大，这是需要通过升级架构来解决，比如分表分库，而不是单纯地依赖存储引擎。</p>
<p>现在一般都是选用innodb了，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM对于读写密集型应用一般是不会去选用的。<br>MEMORY存储引擎</p>
<p>MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。<br>每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。</p>
<p>MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。</p>
<p>注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。</p>
</blockquote>
<h4 id="3-MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景"><a href="#3-MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景" class="headerlink" title="3.MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?"></a><strong>3.MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?</strong></h4><blockquote>
<p><strong>事务处理上方面</strong></p>
</blockquote>
<ul>
<li>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。</li>
<li>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li>
</ul>
<blockquote>
<p><strong>锁级别</strong></p>
</blockquote>
<ul>
<li>MyISAM：只支持表级锁，用户在操作MyISAM表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。</li>
<li>InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</li>
</ul>
<blockquote>
<p><strong>关于存储引擎MyISAM和InnoDB的其他参考资料如下：</strong></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/lc0817/article/details/52757194">MySQL存储引擎中的MyISAM和InnoDB区别详解</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kevingrace/p/5685355.html">MySQL存储引擎之MyISAM和Innodb总结性梳理</a></p>
</blockquote>
<h2 id="五、优化"><a href="#五、优化" class="headerlink" title="五、优化"></a>五、优化</h2><h4 id="1-查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序"><a href="#1-查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序" class="headerlink" title="1.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?"></a><strong>1.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?</strong></h4><ul>
<li>1.查询中用到的关键词主要包含<strong>六个</strong>，并且他们的顺序依次为 <strong>select–from–where–group by–having–order by</strong></li>
</ul>
<blockquote>
<p><strong>其中select和from是必须的，其他关键词是可选的，这六个关键词的执行顺序 与sql语句的书写顺序并不是一样的，而是按照下面的顺序来执行</strong></p>
<p>**from:**需要从哪个数据表检索数据</p>
</blockquote>
<blockquote>
<p>**where:**过滤表中数据的条件</p>
<p>**group by:**如何将上面过滤出的数据分组</p>
<p>**having:**对上面已经分组的数据进行过滤的条件</p>
<p>**select:**查看结果集中的哪个列，或列的计算结果</p>
<p>**order by :**按照什么样的顺序来查看返回的数据</p>
</blockquote>
<ul>
<li>2.<strong>from后面的表关联，是自右向左解析 而where条件的解析顺序是自下而上的。</strong></li>
</ul>
<blockquote>
<p>也就是说，在写SQL语句的时候，尽量把数据量小的表放在最右边来进行关联（用小表去匹配大表），而把能筛选出小量数据的条件放在where语句的最左边 （用小表去匹配大表）</p>
<p>其他参考资源：<br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/huminxxl/p/3149097.html">http://www.cnblogs.com/huminxxl/p/3149097.html</a></p>
</blockquote>
<h4 id="2-使用explain优化sql和索引"><a href="#2-使用explain优化sql和索引" class="headerlink" title="2.使用explain优化sql和索引?"></a><strong>2.使用explain优化sql和索引?</strong></h4><blockquote>
<p><strong>对于复杂、效率低的sql语句，我们通常是使用explain sql 来分析sql语句，这个语句可以打印出，语句的执行。这样方便我们分析，进行优化</strong></p>
<p><strong>table：</strong>显示这一行的数据是关于哪张表的</p>
<p><strong>type：</strong>这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL</p>
<p><strong>all:</strong> full table scan ;MySQL将遍历全表以找到匹配的行；</p>
<p><strong>index:</strong> index scan; index 和 all的区别在于index类型只遍历索引；</p>
<p><strong>range：</strong>索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between ，等查询；</p>
<p><strong>ref：</strong>非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找；</p>
<p><strong>eq_ref：</strong>唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描；</p>
<p><strong>const，system：</strong>当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于where列表中，MySQL就能将该查询转化为一个常量。</p>
<p><strong>possible_keys：</strong>显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</p>
<p><strong>key：</strong> 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引</p>
<p><strong>key_len：</strong>使用的索引的长度。在不损失精确性的情况下，长度越短越好</p>
<p><strong>ref：</strong>显示索引的哪一列被使用了，如果可能的话，是一个常数</p>
<p><strong>rows：</strong>MySQL认为必须检查的用来返回请求数据的行数</p>
<p><strong>Extra：</strong>关于MySQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MySQL根本不能使用索引，结果是检索会很慢。</p>
</blockquote>
<h4 id="3-MySQL慢查询怎么解决"><a href="#3-MySQL慢查询怎么解决" class="headerlink" title="3.MySQL慢查询怎么解决?"></a><strong>3.MySQL慢查询怎么解决?</strong></h4><blockquote>
<ul>
<li>slow_query_log 慢查询开启状态。</li>
<li>slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）。</li>
<li>long_query_time 查询超过多少秒才记录。</li>
</ul>
</blockquote>
<h2 id="六、数据库锁"><a href="#六、数据库锁" class="headerlink" title="六、数据库锁"></a>六、数据库锁</h2><h4 id="1-mysql-都有什么锁，死锁判定原理和具体场景，死锁怎么解决"><a href="#1-mysql-都有什么锁，死锁判定原理和具体场景，死锁怎么解决" class="headerlink" title="1. mysql 都有什么锁，死锁判定原理和具体场景，死锁怎么解决?"></a><strong>1. mysql 都有什么锁，死锁判定原理和具体场景，死锁怎么解决?</strong></h4><blockquote>
<p><strong>MySQL有三种锁的级别：</strong>页级、表级、行级。</p>
<ul>
<li><strong>表级锁：</strong>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li>
<li><strong>行级锁：</strong>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li>
<li><strong>页面锁：</strong>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般<br><strong>什么情况下会造成死锁?</strong></li>
</ul>
<p><strong>什么是死锁？</strong></p>
<p><strong>死锁:</strong> 是指两个或两个以上的进程在执行过程中。因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程。</p>
<p>表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的 InnoDB。</p>
<p><strong>死锁的关键在于：</strong>两个(或以上)的Session加锁的顺序不一致。</p>
<p>那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。</p>
<p><strong>死锁的解决办法?</strong></p>
<p>1.查出的线程杀死 kill<br>SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;</p>
<p>2.设置锁的超时时间<br>Innodb 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。</p>
<p>生产环境不推荐使用过大的 innodb_lock_wait_timeout参数值<br>该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间，如下：<br>set innodb_lock_wait_timeout&#x3D;1000; —设置当前会话 Innodb 行锁等待超时时间，单位秒。</p>
<p>3.指定获取锁的顺序</p>
</blockquote>
<h4 id="2-有哪些锁（乐观锁悲观锁），select-时怎么加排它锁"><a href="#2-有哪些锁（乐观锁悲观锁），select-时怎么加排它锁" class="headerlink" title="2. 有哪些锁（乐观锁悲观锁），select 时怎么加排它锁?"></a><strong>2. 有哪些锁（乐观锁悲观锁），select 时怎么加排它锁?</strong></h4><blockquote>
<p><strong>悲观锁（Pessimistic Lock）:</strong></p>
<p>**悲观锁特点:**先获取锁，再进行业务操作。</p>
<p>即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的<strong>“一锁二查三更新”即指的是使用悲观锁。</strong>通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p>
<p><strong>补充：</strong><br>不同的数据库对select for update的实现和支持都是有所区别的，</p>
<ul>
<li>oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，MySQL就没有no wait这个选项。</li>
<li>MySQL还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在MySQL中用悲观锁务必要确定走了索引，而不是全表扫描。</li>
</ul>
<p><strong>乐观锁（Optimistic Lock）:</strong></p>
<p>**1. **乐观锁，也叫乐观并发控制，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，那么当前正在提交的事务会进行回滚。</p>
<p>**2.  <strong>乐观锁的特点先进行业务操作，不到万不得已不去拿锁。</strong>即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。<br>乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。</p>
<p><strong>3.<strong>一般的做法是</strong>在需要锁的数据上增加一个版本号，或者时间戳</strong>，</p>
<p><strong>实现方式举例如下：</strong></p>
<p><strong>乐观锁（给表加一个版本号字段）</strong> 这个并不是乐观锁的定义，给表加版本号，是<strong>数据库实现乐观锁的一种方式</strong>。</p>
<ol>
<li>SELECT data AS old_data, version AS old_version FROM …;</li>
<li>根据获取的数据进行业务操作，得到new_data和new_version</li>
<li>UPDATE SET data &#x3D; new_data, version &#x3D; new_version WHERE version &#x3D; old_version</li>
</ol>
<p>if (updated row &gt; 0) {</p>
<p>&#x2F;&#x2F; 乐观锁获取成功，操作完成</p>
<p>} else {</p>
<p>&#x2F;&#x2F; 乐观锁获取失败，回滚并重试</p>
<p>}</p>
<p><strong>注意：</strong></p>
<ul>
<li>乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能</li>
<li>乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方。</li>
</ul>
<p><strong>总结：</strong><br>悲观锁和乐观锁是数据库用来保证数据并发安全防止更新丢失的两种方法，例子在select … for update前加个事务就可以防止更新丢失。悲观锁和乐观锁大部分场景下差异不大，一些独特场景下有一些差别，一般我们可以从如下几个方面来判断。</p>
<ul>
<li><strong>响应速度：</strong> 如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。’</li>
<li><strong>冲突频率：</strong> 如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。</li>
<li><strong>重试代价：</strong> 如果重试代价大，建议采用悲观锁。</li>
</ul>
</blockquote>
<h2 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h2><h4 id="1-数据库的主从复制"><a href="#1-数据库的主从复制" class="headerlink" title="1.数据库的主从复制"></a><strong>1.数据库的主从复制</strong></h4><blockquote>
<p><strong>主从复制的几种方式:</strong></p>
<p><strong>同步复制:</strong></p>
<p>所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,…,slave-n完成后才能返回。 这样，显然不可取，也不是MySQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间。</p>
<p><strong>异步复制:</strong></p>
<p>如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心,MySQL的默认设置。</p>
<p><strong>半同步复制:</strong></p>
<p>master只保证slaves中的一个操作成功，就返回，其他slave不管。 这个功能，是由google为MySQL引入的。</p>
</blockquote>
<h4 id="2-数据库主从复制分析的-7-个问题"><a href="#2-数据库主从复制分析的-7-个问题" class="headerlink" title="2.数据库主从复制分析的 7 个问题?"></a><strong>2.数据库主从复制分析的 7 个问题?</strong></h4><p><strong>问题1：</strong>master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？</p>
<blockquote>
<p>假设slave可以主动的进行写操作，slave又无法通知master，这样就导致了master和slave数据不一致了。因此slave不应该进行写操作，至少是slave上涉及到复制的数据库不可以写。实际上，这里已经揭示了读写分离的概念。</p>
</blockquote>
<p><strong>问题2：</strong>主从复制中，可以有N个slave,可是这些slave又不能进行写操作，要他们干嘛？</p>
<blockquote>
<p><strong>实现数据备份:</strong><br>类似于高可用的功能，一旦master挂了，可以让slave顶上去，同时slave提升为master。</p>
<p>**异地容灾:**比如master在北京，地震挂了，那么在上海的slave还可以继续。<br>主要用于实现scale out,分担负载,可以将读的任务分散到slaves上。<br>【很可能的情况是，一个系统的读操作远远多于写操作，因此写操作发向master，读操作发向slaves进行操作】</p>
</blockquote>
<p><strong>问题3：</strong>主从复制中有master,slave1,slave2,…等等这么多MySQL数据库，那比如一个JAVA WEB应用到底应该连接哪个数据库?</p>
<blockquote>
<p>我们在应用程序中可以这样，insert&#x2F;delete&#x2F;update这些更新数据库的操作，用connection(for master)进行操作，</p>
<p>select用connection(for slaves)进行操作。那我们的应用程序还要完成怎么从slaves选择一个来执行select，例如使用简单的轮循算法。</p>
<p>这样的话，相当于应用程序完成了SQL语句的路由，而且与MySQL的主从复制架构非常关联，一旦master挂了，某些slave挂了，那么应用程序就要修改了。能不能让应用程序与MySQL的主从复制架构没有什么太多关系呢？<br>找一个组件，application program只需要与它打交道，用它来完成MySQL的代理，实现SQL语句的路由。<br>MySQL proxy并不负责，怎么从众多的slaves挑一个？可以交给另一个组件(比如haproxy)来完成。</p>
<p>这就是所谓的MySQL READ WRITE SPLITE，MySQL的读写分离。</p>
</blockquote>
<p><strong>问题4：</strong>如果MySQL proxy , direct , master他们中的某些挂了怎么办？</p>
<blockquote>
<p>总统一般都会弄个副总统，以防不测。同样的，可以给这些关键的节点来个备份。</p>
</blockquote>
<p><strong>问题5：</strong>当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave,那是发N次，还是只发一次？如果只发一次，发给了slave-1，那slave-2,slave-3,…它们怎么办？</p>
<blockquote>
<p>显 然，应该发N次。实际上，在MySQL master内部，维护N个线程，每一个线程负责将二进制日志文件发往对应的slave。master既要负责写操作，还的维护N个线程，负担会很重。可以这样，slave-1是master的从，slave-1又是slave-2,slave-3,…的主，同时slave-1不再负责select。 slave-1将master的复制线程的负担，转移到自己的身上。这就是所谓的多级复制的概念。</p>
</blockquote>
<p><strong>问题6：</strong>当一个select发往MySQL proxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了。</p>
<blockquote>
<p>应该找一个共享式的缓存，比如memcache来解决。将slave-2,slave-3,…这些查询的结果都缓存至mamcache中。</p>
</blockquote>
<p><strong>问题7：</strong>随着应用的日益增长，读操作很多，我们可以扩展slave，但是如果master满足不了写操作了，怎么办呢？</p>
<blockquote>
<p>scale on ?更好的服务器？ 没有最好的，只有更好的，太贵了。。。<br>scale out ? 主从复制架构已经满足不了。<br>可以分库【垂直拆分】，分表【水平拆分】。</p>
</blockquote>
<h4 id="3-mysql-高并发环境解决方案"><a href="#3-mysql-高并发环境解决方案" class="headerlink" title="3.mysql 高并发环境解决方案?"></a><strong>3.mysql 高并发环境解决方案?</strong></h4><blockquote>
<p><strong>MySQL 高并发环境解决方案：</strong> 分库 分表 分布式 增加二级缓存。。。。。</p>
<p><strong>需求分析：</strong>互联网单位 每天大量数据读取，写入，并发性高。</p>
<p><strong>现有解决方式：</strong>水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。</p>
<p><strong>集群方案：</strong>解决DB宕机带来的单点DB不能访问问题。</p>
<p><strong>读写分离策略：</strong>极大限度提高了应用中Read数据的速度和并发量。无法解决高写入压力。</p>
</blockquote>
<h4 id="4-数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）"><a href="#4-数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）" class="headerlink" title="4.数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）?"></a><strong>4.数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）?</strong></h4><p>转载：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Bozh/archive/2013/03/18/2966494.html">MySQL REDO日志和UNDO日志</a></p>
<blockquote>
<p><strong>Undo Log:</strong></p>
<p>Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用了Undo Log来实现多版本并发控制(简称：MVCC)。</p>
<p>事务的原子性(Atomicity)事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。<br>原理Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。</p>
<p>之所以能同时保证原子性和持久化，是因为以下<strong>特点：</strong></p>
<p>更新数据前记录Undo log。<br>为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。<br>Undo log必须先于数据持久化到磁盘。如果在G,H之间系统崩溃，undo log是完整的， 可以用来回滚事务。<br>如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。</p>
<p><strong>缺陷：</strong>每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。<br>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即Redo Log。</p>
<p><strong>Redo Log:</strong></p>
<p>原理和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。</p>
</blockquote>
<h4 id="八、整理时参考的资料"><a href="#八、整理时参考的资料" class="headerlink" title="八、整理时参考的资料"></a><strong>八、整理时参考的资料</strong></h4><p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTY0NDU3Nw==&mid=2651936134&idx=1&sn=5213a59104f6d2a90bc18d878cafe417&chksm=8d0f3ac8ba78b3deb2ea3473906a37dd205b6e64bfbebe86cc00108242bfa4c49a7d1e509eca&mpshare=1&scene=1&srcid=0707k8Bdz85tDHyVotxEQ9of#rd">java团长 数据库整理</a></p>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/yanpenglei/blog/1650277">20个数据库常见面试题讲解 - 鹏磊 - 开源中国”</a></p>
<p><a target="_blank" rel="noopener" href="https://m.2cto.com/database/201710/688377.html">34个数据库常见面试题讲解</a></p>
<p><a target="_blank" rel="noopener" href="https://kb.cnblogs.com/page/45712/">漫谈数据库索引<em>知识库</em>博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011479200/article/details/78513632">Mysql| 使用通配符进行模糊查询(like,%,_)</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/lc0817/article/details/52757194">MySQL存储引擎中的MyISAM和InnoDB区别详解</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kevingrace/p/5685355.html">MySQL存储引擎之MyISAM和Innodb总结性梳理</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liangxw1/article/details/51197560">https://blog.csdn.net/liangxw1/article/details/51197560</a></p>
<p>分类: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/wenxiaofei/category/1317332.html">数据库面试</a></p>
<h2 id="Mybatis面试题及答案整理"><a href="#Mybatis面试题及答案整理" class="headerlink" title="Mybatis面试题及答案整理"></a>Mybatis面试题及答案整理</h2><p>Java程序员-张凯 2019-03-13 13:34:15  2946  收藏 47<br>分类专栏： mybatis面试题 文章标签： mybatis面试题 mybatis面试题及答案<br>版权</p>
<h3 id="1、Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#1、Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="1、Mybatis是如何进行分页的？分页插件的原理是什么？"></a>1、Mybatis是如何进行分页的？分页插件的原理是什么？</h3><p>答：Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p>
<p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p>
<p>举例：select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10</p>
<h3 id="2、简述Mybatis的插件运行原理，以及如何编写一个插件。"><a href="#2、简述Mybatis的插件运行原理，以及如何编写一个插件。" class="headerlink" title="2、简述Mybatis的插件运行原理，以及如何编写一个插件。"></a>2、简述Mybatis的插件运行原理，以及如何编写一个插件。</h3><p>答：Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p>
<p>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>
<h3 id="3、Mybatis执行批量插入，能返回数据库主键列表吗？"><a href="#3、Mybatis执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="3、Mybatis执行批量插入，能返回数据库主键列表吗？"></a>3、Mybatis执行批量插入，能返回数据库主键列表吗？</h3><p>答：能，JDBC都能，Mybatis当然也能。</p>
<h3 id="4、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"><a href="#4、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？" class="headerlink" title="4、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"></a>4、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</h3><p>答：Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。</p>
<p>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p>
<h3 id="5、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#5、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="5、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>5、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h3><p>答：第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</p>
<p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h3 id="6、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"><a href="#6、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。" class="headerlink" title="6、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"></a>6、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。</h3><p>答：能，Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。</p>
<p>关联对象查询，有两种实现方式，一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。</p>
<p>那么问题来了，join查询出来100条记录，如何确定主对象是5个，而不是100个？其去重复的原理是<resultMap>标签内的<id>子标签，指定了唯一确定一条记录的id列，Mybatis根据<id>列值来完成100条记录的去重复功能，<id>可以有多个，代表了联合主键的语意。</p>
<p>同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。</p>
<p>举例：下面join查询出来6条记录，一、二列是Teacher对象列，第三列为Student对象列，Mybatis去重复处理后，结果为1个老师6个学生，而不是6个老师6个学生。</p>
<pre><code class="hljs">   t_id    t_name           s_id
</code></pre>
<p>|          1 | teacher      |      38 |<br>|          1 | teacher      |      39 |<br>|          1 | teacher      |      40 |<br>|          1 | teacher      |      41 |<br>|          1 | teacher      |      42 |<br>|          1 | teacher      |      43 |</p>
<h3 id="7、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#7、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="7、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>7、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h3><p>答：Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false。</p>
<p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p>
<h3 id="8、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#8、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="8、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>8、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h3><p>答：不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。</p>
<p>原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p>
<h3 id="9、Mybatis中如何执行批处理？"><a href="#9、Mybatis中如何执行批处理？" class="headerlink" title="9、Mybatis中如何执行批处理？"></a>9、Mybatis中如何执行批处理？</h3><p>答：使用BatchExecutor完成批处理。</p>
<h3 id="10、Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#10、Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="10、Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>10、Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h3><p>答：Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p>
<p>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</p>
<p>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</p>
<p>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p>
<p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p>
<h3 id="11、Mybatis中如何指定使用哪一种Executor执行器？"><a href="#11、Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="11、Mybatis中如何指定使用哪一种Executor执行器？"></a>11、Mybatis中如何指定使用哪一种Executor执行器？</h3><p>答：在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。</p>
<h3 id="12、Mybatis是否可以映射Enum枚举类？"><a href="#12、Mybatis是否可以映射Enum枚举类？" class="headerlink" title="12、Mybatis是否可以映射Enum枚举类？"></a>12、Mybatis是否可以映射Enum枚举类？</h3><p>答：Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。</p>
<h3 id="13、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"><a href="#13、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="13、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"></a>13、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</h3><p>答：虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。</p>
<p>原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</p>
<h3 id="14、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#14、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="14、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>14、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h3><p>答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<parameterMap>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。<resultMap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</p>
<h3 id="15、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#15、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="15、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>15、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h3><p>答：Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p>
<h3 id="16、-和-的区别是什么？"><a href="#16、-和-的区别是什么？" class="headerlink" title="16、#{}和${}的区别是什么？"></a>16、#{}和${}的区别是什么？</h3><p>答：${}是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。#{}是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值，比如ps.setInt(0, parameterValue)，#{item.name}的取值方式为使用反射从参数对象中获取item对象的name属性值，相当于param.getItem().getName()。</p>
<h3 id="17、Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？"><a href="#17、Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？" class="headerlink" title="17、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？"></a>17、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h3><p>答：还有很多其他的标签，<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中<sql>为sql片段标签，通过<include>标签引入sql片段，<selectKey>为不支持自增的主键生成策略标签。</p>
<h3 id="18、最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"><a href="#18、最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="18、最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"></a>18、最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</h3><p>答：Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id &#x3D; findStudentById的MappedStatement。在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。</p>
<p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p>
<p>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p>
<p>面试题看似都很简单，但是想要能正确回答上来，必定是研究过源码且深入的人，而不是仅会使用的人或者用的很熟的人。<br>————————————————<br>版权声明：本文为CSDN博主「Java程序员-张凯」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41701956/article/details/88530406">https://blog.csdn.net/qq_41701956/article/details/88530406</a></p>
<h1 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h1><p>java begin</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>

<p>java end</p>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" class="category-chain-item">面试题</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/" class="print-no-link">#Java</a>
      
        <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B-JVM-Spring-SpringCloud/" class="print-no-link">#多线程 - JVM - Spring - SpringCloud</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java面试题</div>
      <div>http://coderdream.github.io/2024/02/01/interview-question-java/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>CoderDream</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年2月1日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/02/01/docker-desktop/" title="Docker Desktop 相关">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Docker Desktop 相关</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/02/01/k8s-1_29_0/" title="kubeadm快速部署Kubernetes 1.29.0版本集群">
                        <span class="hidden-mobile">kubeadm快速部署Kubernetes 1.29.0版本集群</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
