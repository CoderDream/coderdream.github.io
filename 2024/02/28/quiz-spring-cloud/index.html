

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/babyking_v4_128_128.png">
  <link rel="icon" href="/img/babyking_v4_128_128.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="CoderDream">
  <meta name="keywords" content="">
  
    <meta name="description" content="2023年Spring全家桶面试题—图灵徐庶一、Spring Framework1.谈谈你对Spring的理解什么是Spring Spring是一个生态，可以构建Java应用所需的一切基础设施。 通常Spring指的就是Spring Framework。  核心解释 Spring是一个轻量级的开源容器框架。 Spring是为了解决企业级应用开发的业务逻辑层和其他各层对象和对象直接的耦合问题 Spr">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式面试题汇总">
<meta property="og:url" content="http://coderdream.github.io/2024/02/28/quiz-spring-cloud/index.html">
<meta property="og:site_name" content="CoderDream Studio">
<meta property="og:description" content="2023年Spring全家桶面试题—图灵徐庶一、Spring Framework1.谈谈你对Spring的理解什么是Spring Spring是一个生态，可以构建Java应用所需的一切基础设施。 通常Spring指的就是Spring Framework。  核心解释 Spring是一个轻量级的开源容器框架。 Spring是为了解决企业级应用开发的业务逻辑层和其他各层对象和对象直接的耦合问题 Spr">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://coderdream.github.io/images/quiz-design-pattern_index_img.jpg">
<meta property="article:published_time" content="2024-02-28T01:20:39.000Z">
<meta property="article:modified_time" content="2024-02-28T02:20:39.000Z">
<meta property="article:author" content="CoderDream">
<meta property="article:tag" content="设计模式 - Spring">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://coderdream.github.io/images/quiz-design-pattern_index_img.jpg">
  
  
  
  <title>设计模式面试题汇总 - CoderDream Studio</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"coderdream.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>CoderDream</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="设计模式面试题汇总"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-02-28 09:20" pubdate>
          2024年2月28日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          24k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          202 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">设计模式面试题汇总</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="2023年Spring全家桶面试题—图灵徐庶"><a href="#2023年Spring全家桶面试题—图灵徐庶" class="headerlink" title="2023年Spring全家桶面试题—图灵徐庶"></a>2023年Spring全家桶面试题—图灵徐庶</h1><h2 id="一、Spring-Framework"><a href="#一、Spring-Framework" class="headerlink" title="一、Spring Framework"></a>一、Spring Framework</h2><h3 id="1-谈谈你对Spring的理解"><a href="#1-谈谈你对Spring的理解" class="headerlink" title="1.谈谈你对Spring的理解"></a>1.谈谈你对Spring的理解</h3><h4 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h4><blockquote>
<p>Spring是一个生态，可以构建Java应用所需的一切基础设施。</p>
<p>通常Spring指的就是Spring Framework。</p>
</blockquote>
<h4 id="核心解释"><a href="#核心解释" class="headerlink" title="核心解释"></a>核心解释</h4><blockquote>
<p>Spring是一个轻量级的开源容器框架。</p>
<p>Spring是为了解决企业级应用开发的业务逻辑层和其他各层对象和对象直接的耦合问题</p>
<p>Spring是一个<strong>IoC</strong>和<strong>AOP</strong>的容器框架。</p>
<p>IoC：控制反转</p>
<p>AOP：面向切面编程</p>
<p>容器：包含并管理应用对象的生命周期</p>
</blockquote>
<h3 id="2-Spring的优缺点是什么？"><a href="#2-Spring的优缺点是什么？" class="headerlink" title="2.Spring的优缺点是什么？"></a>2.Spring的优缺点是什么？</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li><p>方便解耦，简化开发</p>
<p>通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。</p>
<p>有了Spring，用户不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。</p>
<p>人话：集中管理对象，对象和对象之间的耦合度减低，方便维护对象。 </p>
</li>
<li><p>AOP编程的支持</p>
<p>通过Spring提供的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。</p>
<p>Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式管理，从而提供了更好的复用.</p>
<p>人话： 在不修改代码的情况下可以对业务代码进行增强 减少重复代码 提高开发效率 维护方便 </p>
</li>
<li><p>声明事物的支持</p>
<p>在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。</p>
<p>人话：提高开发效率，只需要一个简单注解@Transactional </p>
</li>
<li><p>方便程序的测试</p>
<p>可以用非容器依赖的编程方式进行几乎所有的测试工作，在Spring里，测试不再是昂贵的操作，而是随手可做的事情。例如：Spring对Junit4支持，可以通过注解方便的测试Spring程序。</p>
<p>人话： Spring实现测试 使我们 可以结合junit非常方便测试Spring Bean SpringMVC </p>
</li>
<li><p>方便集成各种优秀框架</p>
<p>Spring不排斥各种优秀的开源框架，相反，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架。</p>
<p>（如Struts，Hibernate、Hessian、Quartz）等的直接支持。</p>
<p>人话： 拥有非常强大粘合度、集成能力非常，只需要简单配置就可以集成第三方框架</p>
</li>
<li><p>降低Java EE API的使用难度</p>
<p>Spring对很多难用的Java EE API（如JDBC，JavaMail，远程调用等）提供了一个薄薄的封装层，通过Spring的简易封装，这些Java EE API的使用难度大为降低。</p>
<p>人话：简化开发， 帮我封装很多功能性代码</p>
</li>
<li><p>Java 源码是经典学习范例</p>
<p>Spring的源码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造 诣。Spring框架源码无疑是Java技术的最佳实践范例。如果想在短时间内迅速提高自己的Java技术水平和应用开发水平，学习和研究Spring源码将会使你收到意想不到的效果。</p>
<p>人话：学习到了Spring底层的实现、反射..设计模式 都是我们值得学习， 提供非常多的扩展接口供外部进行扩展</p>
</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>从应用层面来说是没有缺点的</li>
<li>简化开发， 如果想深入到底层去了解就非常困难（上层使用越简单、底层封装得就越复杂）</li>
<li>源码缺点：由于spring 大而全（要集成这么多框架、提供非常非常多的扩展点，经过十多年的代码迭代） 代码量非常庞大，一百多万 对于去深入学习源码带来了一定困难。</li>
</ol>
<h2 id="二、Spring-IoC"><a href="#二、Spring-IoC" class="headerlink" title="二、Spring IoC"></a>二、Spring IoC</h2><h3 id="3-什么是Spring-IoC-容器？有什么作用？"><a href="#3-什么是Spring-IoC-容器？有什么作用？" class="headerlink" title="3.什么是Spring IoC 容器？有什么作用？"></a>3.什么是Spring IoC 容器？有什么作用？</h3><blockquote>
<p>控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的”控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。 Spring IoC 负责创建对象，管理对象。</p>
<p>通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p>
<p>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</p>
</blockquote>
<p><strong>控制反转(IoC)有什么作用</strong></p>
<p>管理对象的创建和依赖关系的维护。对象的创建并不是一件简单的事，在对象关系比较复杂时，如果依赖关系需要程序猿来维护的话，那是相当头疼的</p>
<p>解耦，由容器去维护具体的对象</p>
<p>托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的</p>
<p>人话：作用：</p>
<p>控制反转控制了什么？</p>
<p>UserService service&#x3D;new UserService(); &#x2F;&#x2F; 耦合度太高 、维护不方便</p>
<p>引入IoC 就将创建对象的控制权交给Spring的IoC。以前由程序员自己控制对象创建， 现在交给Spring的IoC去创建，如果要去使用对象需要通过DI（依赖注入）@Autowired 自动注入，就可以使用对象 ;</p>
<p>优点： 1.集中管理对象、方便维护 。2.降低耦合度</p>
<p> IoC的优点是什么？</p>
<ul>
<li>最小的代价和最小的侵入性使松散耦合得以实现。 </li>
<li>IoC容器支持加载服务时的饿汉式初始化和懒加载。</li>
</ul>
<h3 id="4-Spring-IoC-的实现机制是什么？"><a href="#4-Spring-IoC-的实现机制是什么？" class="headerlink" title="4.Spring IoC 的实现机制是什么？"></a>4.Spring IoC 的实现机制是什么？</h3><blockquote>
<p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fruit</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>    	System.out.println(<span class="hljs-string">&quot;Apple&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Orange</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>    	System.out.println(<span class="hljs-string">&quot;Orange&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Fruit <span class="hljs-title function_">getInstance</span><span class="hljs-params">(String ClassName)</span>&#123;<br>        Fruit f=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>        	f = (Fruit)Class.forName(ClassName).newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        	e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> f;<br>        &#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] a)</span>&#123;<br>        <span class="hljs-type">Fruit</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> Factory.getInstance(<span class="hljs-string">&quot;Reflect.Apple&quot;</span>);<br>        <span class="hljs-keyword">if</span>(f!=<span class="hljs-literal">null</span>)&#123;<br>            f.eat();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-什么是Spring的依赖注入-DI-？IoC和DI的区别是什么"><a href="#5-什么是Spring的依赖注入-DI-？IoC和DI的区别是什么" class="headerlink" title="5.什么是Spring的依赖注入(DI)？IoC和DI的区别是什么"></a>5.什么是Spring的依赖注入(DI)？IoC和DI的区别是什么</h3><blockquote>
<p>很多人把IoC和DI说成一个东西，笼统来说的话是没有问题的，但是本质上还是有所区别的，希望大家能够严谨一点，IoC和DI是从不同的角度描述的同一件事，IoC是从容器的角度描述，而DI是从应用程序的角度来描述，也可以这样说，IoC是依赖倒置原则的设计思想，而 DI是具体的实现方式。</p>
<p>在面向对象设计的软件系统中，底层的实现都是由N个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。</p>
<img src="/2024/02/28/quiz-spring-cloud/image-20240229125907430.png" srcset="/img/loading.gif" lazyload class="" title="image-20240229125907430">

<p>有一个对象出了问题，就可能会影响到整个流程的正常运转。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。</p>
<img src="/2024/02/28/quiz-spring-cloud/image-20240229125846005.png" srcset="/img/loading.gif" lazyload class="" title="image-20240229125846005">

<p>大家看到了吧，由于引进了中间位置的”第三方”，也就是IoC容器，对象和对象之间没有了耦合关系， 它起到了一种类似”粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个”粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IoC容器比喻成”粘合剂”的由来。</p>
</blockquote>
<h3 id="6-紧耦合和松耦合有什么区别？"><a href="#6-紧耦合和松耦合有什么区别？" class="headerlink" title="6.紧耦合和松耦合有什么区别？"></a>6.紧耦合和松耦合有什么区别？</h3><blockquote>
<p>紧耦合：紧密耦合是指类之间高度依赖。</p>
<p>松耦合：松耦合是通过促进单一职责和关注点分离、依赖倒置的设计原则来实现的。</p>
</blockquote>
<h3 id="7-BeanFactory的作用"><a href="#7-BeanFactory的作用" class="headerlink" title="7.BeanFactory的作用"></a>7.BeanFactory的作用</h3><blockquote>
<ul>
<li>BeanFactory是Spring中<strong>非常核心的一个顶层接口</strong>；</li>
<li>它是Bean的”工厂”、它的<strong>主要职责就是生产Bean</strong>；</li>
<li>它实现了<strong>简单工厂的设计模式</strong>，通过调用getBean传入标识生产一个Bean；</li>
<li>它有非常多的实现类、每个工厂都有不同的职责（单一职责）功能，最强大的工厂是：DefaultListableBeanFactory Spring底层就是使用的该实现工厂进行生产Bean的</li>
<li>BeanFactory它也是容器 Spring容器（管理着Bean的生命周期）</li>
</ul>
<img src="/2024/02/28/quiz-spring-cloud/image-20240229130120100.png" srcset="/img/loading.gif" lazyload class="" title="image-20240229130120100">
</blockquote>
<h3 id="8-BeanDefinition的作用"><a href="#8-BeanDefinition的作用" class="headerlink" title="8. BeanDefinition的作用"></a>8. BeanDefinition的作用</h3><blockquote>
<p>它主要负责存储Bean的<strong>定义信息</strong>:决定Bean的生产方式。如：spring.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.tuling.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span> <span class="hljs-attr">lazy</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">abstract</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;none&quot;</span> <span class="hljs-attr">....</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;xushu&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>后续BeanFactory根据这些信息就行生产Bean： 比如实例化 可以通过class进行反射进而得到实例对象 ， 比如lazy 则不会在IoC加载时创建Bean</p>
</blockquote>
<h3 id="9-BeanFactory-和-ApplicationContext有什么区别？"><a href="#9-BeanFactory-和-ApplicationContext有什么区别？" class="headerlink" title="9. BeanFactory 和 ApplicationContext有什么区别？"></a>9. <strong>BeanFactory 和 ApplicationContext有什么区别？</strong></h3><blockquote>
<p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是 BeanFactory的子接口。</p>
<p>依赖关系 </p>
<p>BeanFactory：是Spring里面最顶层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。BeanFactory 简单粗暴，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 **”低级容器”**。</p>
<p>ApplicationContext 可以称之为 **”高级容器”**。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载&#x2F;刷新所有的 bean。 </p>
<p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能。</p>
<p>官方文档截图：</p>
<img src="/2024/02/28/quiz-spring-cloud/image-20240229131015957.png" srcset="/img/loading.gif" lazyload class="" title="image-20240229131015957">
</blockquote>
<h3 id="10-BeanFactory-和FactoryBean有什么区别？"><a href="#10-BeanFactory-和FactoryBean有什么区别？" class="headerlink" title="10. BeanFactory 和FactoryBean有什么区别？"></a>10. BeanFactory 和FactoryBean有什么区别？</h3><blockquote>
<p>BeanFactory是一个工厂，也就是一个容器，是来管理和生产bean的；</p>
<p>FactoryBean是一个bean，但是它是一个特殊的bean，所以也是由BeanFactory来管理的，它是一个接口，他必须被一个bean去实现。</p>
<p>不过FactoryBean不是一个普通的Bean，它会表现出工厂模式的样子，是一个能产生或者修饰对象生成的工厂Bean，里面的getObject()就是用来获取FactoryBean产生的对象。所以在BeanFactory中使用”&amp;”来得到FactoryBean本身，用来区分通过容器获取FactoryBean产生的对象还是获取FactoryBean本身。</p>
</blockquote>
<h3 id="11-IoC容器的加载过程："><a href="#11-IoC容器的加载过程：" class="headerlink" title="11. IoC容器的加载过程："></a>11. IoC容器的加载过程：</h3><blockquote>
<p><strong>从概念态---&gt;定义态的过程</strong> </p>
<ol>
<li>实例化一个ApplicationContext的对象； </li>
<li>调用bean工厂后置处理器完成扫描；</li>
<li>循环解析扫描出来的类信息； </li>
<li>实例化一个BeanDefinition对象来存储解析出来的信息； </li>
<li>把实例化好的beanDefinition对象put到beanDefinitionMap当中缓存起来，以便后面实例化bean；</li>
<li>再次调用其他bean工厂后置处理器；</li>
</ol>
<p><strong>从定义态到纯净态</strong></p>
<ol start="7">
<li>当然Spring还会干很多事情，比如国际化，比如注册BeanPostProcessor等等，如果我们只关心如何实例化一个bean的话那么这一步就是spring调用finishBeanFactoryInitialization方法来实例化单例的bean，实例化之前Spring要做验证，需要遍历所有扫描出来的类，依次判断这个bean是否Lazy，是否prototype，是否 abstract等等； </li>
<li>如果验证完成Spring在实例化一个bean之前需要推断构造方法，因为Spring实例化对象是通过构造方法反射，故而需要知道用哪个构造方法； </li>
<li>推断完构造方法之后Spring调用构造方法反射<strong>实例化</strong>一个对象；注意我这里说的是对象、对象、对象；这个时候对象已经实例化出来了，但是并不是一个完整的bean，最简单的体现是这个时候实例化出来的对象属性是没有注入，所以不是一个完整的bean；</li>
</ol>
<p><strong>从纯净态到成熟态</strong></p>
<ol start="10">
<li>Spring处理合并后的beanDefinition </li>
<li>判断是否需要完成<strong>属性注入</strong></li>
<li>如果需要完成属性注入，则开始注入属性</li>
</ol>
<p><strong>初始化</strong></p>
<ol start="13">
<li>判断bean的类型回调Aware接口</li>
<li>调用生命周期回调方法</li>
<li>如果需要代理则完成代理</li>
</ol>
<p><strong>创建完成</strong></p>
<ol start="16">
<li>put到单例池——bean完成——存在Spring容器当中</li>
</ol>
<img src="/2024/02/28/quiz-spring-cloud/image-20240229131617951.png" srcset="/img/loading.gif" lazyload class="" title="image-20240229131617951">
</blockquote>
<img src="/2024/02/28/quiz-spring-cloud/image-20240229131600091.png" srcset="/img/loading.gif" lazyload class="" title="image-20240229131600091">

<h3 id="12-你知道Spring的哪些扩展点？在什么时候调用？"><a href="#12-你知道Spring的哪些扩展点？在什么时候调用？" class="headerlink" title="12.你知道Spring的哪些扩展点？在什么时候调用？"></a>12.你知道Spring的哪些扩展点？在什么时候调用？</h3><blockquote>
<p>Spring中非常非常多的扩展接口，当然你也不需要全部回答，可以挑重点回答：</p>
</blockquote>
<ol>
<li><p>执行BeanFactoryPostProcessor的postProcessBeanFactory方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 作用： 在注册BeanDefinition的可以对beanFactory进行扩展 后</span><br><span class="hljs-comment"> * 调用时机： Ioc加载时注册BeanDefinition 的时候会调用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>


</li>
<li><p>执行BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 作用：动态注册BeanDefinition</span><br><span class="hljs-comment"> * 调用时机： Ioc加载时注册BeanDefinition 的时候会调用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanDefinitionRegistryPostProcessor</span> &#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>		<span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(Car.class);<br>		registry.registerBeanDefinition(<span class="hljs-string">&quot;car&quot;</span>,beanDefinition);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
<li><p>加载BeanPostProcessor实现类 : <strong>在Bean的生命周期会调用9次Bean的后置处理器</strong></p>
</li>
<li><p>创建所有单例bean</p>
<img src="/2024/02/28/quiz-spring-cloud/image-20240301175939535.png" srcset="/img/loading.gif" lazyload class="" title="image-20240301175939535"></li>
</ol>
<p><strong>初始化阶段:</strong></p>
<ol start="5">
<li>初始化阶段调用XXXAware接口的SetXXXAware方法 ：</li>
</ol>
<h5 id="生命周期回调：-初始化、销毁"><a href="#生命周期回调：-初始化、销毁" class="headerlink" title="生命周期回调： 初始化、销毁"></a>生命周期回调： 初始化、销毁</h5><ol start="6">
<li>执行BeanPostProcessor实现类的postProcessBeforeInitialization方法</li>
<li>执行InitializingBean实现类的afterPropertiesSet方法</li>
<li>执行bean的init-method属性指定的初始化方法</li>
<li>执行BeanPostProcessor实现类的postProcessAfterInitialization方法</li>
<li>初始化完成</li>
<li>关闭容器，执行DiposibleBean实现类的destory</li>
<li>执行bean的destroy-method属性指定的初始化方法</li>
</ol>
<h2 id="三、Spring-Beans"><a href="#三、Spring-Beans" class="headerlink" title="三、Spring Beans"></a>三、Spring Beans</h2><h3 id="13-什么是Spring-beans"><a href="#13-什么是Spring-beans" class="headerlink" title="13. 什么是Spring beans?"></a>13. 什么是Spring beans?</h3><blockquote>
<p>Spring 官方文档对 bean 的解释是：</p>
<p>In Spring， the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated， assembled， and otherwise managed by a Spring IoC container.</p>
<p>翻译过来就是：</p>
<p>在 Spring 中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。bean是一个由Spring IoC容器实例化、组装和管理的对象。</p>
<p>概念简单明了，我们提取处关键的信息：</p>
<ol>
<li><p>bean是对象，一个或者多个不限定</p>
</li>
<li><p>bean由Spring中一个叫IoC的东西管理</p>
</li>
</ol>
</blockquote>
<h3 id="14-配置Bean有哪几种方式？"><a href="#14-配置Bean有哪几种方式？" class="headerlink" title="14. 配置Bean有哪几种方式？"></a>14. 配置Bean有哪几种方式？</h3><ol>
<li><p>xml: &lt;bean class&#x3D;&quot;com.tuling.UserService&quot; id&#x3D;&quot;&quot;&gt;</p>
</li>
<li><p>注解：@Component(@Controller 、@Service、@Repostory) 前提：需要配置扫描包&lt;component-scan&gt; 反射调用构造方法 </p>
</li>
<li><p>javaConfig: @Bean 可以自己控制实例化过程</p>
</li>
<li><p>@import 3种方式</p>
</li>
</ol>
<h3 id="15-解释Spring支持的几种bean的作用域"><a href="#15-解释Spring支持的几种bean的作用域" class="headerlink" title="15. 解释Spring支持的几种bean的作用域"></a>15. 解释Spring支持的几种bean的作用域</h3><blockquote>
<p>Spring框架支持以下五种bean的作用域：</p>
<ul>
<li><strong>singleton :</strong> bean在每个Spring IoC 容器中只有一个实例。</li>
<li><strong>prototype</strong>：一个bean的定义可以有多个实例。 </li>
<li><strong>request</strong>：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。 </li>
<li><strong>session</strong>：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
<li><strong>application</strong>：全局 Web 应用程序范围的范围标识符。</li>
</ul>
<p><strong>注意：</strong> 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean会带来很大的性能开销。</p>
</blockquote>
<h3 id="16-单例bean的优势"><a href="#16-单例bean的优势" class="headerlink" title="16. 单例bean的优势"></a>16. 单例bean的优势</h3><blockquote>
<p>由于不会每次都新创建新对象所以有一下几个性能上的优势： </p>
<p>1.减少了新生成实例的消耗新生成实例消耗包括两方面，第一，spring会通过反射或者cglib来生成bean实例这都是耗性能的操作，其次给对象分配内存也会涉及复杂算法。 提供服务器内存的利用率 ，减少服务器内存消耗。</p>
<p>2.减少jvm垃圾回收由于不会给每个请求都新生成bean实例，所以自然回收的对象少了。</p>
<p>3.可以快速获取到bean因为单例的获取bean操作除了第一次生成之外其余的都是从缓存里获取的所以很快。</p>
</blockquote>
<h3 id="17-Spring实例化bean方式的几种方式"><a href="#17-Spring实例化bean方式的几种方式" class="headerlink" title="17.Spring实例化bean方式的几种方式"></a>17.Spring实例化bean方式的几种方式</h3><blockquote>
<ol>
<li><p>构造器方式（反射）；</p>
</li>
<li><p>静态工厂方式； factory-method</p>
</li>
<li><p>实例工厂方式(@Bean)； factory-bean+factory-method</p>
</li>
<li><p>FactoryBean方式</p>
</li>
</ol>
</blockquote>
<h3 id="18-Spring框架中的单例bean是线程安全的吗？（阿里一面）"><a href="#18-Spring框架中的单例bean是线程安全的吗？（阿里一面）" class="headerlink" title="18.Spring框架中的单例bean是线程安全的吗？（阿里一面）"></a>18.Spring框架中的单例bean是线程安全的吗？（阿里一面）</h3><blockquote>
<p>不是，Spring框架中的单例bean不是线程安全的。</p>
<p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p>
<p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所以某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把”singleton”变更为”prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p>
<ul>
<li>有状态就是有数据存储功能（比如成员变量读写）。</li>
<li>无状态就是不会保存数据。</li>
</ul>
</blockquote>
<h3 id="19-Spring如何处理线程并发问题？"><a href="#19-Spring如何处理线程并发问题？" class="headerlink" title="19.Spring如何处理线程并发问题？"></a>19.Spring如何处理线程并发问题？</h3><blockquote>
<p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。 ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了”时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了”空间换时间”的方式。</p>
<p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> 徐庶 QQ:1092002729</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Slogan</span> 致敬大师，致敬未来的你</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 单例Bean的情况 如果在类中声明成员变量 并且有读写操作（有状态），就是线程不安全 </span><br><span class="hljs-comment"> 解决： </span><br><span class="hljs-comment"> 1.设置为多例 </span><br><span class="hljs-comment"> 2.将成员变量放在ThreadLocal </span><br><span class="hljs-comment"> 3.同步锁 会影响服务器吞吐量 但是! 只需要把成员变量声明在方法中（无状态），</span><br><span class="hljs-comment"> * 单例Bean是线程安全的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Run</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(<br>            MainConfig.class);<br><br>        <span class="hljs-comment">// 线程一</span><br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> applicationContext.getBean(UserService.class);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() ‐&gt; &#123;<br>            System.out.println(bean.welcome(<span class="hljs-string">&quot;张三&quot;</span>));<br> &#125;).start();<br><br>        <span class="hljs-comment">// 线程二</span><br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">bean2</span> <span class="hljs-operator">=</span> applicationContext.getBean(UserService.class);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() ‐&gt; &#123;<br>            System.out.println(bean2.welcome(<span class="hljs-string">&quot;李四&quot;</span>));<br> &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="20-什么是bean装配？"><a href="#20-什么是bean装配？" class="headerlink" title="20. 什么是bean装配？"></a>20. 什么是bean装配？</h3><blockquote>
<p>装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</p>
</blockquote>
<h3 id="21-什么是bean的自动装配？"><a href="#21-什么是bean的自动装配？" class="headerlink" title="21.什么是bean的自动装配？"></a>21.什么是bean的自动装配？</h3><blockquote>
<p>在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean工厂自动处理bean之间的协作。这意味着 Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。</p>
</blockquote>
<h3 id="22-自动装配有哪些限制（需要注意）？"><a href="#22-自动装配有哪些限制（需要注意）？" class="headerlink" title="22. 自动装配有哪些限制（需要注意）？"></a>22. 自动装配有哪些限制（需要注意）？</h3><blockquote>
<ul>
<li>一定要声明set方法</li>
<li>覆盖： 你仍可以用 &lt;constructor-arg &gt;和 &lt; property &gt; 配置来定义依赖，这些配置将始终覆盖自动注入。</li>
<li>基本数据类型：不能自动装配简单的属性，如基本数据类型、字符串和类。 (手动注入还是可以注入基本数据类型的 &lt;property value&#x3D;&quot;&quot; @Value)</li>
<li>模糊特性：自动装配不如显式装配精确，如果有可能尽量使用显示装配。</li>
</ul>
<p>所以更推荐使用手动装配(@Autowired（根据类型、再根据名字） ref&#x3D;&quot;&quot; 这种方式 更加灵活更加清晰 )</p>
</blockquote>
<h3 id="23-Spring-自动装配-bean-有哪些方式？"><a href="#23-Spring-自动装配-bean-有哪些方式？" class="headerlink" title="23. Spring 自动装配 bean 有哪些方式？"></a>23. Spring 自动装配 bean 有哪些方式？</h3><blockquote>
<p>在Spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</p>
<p>在Spring框架xml配置中共有5种自动装配：</p>
<ul>
<li>no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。@Autowired 来进行手动指定需要自动注入的属性</li>
<li>byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。</li>
<li>byType：通过参数的数据类型进行自动装配。 </li>
<li>constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。 </li>
<li>autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。 （在Spring3.0+弃用）</li>
</ul>
</blockquote>
<h3 id="24-有哪些生命周期回调方法？有哪几种实现方式？"><a href="#24-有哪些生命周期回调方法？有哪几种实现方式？" class="headerlink" title="24.有哪些生命周期回调方法？有哪几种实现方式？"></a>24.有哪些生命周期回调方法？有哪几种实现方式？</h3><blockquote>
<p>有两个重要的bean 生命周期方法，第一个是init ， 它是在容器加载bean的时候被调用。第二个方法是 destroy 它是在容器卸载类的时候被调用。</p>
<p>bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</p>
</blockquote>
<h3 id="20-Spring-在加载过程中Bean有哪几种形态："><a href="#20-Spring-在加载过程中Bean有哪几种形态：" class="headerlink" title="20.Spring 在加载过程中Bean有哪几种形态："></a>20.Spring 在加载过程中Bean有哪几种形态：</h3><blockquote>
<img src="/2024/02/28/quiz-spring-cloud/image-20240301183401545.png" srcset="/img/loading.gif" lazyload class="" title="image-20240301183401545">
</blockquote>
<h3 id="25-解释Spring框架中bean的生命周期"><a href="#25-解释Spring框架中bean的生命周期" class="headerlink" title="25. 解释Spring框架中bean的生命周期"></a>25. 解释Spring框架中bean的生命周期</h3><blockquote>
<p>Bean生命周期：指定的就是Bean从创建到销毁的整个过程: 分4步：</p>
<ol>
<li><p>实例化</p>
<p>a.  通过反射去推断构造函数进行实例化</p>
<p>b.  实例工厂、 静态工厂</p>
</li>
<li><p>属性赋值</p>
<p>a.  解析自动装配（byname bytype constractor none @Autowired） DI的体现</p>
<p>b.  循环依赖</p>
</li>
<li><p>初始化</p>
<p>a.  调用XXXAware回调方法</p>
<p>b.  调用初始化生命周期回调（三种）</p>
<p>c.  如果bean实现aop 创建动态代理</p>
</li>
<li><p>销毁</p>
<p>a.  在spring容器关闭的时候进行调用</p>
<p>b.  调用销毁生命周期回调</p>
</li>
</ol>
<p>下图展示了bean装载到Spring应用上下文中的一个典型的生命周期过程。</p>
<img src="/2024/02/28/quiz-spring-cloud/image-20240301183449831.png" srcset="/img/loading.gif" lazyload class="" title="image-20240301183449831">

<p>bean在Spring容器中从创建到销毁经历了若干阶段，每一阶段都可以针对Spring如何管理bean进行个性化定制。正如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。</p>
<p>我们对上图进行详细描述： Spring对bean进行实例化； Spring将值和bean的引用注入到bean对应的属性中；</p>
<p>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</p>
<p>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</p>
<p>如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</p>
<p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</p>
<p>如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用 initmethod声明了初始化方法，该方法也会被调用；</p>
<p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</p>
<p>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</p>
<p>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</p>
<p>现在你已经了解了如何创建和加载一个Spring容器。但是一个空的容器并没有太大的价值，在你把东西放进去之前，它里面什么都没有。为了从Spring的DI(依赖注入)中受益，我们必须将应用对象装配进Spring容器中。</p>
</blockquote>
<h3 id="26-Spring是如何解决Bean的循环依赖？"><a href="#26-Spring是如何解决Bean的循环依赖？" class="headerlink" title="26. Spring是如何解决Bean的循环依赖？"></a>26. Spring是如何解决Bean的循环依赖？</h3><blockquote>
<p>Spring是如何解决的循环依赖： 采用三级缓存解决的 就是三个Map ； 关键： 一定要有一个缓存保存它的早期对象作为死循环的出口</p>
<ol>
<li><p>一级缓存：存储完整的Bean</p>
</li>
<li><p>二级缓存： 避免多重循环依赖的情况 重复创建动态代理。</p>
</li>
<li><p>三级缓存：</p>
<p>a.  缓存是函数接口：通过lambda 把方法传进去（ 把Bean的实例和Bean名字传进去（aop创建） ）</p>
<p>b.  不会立即调：（如果在实例化后立即调用的话：所有的aop 不管bean是否循环依赖都会在 实例化后创建 proxy， 正常Bean 其实spring还是希望遵循生命周期在初始化创建动态代理， 只能循环依赖才创建)</p>
<p>c.  会在 ABA (第二次getBean(A) 才会去调用三级缓存（如果实现了aop才会创建动态代理，如果没有实现依然返回的Bean的实例））</p>
<p>d.  放入二级缓存（避免重复创建）</p>
</li>
</ol>
<img src="/2024/02/28/quiz-spring-cloud/image-20240301183922079.png" srcset="/img/loading.gif" lazyload class="" title="image-20240301183922079">

<p>夺命连环问：</p>
<ol>
<li><p>二级缓存能不能解决循环依赖？</p>
<p>a.  如果只是死循环的问题： 一级缓存就可以解决 ：无法避免在并发下获取不完整的Bean?</p>
<p>b.  二级缓存也可以解决循环依赖： 只不过如果出现重复循环依赖 会多次创建aop的动态代理</p>
</li>
<li><p>Spring有没有解决多例Bean的循环依赖？</p>
<p>a.  多例不会使用缓存进行存储（多例Bean每次使用都需要重新创建）</p>
<p>b.  不缓存早期对象就无法解决循环</p>
</li>
<li><p>Spring有没有解决构造函数参数Bean的循环依赖？</p>
<ol>
<li>构造函数的循环依赖也是会报错</li>
<li>可以通过人工进行解决：@Lazy<ol>
<li>就不会立即创建依赖的bean了</li>
<li>而是等到用到才通过动态代理进行创建</li>
</ol>
</li>
</ol>
</li>
</ol>
</blockquote>
<h3 id="27-Spring如何避免在并发下获取不完整的Bean"><a href="#27-Spring如何避免在并发下获取不完整的Bean" class="headerlink" title="27.Spring如何避免在并发下获取不完整的Bean?"></a>27.Spring如何避免在并发下获取不完整的Bean?</h3><blockquote>
<p>双重检查锁</p>
<ul>
<li>为什么一级缓存不加到锁里面：<ul>
<li>性能：避免已经创建好的Bean阻塞等待</li>
</ul>
</li>
</ul>
<img src="/2024/02/28/quiz-spring-cloud/image-20240301184207118.png" srcset="/img/loading.gif" lazyload class="" title="image-20240301184207118">
</blockquote>
<h3 id="28-BeanDefinition的加载过程"><a href="#28-BeanDefinition的加载过程" class="headerlink" title="28. BeanDefinition的加载过程"></a>28. BeanDefinition的加载过程</h3><blockquote>
<p>BeanDefinition的加载过程就是将 概念态的Bean注册为定义态的Bean不同的Spring上下文会有不同的注册过程，但是会用共同的api步骤：</p>
<ol>
<li><p>通过BeanDefinitionReader 将配置类(AnnotatedBeanDefinitionReader)（xml文件:XmlBeanDefinitionReader) 注册为BeanDefinition</p>
</li>
<li><p>解析配置类ConfigurationClassParser(xml文件:BeanDefinitionDocumentReader）</p>
</li>
<li><p>不同的注解（xml节点）有不同的解析器</p>
<ol>
<li>比如ComponentScan 需要通过ClassPathBeanDefinitionScanner扫描所有类找到类上面有 @Import的类</li>
</ol>
</li>
<li><p>将读取到的Bean定义信息通过BeanDefinitionRegistry注册为一个BeanDefinition</p>
</li>
</ol>
</blockquote>
<h3 id="29-如何在Spring所有BeanDefinition注册完后做扩展？"><a href="#29-如何在Spring所有BeanDefinition注册完后做扩展？" class="headerlink" title="29. 如何在Spring所有BeanDefinition注册完后做扩展？"></a>29. 如何在Spring所有BeanDefinition注册完后做扩展？</h3><blockquote>
<p>通常可以使用beanFactoryPostProcessor 对已注册的BeanDefinition进行修改、或者通过它的子接口BeanDefinitionRegistryPostProcessor 再进行注册</p>
</blockquote>
<h3 id="30-如何在Spring所有Bean创建完后做扩展？"><a href="#30-如何在Spring所有Bean创建完后做扩展？" class="headerlink" title="30. 如何在Spring所有Bean创建完后做扩展？"></a>30. 如何在Spring所有Bean创建完后做扩展？</h3><blockquote>
<p>哪里才算所有的Bean创建完： new ApplicationContext()----&gt;refresh() &gt;finishBeanFactoryInitialization（循环所有的BeanDefinition，通过BeanFactory.getBean()生成所有的Bean）这个循环结束之后所有的bean也就创建完了。</p>
</blockquote>
<h3 id="31、Spring容器启动时，为什么先加载BeanFactoryPostProcess"><a href="#31、Spring容器启动时，为什么先加载BeanFactoryPostProcess" class="headerlink" title="31、Spring容器启动时，为什么先加载BeanFactoryPostProcess"></a>31、Spring容器启动时，为什么先加载BeanFactoryPostProcess</h3><blockquote>
<ol>
<li>因为BeanDefinition会在IoC容器加载的先注册， 而BeanFactoryPostProcess就是在所有的BeanDefinition注册完后做扩展的，所以要先加载BeanFactoryPostProcess</li>
<li>解析配置类的组件 它就实现BeanFactoryPostProcess， 所以要先去加载BeanFactoryPostProcess</li>
</ol>
<p>方式一 基于SmartInitializingSingleton接口</p>
<p>Source</p>
<p>在创建所有单例Bean的方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">finishBeanFactoryInitialization(beanFactory);<br></code></pre></td></tr></table></figure>

<p>SmartInitializingSingleton接口是在所有的Bean实例化完成以后，Spring回调的方法，所以这里也是一个扩展点，可以在单例bean全部完成实例化以后做处理。</p>
<img src="/2024/02/28/quiz-spring-cloud/image-20240301185918755.png" srcset="/img/loading.gif" lazyload class="" title="image-20240301185918755">

<p>在创建所有单例Bean的方法中：</p>
<p>Code</p>
<p>【配置类】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.artisan.beanLoadedExtend.smartinit;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.artisan.beanLoadedExtend&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartInitConfig</span> &#123;<br></code></pre></td></tr></table></figure>

<p>【扩展类 implements SmartInitializingSingleton 】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.SmartInitializingSingleton;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartInitExtend</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SmartInitializingSingleton</span> &#123;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterSingletonsInstantiated</span><span class="hljs-params">()</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;all singleton beans loaded , 自定义扩展here &quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>【测试】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(SmartInitConfig.class);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>方式二 基于Spring事件监听</p>
<p>Source</p>
<p>生命周期的最后一步是finishRefresh();，这里面中有一个方法是publishEvent</p>
<img src="/2024/02/28/quiz-spring-cloud/image-20240301190552143.png" srcset="/img/loading.gif" lazyload class="" title="image-20240301190552143">

<p>所以这里也可以进行扩展，监听ContextRefreshedEvent事件 。</p>
</blockquote>
<h3 id="32-Bean的创建顺序是什么样的？"><a href="#32-Bean的创建顺序是什么样的？" class="headerlink" title="32. Bean的创建顺序是什么样的？"></a>32. Bean的创建顺序是什么样的？</h3><blockquote>
<p>Bean的创建顺序是由BeanDefinition的注册顺序来决定的， 当然依赖关系也会影响Bean创建顺序 （A-B)。</p>
<p>BeanDefinition的注册顺序由什么来决定的？</p>
<p>主要是由注解（配置）的解析顺序来决定：</p>
<img src="/2024/02/28/quiz-spring-cloud/image-20240301185332104.png" srcset="/img/loading.gif" lazyload class="" title="image-20240301185332104">

<ol>
<li><p>@Configuration</p>
</li>
<li><p>@Component</p>
</li>
<li><p>@Import—类</p>
</li>
<li><p>@Bean</p>
</li>
<li><p>@Import—ImportBeanDefinitionRegistrar</p>
<img src="/2024/02/28/quiz-spring-cloud/image-20240301185415533.png" srcset="/img/loading.gif" lazyload class="" title="image-20240301185415533">
</li>
<li><p>BeanDefinitionRegistryPostProcessor</p>
</li>
</ol>
</blockquote>
<h2 id="四、Spring注解"><a href="#四、Spring注解" class="headerlink" title="四、Spring注解"></a>四、Spring注解</h2><h3 id="33-Spring有哪几种配置方式："><a href="#33-Spring有哪几种配置方式：" class="headerlink" title="33. Spring有哪几种配置方式："></a>33. Spring有哪几种配置方式：</h3><blockquote>
<p>这里有三种重要的方法给Spring 容器提供配置元数据。</p>
<ol>
<li><p>XML配置文件。 Spring诞生</p>
<p>a.  spring.xml &lt;bean&gt;</p>
</li>
<li><p>基于注解的配置。 Spring2.5+</p>
<p>a.  spring.xml &lt;component-scan base-package&#x3D;&quot; &quot;&#x2F;&gt; @Component @Autowired</p>
</li>
<li><p>基于Java的配置。 JavaConfig Spring3.0+</p>
<p>a.  @Configuration @Bean .…</p>
</li>
</ol>
</blockquote>
<h3 id="34-用过JavaConfig方式的Spring配置吗？它是如何替代xml的？"><a href="#34-用过JavaConfig方式的Spring配置吗？它是如何替代xml的？" class="headerlink" title="34.用过JavaConfig方式的Spring配置吗？它是如何替代xml的？"></a>34.用过JavaConfig方式的Spring配置吗？它是如何替代xml的？</h3><blockquote>
<p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IoC容器使用。</p>
<p>另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentConfig</span>&#123;<br>	<span class="hljs-meta">@Bean</span><br>	<span class="hljs-keyword">public</span> StudentBean <span class="hljs-title function_">myStudent</span><span class="hljs-params">()</span>&#123;<br>		returnnewStudentBean();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>应用：</p>
<ol>
<li><p>以前Xml</p>
<p>a.  Spring容器 ClassPathXmlApplicationContext(&quot;xml&quot;)</p>
<p>b.  Spring.xml</p>
<p>c.  &lt;bean scope lazy&gt;</p>
<p>d.  扫描包: &lt;component-scan&gt;</p>
<p>e.  引入外部属性配置文件 &lt;property-placeHodeler resource&#x3D;&quot;xxx.properties&quot;&gt;</p>
<p>f.  &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;${mysql.password}&quot;&gt;&lt;&#x2F;property&gt;</p>
<p>g.  指定其他配置文件：&lt;import resource&#x3D;&quot;&quot;</p>
</li>
<li><p>javaconfig</p>
<p>a.  Spring容器：AnnotationConfigApplicationContext(javaconfig.class)</p>
<p>b.  配置类 @Configuration</p>
<p>c.  @Bean @Scope @Lazy</p>
<p>d.  扫描包: @ComponentScan</p>
<p>e.  引入外部属性配置文件 @PropertySource(&quot;classpath:db.properties&quot;)</p>
<p>f.  @Value(&quot;${mysql.password}&quot;)</p>
<p>g.  @Import @Import({配置类}) 使用比较灵活</p>
</li>
</ol>
<p>源码：</p>
<img src="/2024/02/28/quiz-spring-cloud/image-20240301191211454.png" srcset="/img/loading.gif" lazyload class="" title="image-20240301191211454">
</blockquote>
<h3 id="35-Component，-Controller，-Repository，-Service-有何区别？"><a href="#35-Component，-Controller，-Repository，-Service-有何区别？" class="headerlink" title="35. @Component， @Controller， @Repository， @Service 有何区别？"></a>35. @Component， @Controller， @Repository， @Service 有何区别？</h3><blockquote>
<p>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</p>
<p>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。 @Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。 @Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p>
</blockquote>
<h5 id="36-Import可以有几种用法？"><a href="#36-Import可以有几种用法？" class="headerlink" title="36.@Import可以有几种用法？"></a>36.@Import可以有几种用法？</h5><blockquote>
<p>4种：</p>
</blockquote>
<ol>
<li><p>直接指定类 （如果配置类会按配置类正常解析、 如果是个普通类就会解析成Bean)</p>
</li>
<li><p>通过<strong>ImportSelector</strong> 可以一次性注册多个，返回一个string[] 每一个值就是类的完整类路径</p>
<p>a.  通过<strong>DeferredImportSelector</strong>可以一次性注册多个，返回一个string[] 每一个值就是类的完整类路径</p>
<pre><code class="hljs">i.  区别：**DeferredImportSelector 顺序靠后**
</code></pre>
</li>
<li><p>通过ImportBeanDefinitionRegistrar 可以一次性注册多个，通过BeanDefinitionRegistry来动态注册BeanDefintion</p>
</li>
</ol>
<h4 id="37-如何让自动注入没有找到依赖Bean时不报错"><a href="#37-如何让自动注入没有找到依赖Bean时不报错" class="headerlink" title="37.如何让自动注入没有找到依赖Bean时不报错"></a>37.如何让自动注入没有找到依赖Bean时不报错</h4><blockquote>
<p>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。示例：</p>
</blockquote>
<p>+—————————-+——————————————————–+<br>| &gt; 1 @Autowired(required &#x3D; | &gt; false)                                               |<br>+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+<br>| &gt; 2 private Role role;     |                                                        |<br>+—————————-+——————————————————–+</p>
<blockquote>
<p><strong>38.如何让自动注入找到多个依赖Bean时不报错</strong></p>
<p><img src="/media/image36.png" srcset="/img/loading.gif" lazyload>{width&#x3D;”4.272185039370079in” height&#x3D;”1.3781244531933508in”}</p>
</blockquote>
<h2 id="39-Autowired-注解有什么作用"><a href="#39-Autowired-注解有什么作用" class="headerlink" title="39.@Autowired 注解有什么作用"></a>39.@Autowired 注解有什么作用</h2><blockquote>
<p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。 @Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。</p>
<p><strong>40.@Autowired和@Resource之间的区别</strong> @Autowired可用于：构造函数、成员变量、Setter方法 @Autowired和@Resource之间的区别</p>
<p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为 false）。</p>
<p>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</p>
</blockquote>
<h5 id="41-使用-Autowired注解自动装配的过程是怎样的？"><a href="#41-使用-Autowired注解自动装配的过程是怎样的？" class="headerlink" title="41.使用@Autowired注解自动装配的过程是怎样的？"></a>41.使用@Autowired注解自动装配的过程是怎样的？</h5><blockquote>
<p>记住：@Autowired 通过Bean的后置处理器进行解析的</p>
</blockquote>
<ol>
<li><p>在创建一个Spring上下文的时候再构造函数中进行注册AutowiredAnnotationBeanPostProcessor</p>
</li>
<li><p>在Bean的创建过程中进行解析</p>
<ol>
<li><p>在实例化后预解析（解析@Autowired标注的属性、方法 比如：把属性的类型、名称、属性所在的类. 元数据缓存起）</p>
</li>
<li><p>在属性注入真正的解析（拿到上一步缓存的元数据 去IoC容器帮进行查找，并且返回注入）</p>
<p>a.  首先根据预解析的元数据拿到 类型去容器中进行查找</p>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；如果查询的结果不止一个，那么@Autowired会根据名称来查找；</p>
<p><img src="/media/image37.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”3.982542650918635in” height&#x3D;”3.301353893263342in”}如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required&#x3D;false。</p>
</blockquote>
<h5 id="42-配置类-Configuration的作用解析原理"><a href="#42-配置类-Configuration的作用解析原理" class="headerlink" title="42.配置类@Configuration的作用解析原理:"></a>42.配置类@Configuration的作用解析原理:</h5><ol>
<li><p><a href="mailto:1.@Configuration用来代替xml配置方式spring.xml配置文件">@Configuration用来代替xml配置方式spring.xml配置文件</a> &lt;bean&gt;</p>
</li>
<li><p>没有@Configuration也是可以配置@Bean</p>
</li>
<li><p>@Configuration加与不加有什么区别</p>
</li>
<li><p>加了@Configuration会为配置类创建cglib动态代理（保证配置类@Bean方法调用Bean的单例），@Bean方法的调用就会通过容器.getBean进行获取</p>
</li>
</ol>
<blockquote>
<p>原理：</p>
</blockquote>
<ol>
<li>创建Spring上下文的时候会注册一个解析配置的处理器<strong>ConfigurationClassPostProcessor</strong>（实现BeanFactoryPostProcessor和 BeanDefinitionRegistryPostProcessor)</li>
</ol>
<blockquote>
<p>2.在调用invokeBeanFactoryPostProcessor，就会去调用 <strong>ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry</strong>进行解析配置（解析配置类说白就是去解析各种注解 (@Bean @Configuration@Import @Component ... 就是注册BeanDefinition)</p>
<p>3. <strong>ConfigurationClassPostProcessor.postProcessBeanFactory</strong>去创建cglib动态代理</p>
</blockquote>
<h5 id="43-Bean之间的方法调用是怎么保证单例的？"><a href="#43-Bean之间的方法调用是怎么保证单例的？" class="headerlink" title="43.@Bean之间的方法调用是怎么保证单例的？"></a>43.@Bean之间的方法调用是怎么保证单例的？</h5><blockquote>
<p>（ <strong>@Configuration加与不加的区别是什么？）</strong></p>
</blockquote>
<ol>
<li><p>如果希望@bean的方法返回是对象是单例 需要在类上面加上@Configuration，</p>
</li>
<li><p>Spring 会在invokeBeanFactoryPostProcessor 通过内置BeanFactoryPostProcessor中会CGLib生成动态代理代理 3.当@Bean方法进行互调时， 则会通过CGLIB进行增强，通过调用的方法名作为bean的名称去IoC容器中获取，进而保证了@Bean方法的单例</p>
</li>
</ol>
<h5 id="44-要将一个第三方的类配成为Bean有哪些方式？"><a href="#44-要将一个第三方的类配成为Bean有哪些方式？" class="headerlink" title="44.要将一个第三方的类配成为Bean有哪些方式？"></a>44.要将一个第三方的类配成为Bean有哪些方式？</h5><ol>
<li><p><span class="underline">@Bean</span></p>
</li>
<li><p>@Import 3.通过Spring的扩展接口：BeanDefinitionRegistryPostProcessor</p>
</li>
</ol>
<h5 id="45、为什么-ComponentScan-不设置basePackage也会扫描？"><a href="#45、为什么-ComponentScan-不设置basePackage也会扫描？" class="headerlink" title="45、为什么@ComponentScan 不设置basePackage也会扫描？"></a>45、为什么@ComponentScan 不设置basePackage也会扫描？</h5><blockquote>
<p>因为Spring在解析@ComponentScan的时候 拿到basePackage 如果没有设置会将你的类所在的包的地址作为扫描包的地址</p>
</blockquote>
<h3 id="五、Spring-AOP"><a href="#五、Spring-AOP" class="headerlink" title="五、Spring AOP"></a>五、Spring AOP</h3><h4 id="46-什么是AOP、能做什么"><a href="#46-什么是AOP、能做什么" class="headerlink" title="46.什么是AOP、能做什么"></a>46.什么是AOP、能做什么</h4><blockquote>
<p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻</p>
<p>辑，抽取并封装为一个可重用的模块，这个模块被命名为”切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p>
<p>可用于权限认证、日志、事务处理等。</p>
<p>AOP、OOP在字面上虽然非常类似，但却是面向不同领域的两种设计思想。OOP（面向对象编程）针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。 而AOP作为面向对象的一种补充，则是针对业务处理过程中的切面进行提取，已达到业务代码和公共行为代码之间低耦合性的隔离效果。这两种设计思想在目标上有着本质的差异。</p>
</blockquote>
<ol start="47">
<li><h4 id="解释一下Spring-AOP里面的几个名词"><a href="#解释一下Spring-AOP里面的几个名词" class="headerlink" title="解释一下Spring AOP里面的几个名词"></a>解释一下Spring AOP里面的几个名词</h4><ol>
<li><p>切面（Aspect）： 在Spring Aop指定就是”切面类” ，切面类会管理着切点、通知。</p>
</li>
<li><p>连接点（Join point）： 指定就是被增强的业务方法</p>
</li>
<li><p>通知（Advice）： 就是需要增加到业务方法中的公共代码， 通知有很多种类型分别可以在需要增加的业务方法不同位置进行执行（前置通知、后置通知、异常通知、返回通知、环绕通知）</p>
</li>
<li><p>切点（Pointcut）： 由他决定哪些方法需要增强、哪些不需要增强， 结合切点表达式进行实现</p>
</li>
<li><p>目标对象（Target Object）： 指定是增强的对象</p>
</li>
<li><p>织入（Weaving） ： spring aop用的织入方式：动态代理。 就是为目标对象创建动态代理的过程就叫织入。</p>
</li>
</ol>
</li>
</ol>
<p><img src="/media/image38.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”4.347458442694663in” height&#x3D;”4.094998906386702in”}</p>
<h4 id="48-Spring通知有哪些类型？"><a href="#48-Spring通知有哪些类型？" class="headerlink" title="48.Spring通知有哪些类型？"></a>48.Spring通知有哪些类型？</h4><blockquote>
<p>在AOP术语中，在的某个特定的连接点上执行的动作——官方 Spring切面可以应用5种类型的通知：</p>
</blockquote>
<ol>
<li><p>前置通知（Before）：在目标方法被调用之前调用通知功能；</p>
</li>
<li><p>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</p>
</li>
<li><p>返回通知（After-returning ）：在目标方法成功执行之后调用通知；</p>
</li>
<li><p>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</p>
</li>
<li><p>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。执行顺序：</p>
</li>
</ol>
<blockquote>
<p><img src="/media/image39.png" srcset="/img/loading.gif" lazyload>{width&#x3D;”4.284726596675416in” height&#x3D;”1.085in”}</p>
</blockquote>
<h5 id="Spring在5-2-7之后就改变的advice-的执行顺序。-在github官网版本更新说明中有说明：如图"><a href="#Spring在5-2-7之后就改变的advice-的执行顺序。-在github官网版本更新说明中有说明：如图" class="headerlink" title="Spring在5.2.7之后就改变的advice 的执行顺序。 在github官网版本更新说明中有说明：如图"></a>Spring在5.2.7之后就改变的advice 的执行顺序。 在github官网版本更新说明中有说明：如图</h5><blockquote>
<p>1、正常执行：@Before­­­&gt;方法­­­­&gt;@AfterReturning­­­&gt;@After 2、异常执行：@Before­­­&gt;方法­­­­&gt;@AfterThrowing­­­&gt;@After</p>
</blockquote>
<p><img src="/media/image40.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”4.24527012248469in” height&#x3D;”1.9047911198600176in”}</p>
<blockquote>
<p>更新说明：<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/releases/tag/v5.2.7.RELEASE"><span class="underline">https://github.com/spring­projects/spring­framewor...</span></a> #25186链接：<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/issues/25186"><span class="underline">https://github.com/spring­projects/spring­framewor...</span></a></p>
</blockquote>
<h4 id="Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？"></a>Spring AOP and AspectJ AOP 有什么区别？</h4><h5 id="关系："><a href="#关系：" class="headerlink" title="关系："></a>关系：</h5><blockquote>
<p>当在Spring中要使用@Aspect、@Before.等这些注解的时候， 就需要添加AspectJ相关依赖</p>
<p><strong>Spring Aop提供了 AspectJ 的支持，但只用到的AspectJ的切点解析和匹配。</strong> @Aspect、@Before.等这些注解</p>
<p>都是由<strong>AspectJ 发明的</strong></p>
<p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以 Spring AOP为代表。</p>
</blockquote>
<h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><blockquote>
<p>（2）<strong>Spring AOP</strong>使用的动态代理，<strong>它基于动态代理来实现</strong>。默认地，如果使用接口的，用 JDK 提供的动态代理实现，如果没有接口，使用 CGLIB 实现。</p>
<p>（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p>
<p>属于静态织入，它是通过修改代码来实现的，它的织入时机可以是：</p>
<p>Compile-time weaving：编译期织入，如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。</p>
<p>Post-compile weaving：编译后织入，也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。</p>
<p><strong>Load-time weaving</strong>：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法。1、自定义类加载器来干这个，这个应该是最容易想到的办法，在被织入类加载到 JVM 前去对它进行加载，这样就可以在加载的时候定义行为了。2、在 JVM 启动的时候指定 AspectJ 提供的 agent：-javaagent:xxx&#x2F;xxx&#x2F;aspectjweaver.jar。</p>
<p>AspectJ 出身也是名门，来自于 Eclipse 基金会，link：<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj"><span class="underline">https://www.eclipse.org/aspectj</span></a></p>
<p>AspectJ 能干很多 Spring AOP 干不了的事情，它是 <strong>AOP 编程的完全解决方案</strong>。Spring AOP 致力于解决的是企业级开发中最普遍的 AOP 需求（方法织入），而不是力求成为一个像 AspectJ 一样的 AOP 编程完全解决方案。</p>
<p>因为 AspectJ 在实际代码运行前完成了织入，所以大家会说它生成的类是没有额外运行时开销的。</p>
<p>很多人会对比 Spring AOP 和 AspectJ 的性能，Spring AOP 是基于代理实现的，在容器启动的时候需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 那么好。</p>
</blockquote>
<h4 id="JDK动态代理和CGLIB动态代理的区别"><a href="#JDK动态代理和CGLIB动态代理的区别" class="headerlink" title="JDK动态代理和CGLIB动态代理的区别"></a>JDK动态代理和CGLIB动态代理的区别</h4><blockquote>
<p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理： JDK动态代理<strong>只提供接口的代理，不支持类的代理。</strong></p>
<p>JDK会在运行时为目标类生成一个 动态代理类$proxy*.class .</p>
<p>该代理类是实现了接目标类<strong>接口</strong>， 并且代理类会实现<strong>接口</strong>所有的方法增强代码。</p>
<p>调用时 通过代理类先去调用处理类进行增强，再通过<strong>反射</strong>的方式进行调用目标方法。从而实现AOP</p>
<p>如果代理类<strong>没有实现 接口</strong>，那么Spring AOP会选择使用CGLIB来动态代理目标类。</p>
<p>CGLIB的底层是通过<strong>ASM</strong>在运行时动态的生成目标类的一个<strong>子类</strong>。（还有其他相关类，主要是为增强调用时效率） 会生成多个 ，</p>
<p>并且会重写<strong>父类</strong>所有的方法增强代码，</p>
<p>调用时先通过代理类进行增强，再<strong>直接调用父类对应的方法</strong>进行调用目标方法。从而实现 AOP。</p>
<p>CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为 final，那么它是无法使用CGLIB做动态代理的。</p>
<p>CGLIB 除了生成目标子类代理类，还有一个FastClass(路由类)，可以</p>
<p>（但不是必须）让本类方法调用进行增强，而不会像jdk代理那样本类方法调用增强会失效</p>
<p>很多人会对比 JDK和Cglib的性能，jdk动态代理生成类速度快，调用慢，cglib生成类速度慢，但后续调用快，在老版本CGLIB的速度是JDK速度的10倍左右， 但是实际上JDK的速度在版本升级的时候每次都提高很多性能，而 CGLIB仍止步不前.</p>
<p>在对JDK动态代理与CGlib动态代理的代码实验中看，1W次执行下，JDK7及8的动态代理性能比CGlib要好20%左右。</p>
</blockquote>
<h5 id="51-JavaConfig方式如何启用AOP-如何强制使用cglib"><a href="#51-JavaConfig方式如何启用AOP-如何强制使用cglib" class="headerlink" title="51.JavaConfig方式如何启用AOP?如何强制使用cglib?"></a>51.JavaConfig方式如何启用AOP?如何强制使用cglib?</h5><blockquote>
<p><strong>52.介绍AOP有几种实现方式</strong></p>
<p>Spring 1.2 <strong>基于接口的配置</strong>：最早的 Spring AOP 是完全基于几个接口的，想看源码的同学可以从这里起步。 Spring 2.0 <strong>schema-based 配置</strong>：Spring 2.0 以后使用 XML 的方式来配置，使用 命名空间 &lt;aop &gt;&lt;&#x2F;aop&gt;</p>
<p>Spring 2.0 <strong><span class="underline"><a target="_blank" rel="noopener" href="https://github.com/AspectJ">@Aspect</a>J</span> 配置</strong>：使用注解的方式来配置，这种方式感觉是最方便的，还有，这里虽然叫做 <a target="_blank" rel="noopener" href="https://github.com/AspectJ"><span class="underline">@AspectJ</span></a>，但是这个和 AspectJ 其实没啥关系。</p>
<p>AspectJ 方式，这种方式其实和Spring没有关系，采用AspectJ 进行动态织入的方式实现AOP，需要用 AspectJ 单独编译。</p>
</blockquote>
<h5 id="53-什么情况下AOP会失效，怎么解决？"><a href="#53-什么情况下AOP会失效，怎么解决？" class="headerlink" title="53.什么情况下AOP会失效，怎么解决？"></a>53.什么情况下AOP会失效，怎么解决？</h5><blockquote>
<p>失效原因：</p>
</blockquote>
<ol>
<li><p>方法是private 也会失效，解决：改成public</p>
</li>
<li><p>目标类没有配置为Bean也会失效， 解决：配置为Bean</p>
</li>
<li><p>切点表达式没有配置正确</p>
</li>
<li><p>...</p>
</li>
</ol>
<h6 id="内部调用不会触发AoP"><a href="#内部调用不会触发AoP" class="headerlink" title="内部调用不会触发AoP."></a>内部调用不会触发AoP.</h6><blockquote>
<p>解决方式：必须走<strong>代理， 重新拿到代理对象再次执行方法才能进行增强</strong></p>
</blockquote>
<ol>
<li><h6 id="在本类中自动注入当前的bean"><a href="#在本类中自动注入当前的bean" class="headerlink" title="在本类中自动注入当前的bean"></a>在本类中自动注入当前的bean</h6></li>
<li><p><strong>设置暴露当前代理对象到本地线程， 可以通过</strong>AopContext.currentProxy() 拿到当前正在调用的动态代理对象</p>
</li>
</ol>
<h5 id="54-Spring的AOP是在哪里创建的动态代理？"><a href="#54-Spring的AOP是在哪里创建的动态代理？" class="headerlink" title="54.Spring的AOP是在哪里创建的动态代理？"></a>54.Spring的AOP是在哪里创建的动态代理？</h5><ol>
<li><p>正常的Bean会在Bean的生命周期的’初始化’后， 通过BeanPostProcessor.postProcessAfterInitialization创建aop的动态代理</p>
</li>
<li><p>还有一种特殊情况： 循环依赖的Bean会在Bean的生命周期’属性注入’时存在的循环依赖的情况下， 也会为循环依赖的Bean通过MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition创建aop</p>
</li>
</ol>
<h5 id="55-Spring的-Aop的完整实现流程？"><a href="#55-Spring的-Aop的完整实现流程？" class="headerlink" title="55.Spring的 Aop的完整实现流程？"></a>55.Spring的 Aop的完整实现流程？</h5><blockquote>
<p>Aop的实现大致分为三大步：JavaConfig</p>
<p>当@EnableAspectJAutoProxy 会通过@Import注册一个BeanPostProcessor处理AOP</p>
</blockquote>
<ol>
<li><p><strong>解析切面</strong>： 在Bean创建之前的第一个Bean后置处理器会去解析切面（解析切面中通知、切点，一个通知就会解析成一个advisor(通知、切点)）</p>
</li>
<li><p><strong>创建动态代理</strong> 正常的Bean初始化后调用BeanPostProcessor 拿到之前缓存的advisor ，再通过advisor中pointcut判断当前Bean是否被切点表达式匹配，如果匹配，就会为Bean创建动态代理（创建方式1.jdk动态代理2.cglib)。</p>
</li>
<li><p><strong>调用</strong>：拿到动态代理对象， 调用方法 就会判断当前方法是否增强的方法， 就会通过<strong>调用链</strong>的方式依次去执行通知.</p>
</li>
</ol>
<p><img src="/media/image41.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”6.858179133858267in” height&#x3D;”2.0999989063867015in”}</p>
<h4 id="六、Spring事务"><a href="#六、Spring事务" class="headerlink" title="六、Spring事务"></a>六、Spring事务</h4><h5 id="56-事务四大特性"><a href="#56-事务四大特性" class="headerlink" title="56.事务四大特性"></a>56.事务四大特性</h5><h6 id="⑴-原子性（Atomicity）"><a href="#⑴-原子性（Atomicity）" class="headerlink" title="⑴ 原子性（Atomicity）"></a>⑴ 原子性（Atomicity）</h6><blockquote>
<p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚， 因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
</blockquote>
<h6 id="⑵-一致性（Consistency）"><a href="#⑵-一致性（Consistency）" class="headerlink" title="⑵ 一致性（Consistency）"></a>⑵ 一致性（Consistency）</h6><blockquote>
<p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<p>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是</p>
<p>5000，这就是事务的一致性。</p>
</blockquote>
<h6 id="⑶-隔离性（Isolation）"><a href="#⑶-隔离性（Isolation）" class="headerlink" title="⑶ 隔离性（Isolation）"></a>⑶ 隔离性（Isolation）</h6><blockquote>
<p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都 感觉不到有其他事务在并发地执行。</p>
<p>关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</p>
</blockquote>
<h6 id="⑷-持久性（Durability）"><a href="#⑷-持久性（Durability）" class="headerlink" title="⑷ 持久性（Durability）"></a>⑷ 持久性（Durability）</h6><blockquote>
<p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<p>例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错</p>
<p>误。</p>
</blockquote>
<h4 id="Spring支持的事务管理类型，-spring-事务实现方式有哪些？"><a href="#Spring支持的事务管理类型，-spring-事务实现方式有哪些？" class="headerlink" title="Spring支持的事务管理类型， spring 事务实现方式有哪些？"></a>Spring支持的事务管理类型， spring 事务实现方式有哪些？</h4><blockquote>
<p>Spring支持两种类型的事务管理：</p>
<p><strong>编程式事务管理</strong>：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p>
<p><strong>声明式事务管理</strong>：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p>
</blockquote>
<h6 id="实现声明式事务的三种方式："><a href="#实现声明式事务的三种方式：" class="headerlink" title="实现声明式事务的三种方式："></a>实现声明式事务的三种方式：</h6><ol>
<li><p><strong>基于接口</strong></p>
<p>a.  <strong>基于 TransactionInterceptor 的声明式事务:</strong> Spring 声明式事务的基础，通常也不建议使用这种方式，但是与aop一样，了解这种方式对理解 Spring 声明式事务有很大作用。</p>
<p>b.  <strong>基于 TransactionProxyFactoryBean 的声明式事务:</strong> 第一种方式的改进版本，简化的配置文件的书写，这是</p>
</li>
</ol>
<blockquote>
<p>Spring 早期推荐的声明式事务管理方式，但是在 Spring 2.0 中已经不推荐了。</p>
</blockquote>
<ol start="2">
<li><p><strong>基于&lt; tx&gt; 和&lt; aop&gt;命名空间的声明式事务管理：</strong> 目前推荐的方式，其最大特点是与 Spring AOP 结合紧密，可以充分利用切点表达式的强大支持，使得管理事务更加灵活。</p>
</li>
<li><p><strong>基于 @Transactional 的全注解方式：</strong> 将声明式事务管理简化到了极致。开发人员只需在配置文件中加上一行启用相关后处理 Bean 的配置，然后在需要实施事务管理的方法或者类上使用 @Transactional 指定事务规则即可实现事务管理，而且功能也不必其他方式逊色。</p>
</li>
</ol>
<h2 id="58、说一下Spring的事务传播行为"><a href="#58、说一下Spring的事务传播行为" class="headerlink" title="58、说一下Spring的事务传播行为"></a>58、说一下Spring的事务传播行为</h2><blockquote>
<p>事务的传播特性指的是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行？</p>
</blockquote>
<p>+————————+———————-+———————————————————+————————————————————+<br>| &gt; <strong>事务传播行为类型</strong> | &gt; <strong>外部不存在事务</strong> | &gt; <strong>外部存在事务</strong>                                      | &gt; <strong>使用方式</strong>                                             |<br>+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+<br>| REQUIRED（默认）       | 开启新的事务         | &gt; 融合到外部事务中                                      | &gt; @Transactional(propagation &#x3D; Propagation.REQUIRED)      |<br>|                        |                      |                                                         | &gt;                                                          |<br>|                        |                      |                                                         | &gt; 适用增删改查                                             |<br>+————————+———————-+———————————————————+————————————————————+<br>| SUPPORTS               | 不开启新的事务       | &gt; 融合到外部事务中                                      | &gt; @Transactional(propagation &#x3D; Propagation.SUPPORTS)      |<br>|                        |                      |                                                         | &gt;                                                          |<br>|                        |                      |                                                         | &gt; 适用查询                                                 |<br>+————————+———————-+———————————————————+————————————————————+<br>| REQUIRES_NEW           | 开启新的事务         | &gt; 不用外部事务，创建新的事务                            | &gt; @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)  |<br>|                        |                      |                                                         | &gt;                                                          |<br>|                        |                      |                                                         | &gt; 适用内部事务和外部事务不存在业务关联情况，如日志         |<br>+————————+———————-+———————————————————+————————————————————+<br>| NOT_SUPPORTED          | 不开启新的事务       | &gt; 不用外部事务                                          | &gt; @Transactional(propagation &#x3D; Propagation.NOT_SUPPORTED) |<br>|                        |                      |                                                         | &gt;                                                          |<br>|                        |                      |                                                         | &gt; 不常用                                                   |<br>+————————+———————-+———————————————————+————————————————————+<br>| NEVER                  | 不开启新的事务       | &gt; 抛出异常                                              | &gt; @Transactional(propagation &#x3D; Propagation.NEVER )        |<br>|                        |                      |                                                         | &gt;                                                          |<br>|                        |                      |                                                         | &gt; 不常用                                                   |<br>+————————+———————-+———————————————————+————————————————————+<br>| MANDATORY              | 抛出异常             | &gt; 融合到外部事务中                                      | &gt; @Transactional(propagation &#x3D; Propagation.MANDATORY)     |<br>|                        |                      |                                                         | &gt;                                                          |<br>|                        |                      |                                                         | &gt; 不常用                                                   |<br>+————————+———————-+———————————————————+————————————————————+<br>| NESTED                 | 开启新的事务         | &gt; 融合到外部事务中，SavePoint机制，外层影响内层， 内层不 | &gt; @Transactional(propagation &#x3D; Propagation.NESTED)不常用  |<br>|                        |                      | &gt;                                                       |                                                            |<br>|                        |                      | &gt; 会影响外层                                            |                                                            |<br>+————————+———————-+———————————————————+————————————————————+</p>
<h4 id="说一下-spring-的事务隔离？"><a href="#说一下-spring-的事务隔离？" class="headerlink" title="说一下 spring 的事务隔离？"></a>说一下 spring 的事务隔离？</h4><blockquote>
<p>用来解决并发事务所产生一些问题：并发会产生什么问题？</p>
<p>1.脏读</p>
<p>2.不可重复度</p>
<p>3.幻影读</p>
<p>概念： 通过设置隔离级别可解决在并发过程中产生的那些问题：</p>
</blockquote>
<ol>
<li><strong>脏读</strong></li>
</ol>
<hr>
<p>  <strong>事务1</strong> begin                      <strong>事务2</strong> begin</p>
<hr>
<pre><code class="hljs">                                   update t_user set balance=800 where id=1;
</code></pre>
<hr>
<p>+————————————+———————————+<br>|                                    | #balance&#x3D;800                    |<br>+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+<br>| select * from t_user where id&#x3D;1   |                                 |<br>|                                    |                                 |<br>| commit;                            |                                 |<br>|                                    |                                 |<br>| #balance&#x3D;800                       |                                 |<br>+————————————+———————————+<br>|                                    | rollback; #回滚                 |<br>|                                    |                                 |<br>|                                    | #balance&#x3D;1000                   |<br>+————————————+———————————+</p>
<ol>
<li>一个事务，读取了另一个事务中没有提交的数据，会在本事务中产生的数据不一致的问题解决方式：@Transactional(isolation &#x3D; Isolation.READ_COMMITTED)</li>
</ol>
<blockquote>
<p>读已提交：READ COMMITTED</p>
<p>要求Transaction01只能读取Transaction02已提交的修改。</p>
</blockquote>
<ol>
<li><strong>不可重复度</strong></li>
</ol>
<p>+————————————+——————————————-+<br>| <strong>事务1</strong> begin                    | <strong>事务2</strong> begin                           |<br>+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+<br>| select * from t_user where id&#x3D;1   |                                           |<br>|                                    |                                           |<br>| #balance&#x3D;1000                      |                                           |<br>+————————————+——————————————-+<br>|                                    | update t_user set balance&#x3D;800 where id&#x3D;1; |<br>|                                    |                                           |<br>|                                    | commit;                                   |<br>|                                    |                                           |<br>|                                    | #balance&#x3D;800                              |<br>+————————————+——————————————-+<br>| select * from t_user where id&#x3D;1   |                                           |<br>|                                    |                                           |<br>| #balance&#x3D;800                       |                                           |<br>+————————————+——————————————-+<br>| commit;                            |                                           |<br>+————————————+——————————————-+</p>
<blockquote>
<p>一个事务中，多次读取相同的数据， 但是读取的结果不一样， 会在本事务中产生数据不一致的问题。解决方式：@Transactional(isolation &#x3D; Isolation.REPEATABLE_READ)</p>
<p>可重复读：REPEATABLE READ</p>
<p>确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其它事务对这个字段进行更新。(行锁）</p>
</blockquote>
<ol start="2">
<li><strong>幻影读</strong></li>
</ol>
<p>+——————————————–+———————————–+<br>| <strong>事务1</strong> begin                            | <strong>事务2</strong> begin                   |<br>+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+<br>| select sum(balance) from t_user where id&#x3D;1 |                                   |<br>|                                            |                                   |<br>| #balance&#x3D;3000                              |                                   |<br>+——————————————–+———————————–+<br>|                                            | INSERT INTO t_user VALUES         |<br>|                                            |                                   |<br>|                                            | &gt; (                               |<br>|                                            | &gt;                                 |<br>|                                            | &gt; &#39;4&#39;，                          |<br>|                                            | &gt;                                 |<br>|                                            | &gt; &#39;赵六&#39;， &#39;123456784&#39;，        |<br>|                                            | &gt;                                 |<br>|                                            | &gt; &#39;1000&#39;                        |<br>|                                            |                                   |<br>|                                            | );                                |<br>|                                            |                                   |<br>|                                            | commit;                           |<br>+——————————————–+———————————–+<br>| select sum(balance) from t_user where id&#x3D;1 |                                   |<br>|                                            |                                   |<br>| #balance&#x3D;4000                              |                                   |<br>+——————————————–+———————————–+<br>| commit;                                    |                                   |<br>+——————————————–+———————————–+</p>
<blockquote>
<p>一个事务中，多次对数据进行整表数据读取（统计），但是结果不一样， 会在本事务中产生数据不一致的问题。解决方式：@Transactional(isolation &#x3D; Isolation.SERIALIZABLE)</p>
<p>串行化：SERIALIZABLE</p>
<p>确保Transaction01可以多次从一个表中读取到相同的行，在Transaction01执行期间，禁止其它事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。（表锁）</p>
<p>很多人容易搞混不可重复读和幻读，确实这两者有些相似：对于前者， 只需要锁行</p>
<p>对于后者， 需要锁表</p>
<p><img src="/media/image42.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”4.036305774278215in” height&#x3D;”1.1793744531933508in”}</p>
<p>当不设置事务隔离级别将使用数据库的默认事务隔离级别：</p>
</blockquote>
<h5 id="60-Spring事务实现基本原理"><a href="#60-Spring事务实现基本原理" class="headerlink" title="60.Spring事务实现基本原理"></a>60.Spring事务实现基本原理</h5><blockquote>
<p>使用：</p>
<p>原理：</p>
</blockquote>
<ol>
<li><p>解析切面 ——&gt; bean的创建前第一个bean的后置处理器进行解析advisor(pointcut(通过@Transacational解析的切点) ， advise) (这个advisor 是通过@EnableTransactionManagement注册了一个配置类，该配置类就配置了adivsor)</p>
</li>
<li><p>创建动态代理——&gt; bean的初始化后调用bean的后置处理器进行创建动态代理(有接口使用jdk，没接口使用cglib)， 创建动态代理之前会先根据advisor中pointCut 匹配@Transacational( 方法里面是不是有、类上面是不是有、接口或父类上面是不是有 ) ， 匹配到就创建动态代理。</p>
</li>
<li><p>调用： 动态代理</p>
</li>
</ol>
<blockquote>
<p>try{</p>
<p>4.创建一个数据库连接Connection， 并且修改数据库连接的autoCommit属性为false，禁止此连接的自动提交，这是实现Spring事务非常重要的一步</p>
<p>5.然后执行目标方法方法，方法中会执行数据库操作sql</p>
<p>}</p>
<p>catch{</p>
<p>6.如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务</p>
<p>}</p>
<p>7.执行完当前方法后，如果没有出现异常就直接提交事务</p>
<p><img src="/media/image43.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”4.25419728783902in” height&#x3D;”0.9097911198600175in”}</p>
</blockquote>
<h5 id="Spring事务传播行为实现原理："><a href="#Spring事务传播行为实现原理：" class="headerlink" title="Spring事务传播行为实现原理："></a>Spring事务传播行为实现原理：</h5><ol start="2">
<li>Spring的事务信息是存在ThreadLocal中的， 所以一个线程永远只能有一个事务，</li>
</ol>
<blockquote>
<p><strong>融入：</strong>当传播行为是融入外部事务则拿到ThreadLocal中的Connection、共享一个数据库连接共同提交、回</p>
<p>滚；</p>
<p><strong>创建新事务：</strong>当传播行为是创建新事务，会将嵌套新事务存入ThreadLocal、再将外部事务暂存起来； 当嵌套</p>
<p>事务提交、回滚后，会将暂存的事务信息恢复到ThreadLocal中调用：融入</p>
<p>调用：创建新事务</p>
</blockquote>
<ol start="62">
<li><h5 id="Spring多线程事务-能否保证事务的一致性（同时提交、同时回滚）？"><a href="#Spring多线程事务-能否保证事务的一致性（同时提交、同时回滚）？" class="headerlink" title="Spring多线程事务 能否保证事务的一致性（同时提交、同时回滚）？"></a>Spring多线程事务 能否保证事务的一致性（同时提交、同时回滚）？</h5><ol>
<li><p>Spring的事务信息是存在ThreadLocal中的Connection， 所以一个线程永远只能有一个事务</p>
</li>
<li><p>所以Spring 的事务是无法实现事务一致性的</p>
</li>
<li><p>可以通过编程式事务，或者通过分布式事务的思路:二阶段提交方式</p>
</li>
</ol>
</li>
</ol>
<h5 id="63-Spring事务的失效原因？"><a href="#63-Spring事务的失效原因？" class="headerlink" title="63.Spring事务的失效原因？"></a>63.Spring事务的失效原因？</h5><blockquote>
<p>失效原因：</p>
</blockquote>
<ol>
<li><p>方法是private 也会失效，解决：改成public</p>
</li>
<li><p>目标类没有配置为Bean也会失效 解决：配置为Bean</p>
</li>
<li><p>自己捕获了异常 解决：不要捕获处理</p>
</li>
<li><p>使用cglib动态代理，但是@Transactional声明在接口上面</p>
</li>
<li><p>...</p>
</li>
</ol>
<h6 id="内部调用导致事务传播失效"><a href="#内部调用导致事务传播失效" class="headerlink" title="内部调用导致事务传播失效."></a>内部调用导致事务传播失效.</h6><blockquote>
<p>解决方式：必须走<strong>代理， 重新拿到代理对象再次执行方法才能进行增强</strong></p>
</blockquote>
<ol start="3">
<li><h6 id="在本类中自动注入当前的bean-1"><a href="#在本类中自动注入当前的bean-1" class="headerlink" title="在本类中自动注入当前的bean"></a>在本类中自动注入当前的bean</h6></li>
<li><p><strong>设置暴露当前代理对象到本地线程， 可以通过</strong>AopContext.currentProxy() 拿到当前正在调用的动态代理对象</p>
</li>
</ol>
<blockquote>
<p><strong>七、Spring其他</strong></p>
<p><strong>64.Spring事件监听的核心机制是什么？</strong></p>
<p>原理：观察者模式</p>
<p>支持异步：</p>
<p>异步发布事件的核心机制？ 多线程</p>
<p>spring的事件监听有三个部分组成：</p>
<p><strong>事件</strong>（ApplicationEvent) 负责对应相应监听器 事件源发生某事件是特定事件监听器被触发的原因。</p>
<p><strong>监听器(<strong>ApplicationListener) 对应于观察者模式中的</strong>观察者</strong>。监听器监听特定事件，并在内部定义了事件发生后的响应逻辑。</p>
<p><strong>事件发布器</strong>（ApplicationEventMulticaster ）对应于观察者模式中的<strong>被观察者&#x2F;主题， 负责通知观察者</strong> 对外提供发布事件和增删事件监听器的接口，维护事件和事件监听器之间的映射关系，并在事件发生时负责通知相关监听器。</p>
<p><img src="/media/image44.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”5.089530839895013in” height&#x3D;”3.1609372265966753in”}</p>
</blockquote>
<p><img src="/media/image45.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”3.489589895013123in” height&#x3D;”3.5523950131233595in”}</p>
<h6 id="Spring事件机制是观察者模式的一种实现，但是除了发布者和监听者者两个角色之外，还有一个EventMultiCaster的角色负责把事件转发给监听者，工作流程如下："><a href="#Spring事件机制是观察者模式的一种实现，但是除了发布者和监听者者两个角色之外，还有一个EventMultiCaster的角色负责把事件转发给监听者，工作流程如下：" class="headerlink" title="Spring事件机制是观察者模式的一种实现，但是除了发布者和监听者者两个角色之外，还有一个EventMultiCaster的角色负责把事件转发给监听者，工作流程如下："></a>Spring事件机制是观察者模式的一种实现，但是除了发布者和监听者者两个角色之外，还有一个EventMultiCaster的角色负责把事件转发给监听者，工作流程如下：</h6><blockquote>
<p><img src="/media/image46.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”3.423801399825022in” height&#x3D;”2.223853893263342in”}</p>
<p><strong>Spring事件机制</strong></p>
<p><strong>也就是说上面代码中发布者调用</strong>applicationEventPublisher.publishEvent(msg); <strong>是会将事件发送给了EventMultiCaster， 而后由 EventMultiCaster注册着所有的Listener，然后根据事件类型决定转发给那个Listener。</strong></p>
</blockquote>
<h5 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h5><p><img src="/media/image47.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”6.189207130358705in” height&#x3D;”3.50625in”}</p>
<blockquote>
<p><strong>66.Spring是如何整合MyBatis将Mapper接口注册为Bean的原理？</strong></p>
</blockquote>
<ol>
<li><p>首先MyBatis的Mapper接口核心是<strong>JDK动态代理</strong></p>
</li>
<li><p>Spring会排除接口，无法注册到IoC容器中</p>
</li>
<li><p>MyBatis 实现了<strong>BeanDefinitionRegistryPostProcessor</strong> 可以动态注册BeanDefinition</p>
</li>
<li><p>需要<strong>自定义扫描器</strong>（继承Spring内部扫描器ClassPathBeanDefinitionScanner ) 重写排除接口的方法</p>
</li>
</ol>
<blockquote>
<p>（isCandidateComponent）</p>
</blockquote>
<ol start="5">
<li><p>但是接口虽然注册成了BeanDefinition但是无法实例化Bean 因为接口无法实例化</p>
</li>
<li><p>需要将BeanDefinition的BeanClass 替换成JDK动态代理的实例（<strong>偷天换日</strong>）</p>
</li>
<li><p>Mybatis 通过<strong>FactoryBean</strong>的工厂方法设计模式可以自由控制Bean的实例化过程，可以在getObject方法中创建JDK动态代理</p>
</li>
</ol>
<p><img src="/media/image48.png" srcset="/img/loading.gif" lazyload>{width&#x3D;”4.27830927384077in” height&#x3D;”3.6365616797900264in”}</p>
<h1 id="八、SpringMVC"><a href="#八、SpringMVC" class="headerlink" title="八、SpringMVC"></a>八、SpringMVC</h1><h5 id="说说你是如何解决-get-和-post-乱码问题？"><a href="#说说你是如何解决-get-和-post-乱码问题？" class="headerlink" title="说说你是如何解决 get 和 post 乱码问题？"></a>说说你是如何解决 get 和 post 乱码问题？</h5><ol>
<li><p>解决post请求乱码问题：在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf­8；</p>
<ol>
<li><p>&lt;filter&gt;</p>
</li>
<li><p>&lt;filter‐name&gt;CharacterEncodingFilter&lt;&#x2F;filter‐name&gt;</p>
</li>
<li><p>&lt;filter‐class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter‐class&gt;</p>
</li>
<li><p>&lt;init‐param&gt;</p>
</li>
<li><p>&lt;param‐name&gt;encoding&lt;&#x2F;param‐name&gt;</p>
</li>
<li><p>&lt;param‐value&gt;utf‐8&lt;&#x2F;param‐value&gt;</p>
</li>
<li><p>&lt;&#x2F;init‐param&gt;</p>
</li>
<li><p>&lt;&#x2F;filter&gt;</p>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>9</p>
</blockquote>
<ol start="10">
<li><p>&lt;filter‐mapping&gt;</p>
</li>
<li><p>&lt;filter‐name&gt;CharacterEncodingFilter&lt;&#x2F;filter‐name&gt;</p>
</li>
<li><p>&lt;url‐pattern&gt;&#x2F;*&lt;&#x2F;url‐pattern&gt;</p>
</li>
<li><p>&lt;&#x2F;filter‐mapping&gt;</p>
</li>
</ol>
<p>&nbsp;</p>
<ol start="2">
<li>get请求中文参数出现乱码解决方法有两个：</li>
</ol>
<blockquote>
<p>①修改tomcat配置文件添加编码与工程编码一致，如下：</p>
<p>ISO8859­1是tomcat默认编码，需要将tomcat编码后的内容按utf­8编码。</p>
</blockquote>
<h5 id="Spring-MVC的控制器是不是单例模式，如果是，有什么问题，怎么解决？"><a href="#Spring-MVC的控制器是不是单例模式，如果是，有什么问题，怎么解决？" class="headerlink" title="Spring MVC的控制器是不是单例模式，如果是，有什么问题，怎么解决？"></a>Spring MVC的控制器是不是单例模式，如果是，有什么问题，怎么解决？</h5><blockquote>
<p>答：是单例模式，所以在多线程访问的时候有线程安全问题，不要用同步，会影响性能的，解决方案是在控制器里面不能写字段。</p>
</blockquote>
<h5 id="请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？"><a href="#请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？" class="headerlink" title="请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？"></a>请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？</h5><blockquote>
<p>（1）用户发送请求至前端控制器DispatcherServlet；</p>
<p>（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；</p>
<p>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet；</p>
</blockquote>
<ol start="4">
<li><p>DispatcherServlet 调用 HandlerAdapter处理器适配器；</p>
</li>
<li><p>HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；</p>
</li>
</ol>
<blockquote>
<p>（6）Handler执行完成返回ModelAndView；</p>
<p>（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；</p>
<p>（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；</p>
<p>（9）ViewResolver解析后返回具体View；</p>
<p>（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）</p>
<p>（11）DispatcherServlet响应用户。</p>
</blockquote>
<p><img src="/media/image49.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”5.688757655293088in” height&#x3D;”4.127811679790026in”}</p>
<h5 id="70-SpringMvc怎么和AJAX相互调用的？"><a href="#70-SpringMvc怎么和AJAX相互调用的？" class="headerlink" title="70.SpringMvc怎么和AJAX相互调用的？"></a>70.SpringMvc怎么和AJAX相互调用的？</h5><blockquote>
<p>（1）加入Jackson.jar</p>
<p>（2）在配置文件中配置json的消息转换器.(jackson不需要该配置HttpMessageConverter）</p>
<p>（3）在接受Ajax方法里面可以直接返回Object，List等，但方法前面要加上@ResponseBody注解。</p>
<p><img src="/media/image50.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”4.2826148293963255in” height&#x3D;”1.5956244531933508in”}</p>
<p>springMVC对数据Message的处理操作提供了一个接口HttpMessageConverter，用来对参数值和返回值的转换处理。在请求和返回过程中可以进行转换json</p>
</blockquote>
<h5 id="71-Spring和SpringMVC为什么需要父子容器？"><a href="#71-Spring和SpringMVC为什么需要父子容器？" class="headerlink" title="71.Spring和SpringMVC为什么需要父子容器？"></a>71.Spring和SpringMVC为什么需要父子容器？</h5><blockquote>
<p>就功能性来说不用子父容器也可以完成（参考：SpringBoot就没用子父容器）</p>
</blockquote>
<ol>
<li><p>所以父子容器的主要作用应该是划分框架边界。有点单一职责的味道。service、dao层我们一般使用spring框架来管理、controller层交给springmvc管理</p>
</li>
<li><p>规范整体架构 使 父容器service无法访问子容器controller、子容器controller可以访问父容器 service</p>
</li>
<li><p>方便子容器的切换。如果现在我们想把web层从spring mvc替换成struts，那么只需要将spring­mvc.xml替换成 Struts的配置文件struts.xml即可，而spring­core.xml不需要改变。</p>
</li>
<li><p>为了节省重复bean创建</p>
</li>
</ol>
<h5 id="是否可以把所有Bean都通过Spring容器来管理？（Spring的applicationContext-xml中配置全局扫描"><a href="#是否可以把所有Bean都通过Spring容器来管理？（Spring的applicationContext-xml中配置全局扫描" class="headerlink" title="是否可以把所有Bean都通过Spring容器来管理？（Spring的applicationContext.xml中配置全局扫描)"></a>是否可以把所有Bean都通过Spring容器来管理？（Spring的applicationContext.xml中配置全局扫描)</h5><blockquote>
<p>不可以，这样会导致我们请求接口的时候产生404。 如果所有的Bean都交给父容器，SpringMVC在初始化HandlerMethods的时候（initHandlerMethods）无法根据Controller的handler方法注册HandlerMethod，并没有去查找父容器的bean；</p>
<p>也就无法根据请求URI 获取到 HandlerMethod来进行匹配.</p>
<p><img src="/media/image51.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”4.365512904636921in” height&#x3D;”0.48374890638670165in”}</p>
</blockquote>
<h5 id="是否可以把我们所需的Bean都放入Spring­mvc子容器里面来管理（springmvc的spring­-servlet-xml中配置全局扫描）"><a href="#是否可以把我们所需的Bean都放入Spring­mvc子容器里面来管理（springmvc的spring­-servlet-xml中配置全局扫描）" class="headerlink" title="是否可以把我们所需的Bean都放入Spring­mvc子容器里面来管理（springmvc的spring­ servlet.xml中配置全局扫描）?"></a>是否可以把我们所需的Bean都放入Spring­mvc子容器里面来管理（springmvc的spring­ servlet.xml中配置全局扫描）?</h5><blockquote>
<p><strong>可以</strong> ， 因为父容器的体现无非是为了获取子容器不包含的bean， 如果全部包含在子容器完全用不到父容器了， 所以是可以全部放在 springmvc子容器来管理的。</p>
<p>虽然可以这么做不过一般应该是不推荐这么去做的，一般人也不会这么干的。<strong>如果你的项目里有用到事物、或者aop记得也需要把这部分配置需要放到Spring-mvc子容器的配置文件来，不然一部分内容在子容器和一部分内容在父容器，可能就会导致你的事物或者AOP不生效</strong>。 所以如果aop或事物如果不生效也有可能是通过父容器(spring)去增强子容器 (Springmvc)，也就无法增强。</p>
</blockquote>
<h5 id="74-如何实现无XML零配置的SpringMVC"><a href="#74-如何实现无XML零配置的SpringMVC" class="headerlink" title="74.如何实现无XML零配置的SpringMVC"></a>74.如何实现无XML零配置的SpringMVC</h5><ol>
<li><p>省略<strong>web.xml</strong></p>
<p>a.  servlet3.0之后规范中提供了<strong>SPI</strong>扩展:META-INF&#x2F;services&#x2F;javax.servlet.ServletContainerInitializer</p>
<p>b.  SpringMVC通过实现ServletContainerInitializer接口</p>
<p>c.  动态注册ContextLoaderListener 和DispatcherServlet并创建子父容器(Application)</p>
</li>
<li><p>省略<strong>spring.xml</strong>和<strong>spring-mvc.xml(只是sprinmvc方式 ，springboot在自动配置类完成) 配置类--xml</strong></p>
<p>a.  实现一个继承AbstractAnnotationConfigDispatcherServletInitializer的类</p>
<p>b.  该类就实现了ServletContainerInitializer，它会创建ContextLoaderListener 和DispatcherServlet</p>
<p>c.  还会创建父子容器， 创建容器时<strong>传入父子容器配置类</strong>则可以替代spring.xml和spring-mvc.xml</p>
</li>
</ol>
<h5 id="75-SpringMVC的拦截器和过滤器有什么区别？执行顺序？"><a href="#75-SpringMVC的拦截器和过滤器有什么区别？执行顺序？" class="headerlink" title="75.SpringMVC的拦截器和过滤器有什么区别？执行顺序？"></a>75.SpringMVC的拦截器和过滤器有什么区别？执行顺序？</h5><blockquote>
<p>拦截器不依赖与servlet容器，过滤器依赖与servlet容器。</p>
<p>拦截器只能对action请求(DispatcherServlet 映射的请求)起作用，而过滤器则可以对几乎所有的请求起作用。 拦截器可以访问容器中的Bean(DI)，而过滤器不能访问（基于spring注册的过滤器也可以访问容器中的bean）。</p>
</blockquote>
<p>####### 执行顺序：</p>
<p><img src="/media/image52.png" srcset="/img/loading.gif" lazyload>{width&#x3D;”3.3020002187226596in” height&#x3D;”2.9175in”}<img src="/media/image53.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”4.325415573053369in” height&#x3D;”1.3534372265966754in”}</p>
<blockquote>
<p>多个过滤器的执行顺序跟xml文件中定义的先后关系有关</p>
<p>当然，对于多个拦截器它们之间的执行顺序跟在SpringMVC的配置文件中定义的先后顺序有关。</p>
</blockquote>
<h1 id="九、Spring-Boot"><a href="#九、Spring-Boot" class="headerlink" title="九、Spring Boot"></a>九、Spring Boot</h1><blockquote>
<p><strong>76.谈谈你对SpringBoot的理解，它有哪些特性（优点）？</strong> SpringBoot的用来快速开发Spring应用的一个脚手架、其设计目的是用来简新Spring应用的初始搭建以及开发过程。 1.SpringBoot提供了很多内置的Starter结合自动配置，对主流框架无配置集成、开箱即用。</p>
<p>2.SpringBoot简化了开发，采用JavaConfig的方式可以使用零xml的方式进行开发；</p>
<p>2.SpringBoot内置Web容器无需依赖外部Web服务器，省略了Web.xml，直接运行jar文件就可以启动web应用； 4.SpringBoot帮我管理了常用的第三方依赖的版本，减少出现版本冲突的问题；</p>
</blockquote>
<ol>
<li>SpringBoot自带了监控功能，可以监控应用程序的运行状况，或者内存、线程池、Http 请求统计等，同时还提供了优雅关闭应用程序等功能。</li>
</ol>
<h5 id="77-Spring和SpringBoot的关系和区别？"><a href="#77-Spring和SpringBoot的关系和区别？" class="headerlink" title="77.Spring和SpringBoot的关系和区别？"></a>77.Spring和SpringBoot的关系和区别？</h5><blockquote>
<p>SpringBoot是Spring生态的产品。 Spring Framework是一个容器框架</p>
<p>SpringBoot 它不是一个框架、它是一个可以快速构建基于Spring的脚手架(里面包含了Spring和各种框架），为开发Spring生态其他框架铺平道路</p>
<p>2个不是一个层面的东西， 没有可比性。</p>
</blockquote>
<h5 id="78-SpringBoot的核心注解"><a href="#78-SpringBoot的核心注解" class="headerlink" title="78.SpringBoot的核心注解"></a>78.SpringBoot的核心注解</h5><ol>
<li><p>@SpringBootApplication注解：这个注解标识了一个SpringBoot工程，它实际上是另外三个注解的组合，这三个注解是：</p>
</li>
<li><p>@SpringBootConfiguration：这个注解实际就是一个@Configuration，表示启动类也是一个配置类</p>
</li>
<li><p>@EnableAutoConfiguration：向Spring容器中导入了一个Selector，用来加载ClassPath下SpringFactories中所定义的自动配置类，将这些自动加载为配置Bean</p>
</li>
<li><p>@Conditional 也很关键， 如果没有它我们无法在自定义应用中进行定制开发</p>
</li>
</ol>
<blockquote>
<p>@ConditionalOnBean、 @ConditionalOnClass、 @ConditionalOnExpression、 @ConditionalOnMissingBean等。</p>
</blockquote>
<h5 id="79-springboot的自动配置原理？"><a href="#79-springboot的自动配置原理？" class="headerlink" title="79.springboot的自动配置原理？"></a>79.springboot的自动配置原理？</h5><blockquote>
<p>1.通过@SpringBootConfiguration 引入了<strong>@EnableAutoConfiguration</strong> (负责启动自动配置功能） 2.@EnableAutoConfiguration 引入了<strong>@Import</strong> 3.Spring容器启动时：加载IoC容器时会解析@Import 注解</p>
</blockquote>
<ol>
<li>@Import导入了一个<strong>deferredImportSelector</strong>(它会使SpringBoot的自动配置类的顺序在最后，这样方便我们扩展和覆盖？) 5.然后读取所有的**&#x2F;META-INF&#x2F;spring.factories**文件（SPI)</li>
</ol>
<blockquote>
<p>6.过滤出所有<strong>AutoConfigurtionClass</strong>类型的类 7.最后通过<strong>@ConditioOnXXX</strong>排除无效的自动配置类</p>
<p><img src="/media/image54.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”6.65513779527559in” height&#x3D;”2.3357283464566927in”}</p>
</blockquote>
<h5 id="80-为什么SpringBoot的jar可以直接运行？"><a href="#80-为什么SpringBoot的jar可以直接运行？" class="headerlink" title="80.为什么SpringBoot的jar可以直接运行？"></a>80.为什么SpringBoot的jar可以直接运行？</h5><ol>
<li><p>SpringBoot提供了一个插件spring-boot-maven-plugin用于把程序打包成一个可执行的jar包。</p>
</li>
<li><p>Spring Boot应用打包之后，生成一个Fat jar(jar包中包含jar)，包含了应用依赖的jar包和Spring Boot loader相关的类。</p>
</li>
<li><p>java -jar会去找jar中的manifest文件，在那里面找到真正的启动类（Main-Class）；</p>
</li>
<li><p>Fat jar的启动Main函数是JarLauncher，它负责创建一个LaunchedURLClassLoader来加载boot-lib下面的jar，并以一个新线程启动应用的启动类的Main函数（找到manifest中的Start-Class）。</p>
</li>
</ol>
<h5 id="81-SpringBoot的启动原理？"><a href="#81-SpringBoot的启动原理？" class="headerlink" title="81.SpringBoot的启动原理？"></a>81.SpringBoot的启动原理？</h5><ol>
<li>运行main方法： 初始化new SpringApplication 从spring.factories 读取 listener ApplicationContextInitializer 。</li>
</ol>
<blockquote>
<p><img src="/media/image55.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”4.33217738407699in” height&#x3D;”0.9406244531933509in”}</p>
<p>2.运行run方法</p>
</blockquote>
<ol start="3">
<li><p>读取 环境变量 配置信息.….</p>
</li>
<li><p>创建springApplication上下文:<strong>ServletWebServerApplicationContext</strong></p>
</li>
<li><p>预初始化上下文 ： 将启动类作为配置类进行读取--&gt;将配置注册为BeanDefinition 6.调用refresh 加载IoC容器</p>
</li>
</ol>
<blockquote>
<p>invokeBeanFactoryPostProcessor -- 解析@Import: 加载所有的自动配置类 onRefresh 创建(内置)servlet容器</p>
<p>7.在这个过程中springboot会调用很多监听器对外进行扩展</p>
<p><img src="/media/image56.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”6.889550524934383in” height&#x3D;”8.06in”}</p>
</blockquote>
<h5 id="82-SpringBoot内置Tomcat启动原理？"><a href="#82-SpringBoot内置Tomcat启动原理？" class="headerlink" title="82.SpringBoot内置Tomcat启动原理？"></a>82.SpringBoot内置Tomcat启动原理？</h5><blockquote>
<p>当依赖Spring-boot-starter-web依赖时会在SpringBoot中添加：ServletWebServerFactoryAutoConfiguration servlet容器自动配置类</p>
<p>该自动配置类通过@Import导入了可用(通过@ConditionalOnClass判断决定使用哪一个)的一个Web容器工厂（默认Tomcat)在内嵌Tomcat类中配置了一个TomcatServletWebServerFactory的Bean（Web容器工厂）</p>
<p>它会在SpringBoot启动时 加载IoC容器(refresh) OnRefersh 创建内嵌的Tomcat并启动</p>
<p><img src="/media/image57.png" srcset="/img/loading.gif" lazyload>{width&#x3D;”4.273486439195101in” height&#x3D;”8.429791119860017in”}</p>
</blockquote>
<h5 id="83-SpringBoot外置Tomcat启动原理？"><a href="#83-SpringBoot外置Tomcat启动原理？" class="headerlink" title="83.SpringBoot外置Tomcat启动原理？"></a>83.SpringBoot外置Tomcat启动原理？</h5><blockquote>
<p>servlet3.0 规范官方文档： 8.2.4</p>
</blockquote>
<p><img src="/media/image58.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”6.757574365704287in” height&#x3D;”1.7179166666666668in”}</p>
<blockquote>
<p>大概： 当servlet容器启动时候 就会去META-INF&#x2F;services 文件夹中找到javax.servlet.ServletContainerInitializer， 这个文件里面肯定绑定一个ServletContainerInitializer. 当servlet容器启动时候就会去该文件中找到ServletContainerInitializer的实现类，从而创建它的实例调用onstartUp</p>
<p>@HandlesTypes(WebApplicationInitializer.class).</p>
<p>@HandlesTypes传入的类为ServletContainerInitializer感兴趣的</p>
<p>容器会自动在classpath中找到 WebApplicationInitializer 会传入到onStartup方法的 webAppInitializerClasses中</p>
<p>Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses 这里面也包括之前定义的TomcatStartSpringBoot</p>
<p><img src="/media/image59.png" srcset="/img/loading.gif" lazyload>{width&#x3D;”5.759113079615048in” height&#x3D;”1.96875in”}</p>
<p>SpringBootServletInitializer</p>
<p>之前定义的TomcatStartSpringBoot 就是继承它</p>
<p>当调用configure就会来到TomcatStartSpringBoot .configure</p>
<p>将Springboot启动类传入到builder.source</p>
<p>&#x2F;&#x2F; 调用SpringApplication application &#x3D; builder.build(); 就会根据传入的Springboot启动类来构建一个SpringApplication</p>
<p>&#x2F;&#x2F; 调用 return run(application); 就会帮我启动springboot应用</p>
<p>它就相当于我们的</p>
<p><strong>84.会不会SpringBoot自定义Starter？大概实现过程？</strong></p>
</blockquote>
<ol start="2">
<li><p>HelloProperties</p>
</li>
<li><p>IndexController</p>
</li>
<li><p>HelloAutoConfitguration</p>
</li>
<li><p>spring.factories</p>
</li>
</ol>
<blockquote>
<p>在 resources 下创建文件夹 META-INF 并在 META-INF 下创建文件 spring.factories ，内容如下：</p>
<p><img src="/media/image60.png" srcset="/img/loading.gif" lazyload>{width&#x3D;”2.066052055993001in” height&#x3D;”0.56375in”}</p>
<p><img src="/media/image61.png" srcset="/img/loading.gif" lazyload>{width&#x3D;”1.9672637795275592in” height&#x3D;”1.8073742344706911in”}到这儿，我们的配置自定义的starter就写完了 ，我们hello-spring-boot-starter-autoconfigurer、hello-spring-boot- starter 安装成本地jar包。</p>
</blockquote>
<h5 id="85-SpringBoot读取配置文件的原理是什么？加载顺序是怎样的"><a href="#85-SpringBoot读取配置文件的原理是什么？加载顺序是怎样的" class="headerlink" title="85.SpringBoot读取配置文件的原理是什么？加载顺序是怎样的?"></a>85.SpringBoot读取配置文件的原理是什么？加载顺序是怎样的?</h5><blockquote>
<p>通过事件监听的方式读取的配置文件：ConfigFileApplicationListener优先级从高到低，高优先级的配置覆盖低优先级的配置，所有配置会形成互补配置。</p>
</blockquote>
<h5 id="86-SpringBoot的默认日志实现框架是什么？怎么切换成别的？"><a href="#86-SpringBoot的默认日志实现框架是什么？怎么切换成别的？" class="headerlink" title="86.SpringBoot的默认日志实现框架是什么？怎么切换成别的？"></a>86.SpringBoot的默认日志实现框架是什么？怎么切换成别的？</h5><p><img src="/media/image62.png" srcset="/img/loading.gif" lazyload>{width&#x3D;”6.829580052493438in” height&#x3D;”2.6679166666666667in”}</p>
<blockquote>
<p>总结：</p>
</blockquote>
<ol>
<li><p>SpringBoot底层也是使用slf4j+logback的方式进行日志记录</p>
<p>a.  logback桥接：logback-classic</p>
</li>
<li><p>SpringBoot也把其他的日志都替换成了slf4j；</p>
<p>a.  log4j 适配： log4j-over-slf4j</p>
<p>b.  jul适配：jul-to-slf4j</p>
<p>c.  这两个适配器都是为了适配Spring的默认日志：jc</p>
</li>
</ol>
<h5 id="切换日志框架"><a href="#切换日志框架" class="headerlink" title="切换日志框架"></a>切换日志框架</h5><blockquote>
<p>将 logback切换成log4j2</p>
</blockquote>
<ol>
<li><p>将logback的场景启动器排除（slf4j只能运行有1个桥接器）</p>
</li>
<li><p>添加log4j2的场景启动器</p>
</li>
<li><p>添加log4j2的配置文件</p>
</li>
</ol>
<blockquote>
<p>将 logback切换成log4j</p>
</blockquote>
<ol>
<li><p>要将logback的桥接器排除</p>
</li>
<li><p>添加log4j的桥接器</p>
</li>
<li><p>添加log4j的配置文件</p>
</li>
</ol>
<blockquote>
<p>log4j.properties</p>
</blockquote>
<h5 id="87-说说你在开发的时候怎么在SpringBoot的基础上做扩展？"><a href="#87-说说你在开发的时候怎么在SpringBoot的基础上做扩展？" class="headerlink" title="87.说说你在开发的时候怎么在SpringBoot的基础上做扩展？"></a>87.说说你在开发的时候怎么在SpringBoot的基础上做扩展？</h5><blockquote>
<p>首先肯定要确认你扩展的技术点（比如扩展的是aop)打开aop自动配置类:</p>
<p>重点关注@ConditionalOnXXX 它可以帮助开启或关闭 某些功能 深入看源码 有些自动配置类 提供对外的扩展接口、实现接口也可以进行扩展</p>
</blockquote>
<h1 id="十、微服务"><a href="#十、微服务" class="headerlink" title="十、微服务"></a>十、微服务</h1><h5 id="88、微服务架构的优缺点"><a href="#88、微服务架构的优缺点" class="headerlink" title="88、微服务架构的优缺点"></a>88、微服务架构的优缺点</h5><ol>
<li><p>演变而来（从单体应用演变过来）</p>
</li>
<li><p>初期评估起手就上微服务</p>
</li>
</ol>
<h5 id="分工协作"><a href="#分工协作" class="headerlink" title="分工协作"></a>分工协作</h5><p><strong>单体：</strong>影响开发效率，发布和迭代性差；项目启动慢， 每个人对整体的项目都要有所把握； 业务缩减后如果</p>
<blockquote>
<p>语言不一致开发人员面临流失。</p>
<p><strong>拆分：提高开发效率</strong>和敏捷性ꞏ；单个服务启动快， 专人处理专事专注自己的服务； 充分利用项目开发人员</p>
<p>（哪怕是不同的语言不同框架，不同存储技术，也可以）</p>
</blockquote>
<h5 id="并发能力"><a href="#并发能力" class="headerlink" title="并发能力"></a>并发能力</h5><blockquote>
<p><strong>单体：</strong>整体集群，易造成系统资源浪费； 之前下单功能要去集群无法准确评测最大并发量， 因为所有的功能都在一起，无法准确预估扩容的服务器。</p>
<p><strong>拆分：</strong>服务集群，充分利用服务器资源； 现在只需要针对下单服务进行压测就可以得到，下单功能具体能承受的并发量最高水位，从而更准确的进行扩容。</p>
</blockquote>
<h5 id="维护能力（维护困难）"><a href="#维护能力（维护困难）" class="headerlink" title="维护能力（维护困难）"></a>维护能力（维护困难）</h5><blockquote>
<p><strong>单体：</strong>随着业务量增加，应用慢慢膨胀，后续可能会变得牵一发而动全身，难以维护。<strong>拆分：</strong>根据功能垂直拆分，责任更加分明，维护更加精准。</p>
</blockquote>
<h5 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h5><blockquote>
<p><strong>单体</strong>：单点故障，一个功能OOM导致整个应用都不可用</p>
<p><strong>拆分</strong>：弱依赖的服务出现故障，可以进行熔断（隔离） 依然不影响主业务正常使用</p>
</blockquote>
<h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><blockquote>
<p><strong>单体</strong>：难以技术升级</p>
<p><strong>拆分</strong>：新的服务采用任意新技术（技术多样性）</p>
</blockquote>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><h6 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h6><blockquote>
<p>分布式系统较难编程，因为远程调用速度很慢，并且总是面临失败的风险。对于开发人员的技术要求更高<strong>最终一致性</strong></p>
<p>对于分布式系统而言，保持强一致性非常困难，这意味着每个人都必须管理最终一致性。<strong>运维复杂性</strong></p>
<p>微服务必定带来开发、上线、运维的复杂度的提高，如果说单体应用复杂度为 10，实施了微服务后的复杂度将是 100，配备了相应的工具和平台后，可以将复杂度降低到 50，但仍然比单体复杂的多。</p>
</blockquote>
<h6 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h6><blockquote>
<p>服务和服务之间通过接口来”联系”，当某一个服务更改接口格式时，可能涉及到此接口的所有服务都需要做调整。<strong>重复劳动</strong></p>
<p>在很多服务中可能都会使用到同一个功能，而这一功能点没有足够大到提供一个服务的程度，这个时候可能不同的服务团队都会单独开发这一功能，重复的业务逻辑，这违背了良好的软件工程中的很多原则。</p>
</blockquote>
<h5 id="89-SOA、分布式、微服务之间有什么关系和区别？"><a href="#89-SOA、分布式、微服务之间有什么关系和区别？" class="headerlink" title="89.SOA、分布式、微服务之间有什么关系和区别？"></a>89.SOA、分布式、微服务之间有什么关系和区别？</h5><blockquote>
<p>1分布式架构是指将单体架构中的各个部分拆分，然后部署不同的机器或进程中去，SOA和微服务基本上都是分布式架构的</p>
<p>2SOA是一种面向服务的架构，系统的所有服务都注册在总线上，当调用服务时，从总线上查找服务信息，然后调用</p>
<p>3微服务是一种更彻底的面向服务的架构，将系统中各个功能个体抽成一个个小的应用程序，基本保持一个应用对应的一个服务的架构</p>
<p><strong>90.怎么拆分微服务、拆分时机是什么？</strong></p>
<p><strong>怎么拆：</strong></p>
<p>1、高内聚低耦合，职责单一，服务粒度适中，服务不要太细（有的团队甚至一个接口一个服务，一个表一个服务）</p>
<p>2、以业务模型切入：比如产品，用户，订单为一个模型来切入）</p>
<p>3、演进式拆分：刚开始不要划分太细，可以随着迭代过程来逐步优化。</p>
</blockquote>
<p><img src="/media/image63.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”5.481999125109361in” height&#x3D;”1.9739577865266842in”}</p>
<blockquote>
<p>微服务 1.0，仅使用注册发现，基于 SpringCloud 或者 Dubbo 进行开发，目前意图实施微服务的传统企业大部分处于这个阶段，或者正从单体应用，向这个阶段过渡，处于 0.5 的阶段；</p>
<p>微服务 2.0，使用了熔断，限流，降级等服务治理策略，并配备完整微服务工具和平台，目前大部分互联网企业处于这个阶段。传统企业中的领头羊，在做互联网转型的过程中，正在向这个阶段过渡，处于 1.5 的阶段；</p>
<p>微服务 3.0，Service Mesh 将服务治理作为通用组件，下沉到平台层实现，使得应用层仅仅关注业务逻辑，平台层可以根据业务监控自动调度和参数调整，实现 AIOps 和智能调度。目前一线互联网公司在进行这方面的尝试。</p>
</blockquote>
<p>####### 拆分时机：</p>
<blockquote>
<p><strong>业务量足够大，足够成本（投入成本、时间成本）</strong></p>
<p>首先，如果是预估到业务在飞速增长，那就别犹豫，一定要提前考虑微服务的拆分。其次，如果在设计架构的时候，发现需要很多异构的技术栈，那也要考虑下微服务。</p>
<p>最后，如果公司技术基础设施非常完备，对应的业务起初就设计的非常复杂，那么也别犹豫，起手就上微服务。</p>
</blockquote>
<h5 id="width-”6-83325678040245in”-height-”2-384325240594926in”-91-Spring-Cloud有哪些常用组件，作用是什么？"><a href="#width-”6-83325678040245in”-height-”2-384325240594926in”-91-Spring-Cloud有哪些常用组件，作用是什么？" class="headerlink" title="{width&#x3D;”6.83325678040245in” height&#x3D;”2.384325240594926in”}91.Spring Cloud有哪些常用组件，作用是什么？"></a><img src="/media/image64.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”6.83325678040245in” height&#x3D;”2.384325240594926in”}91.Spring Cloud有哪些常用组件，作用是什么？</h5><blockquote>
<p>注册中心：管理服务</p>
<p>负载均衡：客户端的负载均衡器</p>
<p>服务调用：使远程服务调用更加优雅配置中心：管理服务的配置</p>
<p>服务熔断：保证应用高可用 防止出现服务雪崩，防止激增流量打垮冷系统.….分布式事务：Seata</p>
<p>网关：为客户端提供统一的服务，一些跟业务本身功能无光的公共逻辑都可以放在网关实现：鉴权、日志、限流、跨域、路由转发.…</p>
<p>链路追踪：实时追踪服务的监控状况，协助快速恢复</p>
</blockquote>
<h5 id="92-注册中心的原理是什么？"><a href="#92-注册中心的原理是什么？" class="headerlink" title="92.注册中心的原理是什么？"></a>92.注册中心的原理是什么？</h5><p><img src="/media/image65.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”5.569900481189851in” height&#x3D;”3.180833333333333in”}</p>
<blockquote>
<p>服务注册： 当服务启动 通过Rest请求的方式向Nacos Server注册自己的服务</p>
<p>服务心跳：Nacose Client 会维护一个定时心跳持续通知Nacos Server ， 默认5s一次， 如果nacos Client超过了15秒没有接收心跳，会将服务健康状态设置false（拉取的时候会忽略）， 如果nacos Client超过了30 秒没有接收心跳 剔除服务。</p>
<p>服务发现：Nacose Client 会有一个定时任务，实时去Nacos Server 拉取健康服务服务停止： Nacose Client 会主动通过Rest请求Nacos Server 发送一个注销的请求</p>
</blockquote>
<h5 id="93-谈谈配置中心？"><a href="#93-谈谈配置中心？" class="headerlink" title="93.谈谈配置中心？"></a>93.谈谈配置中心？</h5><blockquote>
<p><img src="/media/image66.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”6.682064741907261in” height&#x3D;”2.6774989063867016in”}</p>
<p>集中管理服务的配置、提高维护性、时效性、安全性<strong>有哪些东西可以作为配置？</strong></p>
<p>比方说，数据库连接Url，缓存连接url字符串，数据库的用户名，密码都可以作为配置的字符串，除此之外，还有一些可以动态调整的参数，比方说，客户端的超时设置限流规则和降级开关，流量的动态调度，比方说某个功能只是针对某个地区用户，还有某个功能只在大促的时段开放，如果这种需要通过静态的方式去配置或者发布的方式去配置，那么响应速度是非常慢，可能对业务存在风险，如果有一套集中式的配置中心，只需要相关人员在配置中心动态去调整参数，就基本上可以实时或准实时去调整相关对应的业务。所以配置中心在微服务中算是一个举足轻重的组件。</p>
</blockquote>
<h5 id="推还是拉"><a href="#推还是拉" class="headerlink" title="推还是拉"></a>推还是拉</h5><blockquote>
<p>现在我们了解了 Nacos 的配置管理的功能了，但是有一个问题我们需要弄明白，那就是 Nacos 客户端是怎么实时获取到 Nacos 服务端的最新数据的。</p>
<p>其实客户端和服务端之间的数据交互，无外乎两种情况：服务端推数据给客户端</p>
<p>客户端从服务端拉数据</p>
<p>那到底是推还是拉呢，从 Nacos 客户端<strong>通过 Listener</strong> 来接收最新数据进行分析</p>
<p><img src="/media/image67.png" srcset="/img/loading.gif" lazyload>{width&#x3D;”6.327788713910762in” height&#x3D;”2.7636450131233596in”}</p>
<p>原理：</p>
<p>Nacos 服务端创建了相关的配置项后，客户端就可以进行监听了。</p>
<p>客户端是通过一个定时任务来检查自己监听的配置项的数据的，一旦服务端的数据发生变化时，客户端将会获取到最新的数据，并将最新的数据保存在一个 CacheData 对象中，然后会重新计算 CacheData 的 md5 属性的值，此时就会对该 CacheData 所绑定的 Listener 触发 receiveConfigInfo（接收配置信息） 回调。</p>
</blockquote>
<h5 id="拉的优势"><a href="#拉的优势" class="headerlink" title="拉的优势"></a>拉的优势</h5><blockquote>
<p>客户端拉取服务端的数据与服务端推送数据给客户端相比，优势在哪呢，为什么 Nacos 不设计成主动推送数据，而是要客户端去拉取呢？如果用推的方式，服务端需要维持与客户端的长连接，这样的话需要耗费大量的资源，并且还需要考虑连接的有效性，例如需要通过心跳来维持两者之间的连接。而用拉的方式，客户端只需要通过一个无状态的 http 请求即可获取到服务端的数据。</p>
</blockquote>
<h5 id="94-说说服务网关可以做什么？"><a href="#94-说说服务网关可以做什么？" class="headerlink" title="94.说说服务网关可以做什么？"></a>94.说说服务网关可以做什么？</h5><blockquote>
<p><img src="/media/image68.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”4.2866283902012245in” height&#x3D;”2.1328116797900263in”}</p>
<p>面对互联网复杂的业务系统，基本可以将服务网关分成两类：流量网关和业务网关。</p>
<p><strong>流量网关：</strong>跟具体的后端业务系统和服务完全无关的部分，比如安全策略、全局性流控策略、流量分发策略等。</p>
<p><strong>业务网关：</strong>针对具体的后端业务系统，或者是服务和业务有一定关联性的部分，并且一般被直接部署在业务服务的前面。业务网关一般部署在流量网关之后，业务系统之前，比流量网关更靠近系统。我们大部分情况下说的 API 网关，狭义上指的是业务网关。并且如果系统的规模不大，我们也会将两者合二为一，使用一个网关来处理所有的工作</p>
</blockquote>
<h5 id="95-什么是服务雪崩？什么是服务限流？"><a href="#95-什么是服务雪崩？什么是服务限流？" class="headerlink" title="95.什么是服务雪崩？什么是服务限流？"></a>95.什么是服务雪崩？什么是服务限流？</h5><p><img src="/media/image69.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”6.721771653543307in” height&#x3D;”3.0795833333333333in”}</p>
<blockquote>
<p><strong>服务雪崩效应</strong>： 因服务提供者的不可用导致服务调用者的不可用，并将不可用逐渐放大的过程，就叫服务雪崩效应解决方式：</p>
<p><strong>通过熔断机制，</strong>当一个服务挂了，被影响的服务能够及时熔断，使用 Fallback 数据保证流程在非关键服务不可用的情况下，仍然可以进行。</p>
<p><strong>通过线程池和消息队列机制实现异步化</strong>，允许服务快速失败，当一个服务因为过慢而阻塞，被影响服务可以在超时后快速失败，不会影响整个调用链路。</p>
</blockquote>
<p><img src="/media/image70.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”4.32847331583552in” height&#x3D;”2.9182283464566927in”}</p>
<h5 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a>服务限流</h5><blockquote>
<p>是指在高并发请求下，为了保护系统，可以对访问服务的请求进行数量上的限制，从而防止系统不被大量请求压垮，在秒杀中，限流是非常重要的。</p>
</blockquote>
<h5 id="96-什么是服务熔断？什么是服务降级？区别是什么？"><a href="#96-什么是服务熔断？什么是服务降级？区别是什么？" class="headerlink" title="96.什么是服务熔断？什么是服务降级？区别是什么？"></a>96.什么是服务熔断？什么是服务降级？区别是什么？</h5><blockquote>
<p>1服务熔断（终止交易），当服务A调用的某个服务B不可用时，上游服务A为了保证自己不受影响，及时切断与服务B的通讯。以防服务雪崩。 防止服务雪崩一种措施</p>
</blockquote>
<ol start="2">
<li>服务降级（执行B计划）：提前预想好另外一种兜底措施， 可以进行后期补救。 直到服务B恢复，再恢复和B服务的正常通讯。 当被调用服务不可用时的一种兜底措施。</li>
</ol>
<h5 id="97-说说Seata的实现原理？"><a href="#97-说说Seata的实现原理？" class="headerlink" title="97.说说Seata的实现原理？"></a>97.说说Seata的实现原理？</h5><blockquote>
<p>在应用中Seata整体事务逻辑基于两阶段提交的模型，核心概念包含三个角色： TC：事务协调者，即独立运行的seata-server，用于接收事务注册，提交和回滚。 TM：事务发起者。用来告诉TC全局事务的开始，提交，回滚。 RM：事务资源，每一个RM都会作为一个分支事务注册在TC。</p>
</blockquote>
<h6 id="AT-Auto-Transaction-模式"><a href="#AT-Auto-Transaction-模式" class="headerlink" title="AT(Auto Transaction)模式"></a>AT(Auto Transaction)模式</h6><blockquote>
<p><strong>第一阶段</strong></p>
<p>过程：</p>
<p>TM 向 TC 申请开启一个全局事务，全局事务创建并生成一个全局唯一的XID。 XID 在微服务调用链路的上下文中传播。</p>
<p>假设运行：<strong>update</strong> product <strong>set name</strong> &#x3D; &#39;GTS&#39; <strong>where name</strong> &#x3D; &#39;TXC&#39;; &#x2F;&#x2F; id&#x3D;1</p>
</blockquote>
<ol>
<li><p>解析 SQL：得到 SQL 的类型（UPDATE），表（product），条件（where name &#x3D; &#39;TXC&#39;）等相关的信息。</p>
</li>
<li><p>查询前镜像：根据解析得到的条件信息，生成查询语句，定位数据。 select * from product where name</p>
</li>
</ol>
<blockquote>
<p>&#x3D; &#39;TXC&#39; 镜像前数据</p>
</blockquote>
<ol start="3">
<li><p>执行业务 SQL：更新这条记录的 name 为 &#39;GTS&#39;。</p>
</li>
<li><p>查询后镜像：根据前镜像的结果，通过 主键 定位数据。select * from produc where name &#x3D; &#39;TXC&#39; 镜像后数据</p>
</li>
<li><p>插入回滚日志：把前后镜像数据以及业务 SQL 相关的信息组成一条回滚日志记录，插入到 UNDO_LOG 表中。</p>
</li>
</ol>
<blockquote>
<p>提交前，RM 向 TC 注册分支：申请 product 表中，主键值等于 1 的记录的 全局锁 。</p>
</blockquote>
<ol start="6">
<li>本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。</li>
</ol>
<blockquote>
<p>TM 向 TC 发起针对 XID 的全局提交或回滚决议。将本地事务提交的结果上报给 TC</p>
</blockquote>
<p><img src="/media/image71.png" srcset="/img/loading.gif" lazyload>{width&#x3D;”6.7528685476815395in” height&#x3D;”3.315in”}</p>
<h3 id="二阶段-提交"><a href="#二阶段-提交" class="headerlink" title="二阶段-提交"></a>二阶段-提交</h3><blockquote>
<p>TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。</p>
</blockquote>
<ol>
<li><p>收到 TC 的分支提交请求，把请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。</p>
</li>
<li><p><img src="/media/image72.png" srcset="/img/loading.gif" lazyload>{width&#x3D;”6.625010936132983in” height&#x3D;”3.3821872265966753in”}异步任务阶段的分支:提交请求，将异步和批量地删除相应 UNDO LOG 记录。</p>
</li>
</ol>
<h3 id="二阶段-回滚"><a href="#二阶段-回滚" class="headerlink" title="二阶段-回滚"></a>二阶段-回滚</h3><blockquote>
<p>TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。</p>
</blockquote>
<ol>
<li><p>收到 TC 的分支回滚请求，开启一个本地事务，执行如下操作。</p>
</li>
<li><p>通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。</p>
</li>
<li><p>数据校验：拿 UNDO LOG 中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改（出现脏写），转人工处理（Seata 因为无法感知这个脏写如何发生，此时只能打印日志和触发异常通知，告知用户需要人工介入）</p>
</li>
<li><p>人工没有脏写就简单了：根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句：</p>
</li>
<li><p><img src="/media/image73.png" srcset="/img/loading.gif" lazyload>{width&#x3D;”6.692711067366579in” height&#x3D;”3.4070833333333335in”}提交本地事务。并把本地事务的执行结果（即分支事务回滚的结果）上报给 TC。</p>
</li>
</ol>
<blockquote>
<p><strong>98.你的微服务项目出了异常怎样更快速的定位？</strong></p>
<p><img src="/media/image74.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”5.977158792650918in” height&#x3D;”2.2691666666666666in”}</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ol>
<li>页面</li>
</ol>
<blockquote>
<p><img src="/media/image75.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”6.14278980752406in” height&#x3D;”3.0160411198600174in”}</p>
</blockquote>
<ol>
<li><p>报错通知</p>
<p>a.  DB</p>
</li>
</ol>
<blockquote>
<p><img src="/media/image76.png" srcset="/img/loading.gif" lazyload>{width&#x3D;”4.243413167104112in” height&#x3D;”4.336770559930009in”}</p>
<p>i.</p>
<p>1. Hystrix</p>
<p><img src="/media/image77.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”4.311620734908137in” height&#x3D;”2.9624989063867018in”}</p>
</blockquote>
<h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><blockquote>
<p>1. hystrix</p>
<p><img src="/media/image78.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”6.114226815398076in” height&#x3D;”3.1240616797900262in”}</p>
<p><img src="/media/image79.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”6.135669291338583in” height&#x3D;”3.2621872265966756in”}</p>
</blockquote>
<ol>
<li>日志</li>
</ol>
<blockquote>
<p><img src="/media/image80.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”6.4217049431321085in” height&#x3D;”3.4239577865266844in”}</p>
<p>a.</p>
</blockquote>
<h3 id="动态日志级别调整"><a href="#动态日志级别调整" class="headerlink" title="动态日志级别调整"></a>动态日志级别调整</h3><ol>
<li><p>使用场景</p>
<p>a.  线上问题排查。</p>
</li>
<li><p>使用方式</p>
<p>a.  直接调整单个运行的节点的日志级别获取更详细的日志信息。</p>
</li>
<li><p>使用效果</p>
<p>a.  无需重启服务即可打印详细日志。</p>
<p>b.  单节点调整，不会影响其他节点。</p>
</li>
</ol>
<p><img src="/media/image81.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”6.187591863517061in” height&#x3D;”3.073124453193351in”}</p>
<h3 id="历史状态日志"><a href="#历史状态日志" class="headerlink" title="历史状态日志"></a>历史状态日志</h3><ol>
<li><p>查看一定时间内的微服务状态信息</p>
<p>a.  上线下情况</p>
<p>b.  访问情况</p>
<p>c.  异常情况及其详细信息</p>
<p>d.  状态变化时间点</p>
</li>
</ol>
<p><img src="/media/image82.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”5.765074365704287in” height&#x3D;”2.7454155730533683in”}</p>
<h3 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h3><ol>
<li><p>微服务执行对应数据库测试语句失败。</p>
</li>
<li><p>监控页面微服务对应颜色从绿色变成红色。</p>
</li>
<li><p>触发企业微信通知</p>
</li>
<li><p>相关人员获知微服务出现的异常情况与原因</p>
</li>
<li><p>解决问题</p>
<p>a.  可以通过异常信息直接判断异常原因</p>
<pre><code class="hljs">i.  直接进行相关处理。
</code></pre>
<p>b.  通过异常信息无法判断异常原因</p>
<pre><code class="hljs">i.  直接访问该微服务的异常节点查看相关日志。
</code></pre>
</li>
</ol>
<blockquote>
<p><img src="/media/image83.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”4.314992344706912in” height&#x3D;”5.498124453193351in”}</p>
</blockquote>
<p><img src="/media/image84.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”4.336924759405075in” height&#x3D;”2.0125in”}</p>
<h3 id="低版本问题"><a href="#低版本问题" class="headerlink" title="低版本问题"></a>低版本问题</h3><blockquote>
<p><img src="/media/image85.jpeg" srcset="/img/loading.gif" lazyload>{width&#x3D;”3.416393263342082in” height&#x3D;”3.610207786526684in”}</p>
</blockquote>
<ol>
<li><p>低版本的配置中心会每次检查都会访问一次配置中心数据</p>
<p>a.  解决方案</p>
<pre><code class="hljs">i.  升级为部门标准版本
</code></pre>
<p>b.  高版本优化</p>
<pre><code class="hljs">i.  加入缓存
</code></pre>
</li>
</ol>
<h5 id="99-Ribbon说说有哪些负载均衡策略"><a href="#99-Ribbon说说有哪些负载均衡策略" class="headerlink" title="99.Ribbon说说有哪些负载均衡策略"></a>99.Ribbon说说有哪些负载均衡策略</h5><p><img src="/media/image86.png" srcset="/img/loading.gif" lazyload>{width&#x3D;”6.723307086614173in” height&#x3D;”2.6303116797900263in”}</p>
<p>####### IRule</p>
<blockquote>
<p>这是所有负载均衡策略的父接口，里边的核心方法就是choose方法，用来选择一个服务实例。</p>
</blockquote>
<p>####### AbstractLoadBalancerRule</p>
<blockquote>
<p>AbstractLoadBalancerRule是一个抽象类，里边主要定义了一个ILoadBalancer，这里定义它的目的主要是辅助负责均衡策略选取合适的服务端实例。</p>
</blockquote>
<p>####### RandomRule</p>
<blockquote>
<p>看名字就知道，这种负载均衡策略就是<strong>随机选择一个服务实例</strong>，看源码我们知道，在RandomRule的无参构造方法中初始化了一个Random对象，然后在它重写的choose方法又调用了choose(ILoadBalancer lb， Object key)这个重载的choose方法，在这个重载的choose方法中，每次利用 random对象生成一个不大于服务实例总数的随机数，并将该数作为下标所以获取一个服务实例。</p>
</blockquote>
<p>####### RoundRobinRule</p>
<blockquote>
<p>RoundRobinRule这种负载均衡策略叫做线性<strong>轮询负载均衡策略</strong>。这个类的choose(ILoadBalancer lb， Object key)函数整体逻辑是这样的：开启一个计数器count，在while循环中遍历服务清单，获取清单之前先通过incrementAndGetModulo方法获取一个下标，这个下标是一个不断自增长</p>
<p>的数先加1然后和服务清单总数取模之后获取到的（所以这个下标从来不会越界），拿着下标再去服务清单列表中取服务，每次循环计数器都会加</p>
<p>1，如果连续10次都没有取到服务，则会报一个警告No available alive servers after 10 tries from load balancer: XXXX。</p>
<p><strong>RetryRule</strong>（在轮询的基础上进行重试）</p>
<p>看名字就知道这种负载均衡策略带有<strong>重试</strong>功能。首先RetryRule中又定义了一个subRule，它的实现类是RoundRobinRule，然后在RetryRule的 choose(ILoadBalancer lb， Object key)方法中，每次还是采用RoundRobinRule中的choose规则来选择一个服务实例，如果选到的实例正常就返回，如果选择的服务实例为null或者已经失效，则在失效时间deadline之前不断的进行重试（重试时获取服务的策略还是RoundRobinRule中定义的策略），如果超过了deadline还是没取到则会返回一个null。</p>
<p><strong>WeightedResponseTimeRule（</strong>权重 —nacos的NacosRule ，Nacos还扩展了一个自己的基于配置的权重扩展<strong>）</strong> WeightedResponseTimeRule是RoundRobinRule的一个子类，在WeightedResponseTimeRule中对RoundRobinRule的功能进行了扩展， WeightedResponseTimeRule中会根据每一个实例的运行情况来给计算出该实例的一个<strong>权重</strong>，然后在挑选实例的时候则根据权重进行挑选，这样能够实现更优的实例调用。WeightedResponseTimeRule中有一个名叫DynamicServerWeightTask的定时任务，默认情况下每隔30秒会计算一次各个服务实例的权重，权重的计算规则也很简单，<strong>如果一个服务的平均响应时间越短则权重越大，那么该服务实例被选中执行任务的概率也就越大</strong>。</p>
</blockquote>
<p>####### ClientConfigEnabledRoundRobinRule</p>
<blockquote>
<p>ClientConfigEnabledRoundRobinRule选择策略的实现很简单，内部定义了RoundRobinRule，choose方法还是采用了RoundRobinRule的 choose方法，所以它的选择策略<strong>和RoundRobinRule的选择策略一致</strong>，不赘述。</p>
</blockquote>
<p>####### BestAvailableRule</p>
<blockquote>
<p>BestAvailableRule继承自ClientConfigEnabledRoundRobinRule，它在ClientConfigEnabledRoundRobinRule的基础上主要增加了根据 loadBalancerStats中保存的服务实例的状态信息来<strong>过滤掉失效的服务实例的功能，然后顺便找出并发请求最小的服务实例来使用。</strong>然而 loadBalancerStats有可能为null，如果loadBalancerStats为null，则BestAvailableRule将采用它的父类即 ClientConfigEnabledRoundRobinRule的服务选取策略（线性轮询）。</p>
<p><strong>ZoneAvoidanceRule</strong> （<strong>默认规则</strong>，复合判断server所在区域的性能和server的可用性选择服务器。）</p>
<p>ZoneAvoidanceRule是PredicateBasedRule的一个实现类，只不过这里多一个过滤条件，ZoneAvoidanceRule中的过滤条件是以 ZoneAvoidancePredicate为主过滤条件和以</p>
<p>AvailabilityPredicate为次过滤条件组成的一个叫做CompositePredicate的组合过滤条件，过滤成功之后，继续采用线性轮询</p>
<p>(<strong>RoundRobinRule</strong>)的方式从过滤结果中选择一个出来。</p>
<p><strong>AvailabilityFilteringRule</strong>（先过滤掉故障实例，再选择并发较小的实例）</p>
<p>过滤掉一直连接失败的被标记为circuit tripped的后端Server，并过滤掉那些高并发的后端Server或者使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就是检查status里记录的各个Server的运行状态。</p>
</blockquote>
<h5 id="100-你项目哪些场景用到了限流、降级？怎么配的？"><a href="#100-你项目哪些场景用到了限流、降级？怎么配的？" class="headerlink" title="100.你项目哪些场景用到了限流、降级？怎么配的？"></a>100.你项目哪些场景用到了限流、降级？怎么配的？</h5><blockquote>
<p>服务降级的预案</p>
<p>在进行降级之前要对系统进行梳理，提前将一些 <strong>不重要</strong> 或 <strong>不紧急</strong> 的服务（弱依赖）或任务进行服务的 <strong>延迟使用</strong> 或 <strong>暂停使用</strong>。 （积分）看看哪些服务是必须誓死保护，哪些系统是能够丢卒保帅；具体可以参考日志级别设置预案：</p>
<p>一般：有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p>
<p>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p>
<p>错误：可用率低于90%，或者连接池被占用满了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p>
<p>严重错误：因为特殊原因数据错误了，此时需要紧急人工降级</p>
<p>测试会提供准确的数据；自己算： 二八法则</p>
<p>计算关系：</p>
<p>QPS &#x3D; 并发量 &#x2F; 平均响应时间并发量 &#x3D; QPS * 平均响应时间</p>
<p>根据以上计算关系，我们来预估下单日访问量在 1000W 需要多大的QPS来支持：</p>
<p>通常情况下，80% 的访问量集中在 20%的时间，算一下这 1000w pv实际需要机器达到多少qps才能满足， qps &#x3D; (1000w * 0.8) &#x2F; (24 * 3600 * 0.2)</p>
<p>qps &#x3D; 462.9</p>
<p>根据压力测试的反馈，单台机子的QPS是多少，利用以上结果就可以算出需要几台机器 或 大致推算出需不需要使用缓存配置方案一： 使用集群服务器 不使用缓存服务器</p>
<p>方案二： 使用集群服务器 同时使用缓存服务器 (推荐)例子：</p>
<p>每秒可以处理的请求数 QPS（TPS）：每秒钟可以处理的请求或者事务的数量。并发数： 系统同一时候处理的请求数量（事务数）</p>
<p>响应时间： 一般取平均响应时间 QPS（TPS）&#x3D; 并发数&#x2F;平均响应时间并发数 &#x3D; QPS*平均响应时间</p>
<p>例子:</p>
<p>一个典型的上班签到系统，早上8点上班。7点半到8点这30分钟的时间里用户会登录签到系统进行签到。公司员工为1000人，平均每一个员上登录签到系统的时长为5分钟。能够用以下的方法计算。</p>
<p>（1）QPS &#x3D; 1000&#x2F;(30*60) 事务&#x2F;秒</p>
<p>（2）平均响应时间为 &#x3D; 5*60 秒</p>
<p>（3）并发数&#x3D; QPS*平均响应时间 &#x3D; 1000&#x2F;(30*60) *(5*60)&#x3D;166.7</p>
<p>再看如果老板要求实现多少并发数，在反推出机器需要多少QPS，看是否集群配置。</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" class="category-chain-item">面试题</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Spring/" class="print-no-link">#设计模式 - Spring</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>设计模式面试题汇总</div>
      <div>http://coderdream.github.io/2024/02/28/quiz-spring-cloud/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>CoderDream</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年2月28日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/02/28/quiz-design-pattern%20-%20%E5%89%AF%E6%9C%AC/" title="设计模式面试题汇总">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">设计模式面试题汇总</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/02/20/windows-tools/" title="Windows 实用小工具">
                        <span class="hidden-mobile">Windows 实用小工具</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
